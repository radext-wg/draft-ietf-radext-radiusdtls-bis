{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-10-26T00:57:03.758124+00:00",
  "repo": "radext-wg/draft-ietf-radext-radiusdtls-bis",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "PR exists",
      "description": "",
      "color": "0E8A16"
    },
    {
      "name": "needs discussion",
      "description": "",
      "color": "e99695"
    },
    {
      "name": "WGLC Comment",
      "description": "",
      "color": "79be9f"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOLrzygc6HDCk-",
      "title": "Add / update text on UDP -> TCP and TCP -> UDP proxying issues",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/2",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "6613 etc. discuss UDP to TCP, but not TCP to UDP.\r\n\r\nPlus, there's the whole issue of Accounting-Request and Acct-Delay-Time being updated on retransmits.  Which contributes to congestive collapse when doing UDP to TCP proxying.\r\n\r\nFor TCP to UDP, it may be rarer, but it's possible.  Should the proxy then take care of retransmitting packets over UDP?\r\n\r\nI need to suggest some text.",
      "createdAt": "2024-04-26T12:50:13Z",
      "updatedAt": "2025-04-14T21:35:14Z",
      "closedAt": "2025-04-14T21:35:13Z",
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC 2866 says:\r\n\r\n```\r\n A forwarding server may either perform its forwarding function in a\r\n   pass through manner, where it sends retransmissions on as soon as it\r\n   gets them, or it may take responsibility for retransmissions, for\r\n   example in cases where the network link between forwarding and remote\r\n   server has very different characteristics than the link between NAS\r\n   and forwarding server.\r\n```\r\n\r\nAlex Clouter also mentioned we have the same issue on TCP -> TCP proxying, if the two connections have different throughputs",
          "createdAt": "2024-04-26T15:51:03Z",
          "updatedAt": "2024-04-26T15:51:03Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this can be closed, since proxying issues are out-of-scope for this document.",
          "createdAt": "2025-04-14T21:35:13Z",
          "updatedAt": "2025-04-14T21:35:13Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOLrzygc6st84w",
      "title": "clarity on (D)TLS record padding",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/24",
      "state": "CLOSED",
      "author": "jimdigriz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "PR exists"
      ],
      "body": "From[1]:\n```\nFor the receiving RADIUS/DTLS node, the length checks defined in [[RFC2865](https://www.rfc-editor.org/rfc/rfc2865)], [Section 3](https://rfc-editor.org/rfc/rfc2865#section-3) still apply, but MUST use the length of the decrypted DTLS record instead of the UDP packet length.\n```\n\nThis is confusing to me as I am aware UDP is (typically) being used in the mix here so I could unintentionally read this as if I need to figure out the size of the UDP packet the record came in which would be obviously unlikely to be even possible :)\n\nMaybe a rewording to be explicit that as the UDP packet length is no longer available nor meaningful the application is to use the TLS record length to determine the end of the RADIUS packet, so maybe wording along the lines of:\n\n\"... still apply, but the TLS record length is used in place of the now no longer available nor meaningful UDP packet length.\"\n\nFrom[2]\n```\nExaclty one RADIUS packet is encapsulated in a DTLS record, ...\n```\n\nTypo of `Exaclty` which should be `Exactly`.\n\nFrom[3]:\n```\nFor UDP packets containing multiple DTLS records, each DTLS record MUST be parsed individually and padding at the end of each DTLS record MUST be ignored, instead of treating it as the beginning of a new packet, as it would be treated with RADIUS/TLS.\n```\n\nIt is unclear if you mean here:\n\n * [(D)TLS record padding](https://datatracker.ietf.org/doc/html/rfc8446#section-5.4)\n * [RADIUS (plaintext) data padding](https://datatracker.ietf.org/doc/html/rfc2865#section-3)\n\nMaybe this is because when I think of the return from `SSL_read()` I do not think \"I have a TLS record\" but 'plaintext data'. The OpenSSL manpage does talk in terms of records though so not doubt the problem is more with me.\n\nI would suggest dropping the mentioning of padding altogether here as your first sentence[1] covers what to do and leave it as:\n\n\"For UDP packets containing multiple DTLS records, each DTLS record MUST be parsed individually.\"\n\n[1] https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/blob/d57d9a112ea3755738996987c40e6f92ec3b30c1/draft-ietf-radext-radiusdtls-bis.md?plain=1#L508\n[1] https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/blob/d57d9a112ea3755738996987c40e6f92ec3b30c1/draft-ietf-radext-radiusdtls-bis.md?plain=1#L509\n[2] https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/blob/d57d9a112ea3755738996987c40e6f92ec3b30c1/draft-ietf-radext-radiusdtls-bis.md?plain=1#L510\n\n",
      "createdAt": "2025-03-05T15:54:38Z",
      "updatedAt": "2025-05-27T08:54:26Z",
      "closedAt": "2025-05-27T08:54:25Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with #32 ",
          "createdAt": "2025-05-27T08:54:25Z",
          "updatedAt": "2025-05-27T08:54:25Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOLrzygc6ywMKh",
      "title": "Updating \"Connecting Client Identity\"",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/26",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per Fabians [comments on the mailing list](https://mailarchive.ietf.org/arch/msg/radext/pY_NTCPXAMb6Bgs018THc33rOEs):\n\nWe have the section \"Connecting Client Identity\"\nWhat do we need it for?\nIn practice, the identity of the client is not done with the identifiers listed in the text, but instead different identifies such as subjectAltName or similar certificate attributes",
      "createdAt": "2025-04-16T09:04:58Z",
      "updatedAt": "2025-07-20T12:58:46Z",
      "closedAt": "2025-07-20T12:58:46Z",
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's likely best to just wave your hands vigorously and state \"the client is uniquely identified by some TLS magic.  Client certs, PSK Identity, or other things\".\n\nWhile RFC 9525 defines Service Identity in TLS, there is no similar document for Client Identity.  Perhaps we'll add another item to the \"todo\" list for UTA.",
          "createdAt": "2025-04-16T11:42:56Z",
          "updatedAt": "2025-04-16T11:42:56Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "We'll just leave it as is, maybe it's good to have a description of an actual identity, even if we don't do anything in our document, but other (later) documents may use it.",
          "createdAt": "2025-07-20T12:58:46Z",
          "updatedAt": "2025-07-20T12:58:46Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOLrzygc6ywP1B",
      "title": "Discussion around PMTU discovery",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/27",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "PR exists"
      ],
      "body": "As per Fabians [comments on the mailing list](https://mailarchive.ietf.org/arch/msg/radext/pY_NTCPXAMb6Bgs018THc33rOEs):\n\nIn the section for client session management for DTLS, we recommend using PMTU discovery.\nWhy do we do this? Do we need it? What can the client do about it?",
      "createdAt": "2025-04-16T09:10:49Z",
      "updatedAt": "2025-05-27T08:54:52Z",
      "closedAt": "2025-05-27T08:54:51Z",
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, that caused me to go down a rabbit hole.\n\nFreeRADIUS has disabled MTU discovery since 2009.  The commit messages don't explain why, but a little more checking shows a message to the FreeRADIUS mailing list from Stefan Winter:\n\nhttps://lists.freeradius.org/pipermail/freeradius-devel/2009-August/004868.html\n\n> now this is unpleasant: Apparently, many OSes set the DF bit on every\n> datagram they send, if Path MTU discovery is turned on. Even on UDP packets.\n> This breaks your RADIUS communication if datagram > MTU. I have reason\n> to believe that this has led to numerous problems with EAP-TLS in\n> eduroam, for example.\n>\n> It is of course not in principle a FreeRADIUS problem, but an OS one\n> (speaking here of Linux in particular), but other software like BIND\n> takes precautions against that and I think it might be good to do the\n> same in FreeRADIUS as well (i.e. explicitly disable IP_DONTFRAG socket\n> option).\n\nThe Linux documentation pages describes some related behavior:\n\nhttps://man7.org/linux/man-pages/man7/ip.7.html\n\n> While MTU discovery is in progress, initial packets from\n> datagram sockets may be dropped.  Applications using UDP\n> should be aware of this and not take it into account for\n> their packet retransmit strategy.\n\nI would suspect this really means _\"Before MTU discover has occurred. packets which are larger than the path MTU may be silently dropped somewhere in the network.  Once MTU has been discovered, packets larger than path MTU will result in an EMSGSIZE error\"_\n\nSo what do we do about it?\n\nIf we have large EAP packets and a small local MTU, there isn't much we can do for UDP.  Doing PTMU discovery doesn't help the client, because it can't control the size of the RADIUS packets.  The client (or proxy) just sends the packet, and hopes for the best.\n\nIf the local network can handle fragmented UDP packets, everything works.  If the packets go across the wider Internet, then fragmented UDP packets will likely get dropped.\n\n\nFurther discussion of fragmentation issues is available at https://www.freeradius.org/documentation/freeradius-server/4.0.0/trouble-shooting/connect_nas.html#_identifying_broken_path_mtu_discovery\n\nSo the issues are:\n\n* If you're using UDP, you may be affected by packet fragmentation. \n  *  It's more likely when EAP is being used, but it can happen in other situations, such as when the Access-Accept contains a long list of filter rules (RFC7499 can help here)\n* PMTU discovery doesn't help, as the RADIUS client often doesn't control the contents / size of the packet.\n* RADIUS offers no way to fragment Access-Request data across multiple packets.\n  * So even if the client does PMTU discovery, there's little that it can do with that information\n* most local networks will support fragmented UDP packets, so the client can just send the packet and hope for the best\n* PMTU discovery only really helps when you're sending packets across the Internet where fragmented UDP packets are discarded\n  * i.e. PTMU discovery means that when a proxy sends a large UDP packet, it gets an immediate `EMSGSIZE` error.\n  * the proxy can then take action.\n    *  send the packet over another connection\n    * signal the client via Protocol-Error\n  * this explicit signal is much better than waiting for a reply which will never arrive\n\nThis is all a bit much for the TLSbis document.  Perhaps it's best to just say \"UDP fragments might work on local networks, and are likely to not work across the wider Internet.  PMTU discovery doesn't necessarily help.  If you're not sure, just use TCP\".",
          "createdAt": "2025-04-16T11:38:30Z",
          "updatedAt": "2025-04-16T11:38:30Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with #27",
          "createdAt": "2025-05-27T08:54:51Z",
          "updatedAt": "2025-05-27T08:54:51Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOLrzygc6ywrMH",
      "title": "TLS Record count limitation",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/28",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "PR exists"
      ],
      "body": "In (D)TLS, we can only encrypt a limited number of records until the security degrades.\nFor RADIUS/(D)TLS we have long-lived TLS sessions where we might reach this limit.\n\nWe need to decide whether or not we put some normative/informational text in the document.\nInstead we could leave this to the uta or tls WG and say nothing about this.",
      "createdAt": "2025-04-16T09:52:49Z",
      "updatedAt": "2025-05-27T08:58:05Z",
      "closedAt": "2025-05-27T08:58:04Z",
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there a TLS/DTLS RFC which mentions this issue?  If so, we can just reference that.  We don't need to mention this issue specifically.\n\nIf not, we could put it on the list of things to do for UTA.",
          "createdAt": "2025-04-16T11:02:56Z",
          "updatedAt": "2025-04-16T11:02:56Z"
        },
        {
          "author": "smyslov",
          "authorAssociation": "NONE",
          "body": "Section 5.5 of RFC 8446 for TLS 1.3 sets the limits for AES-GCM and ChaCha20-Poly1305. There is also more generic document for AEAD limits: https://datatracker.ietf.org/doc/draft-irtf-cfrg-aead-limits/",
          "createdAt": "2025-05-07T05:58:47Z",
          "updatedAt": "2025-05-07T05:59:05Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with #31 ",
          "createdAt": "2025-05-27T08:58:04Z",
          "updatedAt": "2025-05-27T08:58:04Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOLrzygc61asnx",
      "title": "Client Connection Attempts",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/29",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs discussion"
      ],
      "body": "OpenRoaming implementers have seen issues where RADIUS/TLS clients repeatedly try to connect to servers, despite their connections not being accepted\n\nThat is, the TCP port is open, but after exchanging TLS data, the server decides that the client should not be allowed access, and closes the connection.  This usually happens when the client is misconfigured:\n\n* client is using the wrong credentials (invalid PSK or client certificate from unknown or wrong CA)\n  * Section 4.3 discusses client identity, and states that depending on the presented credentials,\n\n```\nthe server may decline to perform RADIUS transactions with this client`\n``` \n* the client is coming from an untrusted network.\n  *  Section 7.3 of this document discusses filtering\n\n```\nIf every RADIUS/(D)TLS client is configured with an IP range, then the server does not even have to perform a partial TLS handshake if the connection attempt comes from outside every allowed range, but can instead immediately drop the connection.\n```\n\nThe observed behavior is that some clients are attempting to reconnect multiple times a second, which is unfriendly.\n\nThe current Section 4 has no text on reconnection attempts.  Perhaps we could add a section to discuss this, using timers similar to [RFC 5080 Section 2.2.1](https://www.rfc-editor.org/rfc/rfc5080.html#section-2.2.1)\n\n---\n\n4.8 Client Connection Attempts\n\nWhen a client fails to open a connection, it SHOULD wait for a\nperiod of time, and then try the connection attempt again.\n\nSome existing RADIUS clients implement excessively aggressive\nreconnection behavior, utilizing default reconnection timeouts of\none second or less without support for congestive backoff.  When\ndeployed at a large scale, these implementations are susceptible to\ncongestive collapse. \n\nRADIUS client connection timers are based on the model used RFC 5080\nSection 2.2.1.  Variables used here are also borrowed from this\nspecification.  The connection attempts terminate when the client\nsuccessfully connects to the server, or the connection attempts are\nconsidered to have failed according to the reconnection\nmechanism described below.  Other reconnection mechanisms are\npossible, as long as they satisfy the requirements on jitter and\ncongestive backoff.\n\nThe following algorithms MUST be implemented by any client that originates RADIUS/TLS\nconnections.\n\nThe reconnection behavior is controlled and described by the\nfollowing variables:\n\n      RT     Reconnection timeout\n\n      IRT    Initial reconnection time  (default 2 seconds)\n\n      MRC    Maximum reconnection count (default 15 attempts)\n\n      MRT    Maximum reconnection time (default 300 seconds)\n\n      MRD    Maximum reconnection duration (default 3600 seconds)\n\n      RAND   Randomization factor\n\nWith each connection attempt, the sender sets RT according to the\nrules given below.  If RT expires before the connection is successful,\nthe sender re-computes RT and makes another connection attempt.\n\nEach of the computations of a new RT include a randomization factor\n(RAND), which is a random number chosen with a uniform distribution\nbetween -0.1 and +0.1.  The randomization factor is included to\nminimize the synchronization of messages.\n\nThe algorithm for choosing a random number does not need to be\ncryptographically sound.  The algorithm SHOULD produce a different\nsequence of random numbers from each invocation.\n\nRT for the first connection attempt is based on IRT:\n\n      RT = IRT + RAND*IRT\n\nRT for each subsequent connection attempt is based on the\nprevious value of RT:\n\n      RT = 2*RTprev + RAND*RTprev\n\nMRT specifies an upper bound on the value of RT (disregarding the\nrandomization added by the use of RAND).  If MRT has a value of 0,\nthere is no upper limit on the value of RT.  Otherwise:\n\n      if (RT > MRT)\n         RT = MRT + RAND*MRT\n\nMRD specifies an upper bound on the length of time that a\nclient may try to connect to a server.  The client stops its'\nconnection attempts when MRD seconds have elapsed since it first\nattempted to connect .  MRD MUST be set, MUST NOT have a value higher\nthan 86400 seconds.  MRD SHOULD have a value between 300 and 86400\nseconds.\n\nMRC specifies an upper bound on the number of times a client may try\nto reconnect to a server.  If MRC is zero, The client stops its'\nconnection attempts once MRD seconds have elapsed since the client\nfirst attempted to connect.  If MRC is non-zero, The client stops its'\nconnection attempts when either it as tried MRC connection attempts,\nor when MRD seconds have elapsed since the client first attempted to\nconnect.\n\nThe recommended values for these variables are a balance between\nenabling fast reconnection when there are transient network outages,\nand acknowledging that infinite retries are not desired.  That is, if\na RADIUS server cannot be reached within a day, then the problem is\nlikely due to client misconfiguration, and is not due to a transient network\noutage.  Once a client stops its reconnection attempts due to reaching\nMRC or MRD, it SHOULD log a descriptive error indicating that the\nserver is unreachable.  This error serves as an indication that\nadministrator intervention is needed.\n\nThe client then MUST NOT make any more connection attempts until an\nadministrator has intervened.  This administrator intervention could take any form,\nsuch as setting a \"reconnect now\" flag.  Other forms of this\nintervention are implementation defined, and are outside of the scope\nof this specification.\n",
      "createdAt": "2025-05-06T18:31:05Z",
      "updatedAt": "2025-07-07T16:22:36Z",
      "closedAt": "2025-07-07T16:22:36Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "The question here is: Is this relevant for RADIUS/(D)TLS or is this a general RADIUS (Proxying) issue and therefore out of scope?\n\nI would be reluctant to add so much text at this point.\n\nMy suggestion would be to add a small paragraph about this as a heads-up for implementers, but keep the exact algorithm out of this document and put it in a RADIUS best practices document.",
          "createdAt": "2025-05-12T14:41:02Z",
          "updatedAt": "2025-05-12T14:41:02Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue is only for RADIUS/(D)TLS and RADIUS/TCP.  Those transports have connections between the client and server.\n\nRADIUS/UDP doesn't have connections.  Even connected UDP sockets are pretty bad, and don't always work the way you would think.  RADIUS/UDP historically has just done per-packet retransmissions, and completely ignored the idea of a \"connection\".\n\nSo since this is an issue for RADIUS/(D)TLS, and not so much for RADIUS/UDP, I think it's OK to add here.\n\nIf we don't add it here, then this text will have to wait for a new standards-track document.  Which is likely to be a long time coming.",
          "createdAt": "2025-05-12T14:48:24Z",
          "updatedAt": "2025-05-12T14:48:24Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, clients retrying to connect too fast can be an issue. So putting in some limits might be good. As Janfred suggested, I'm in favor of keeping it short and not overspecify it. I don't think we need to compel implemetors do it in exactly this way - as long as a somewhat reasonable back-off is implemented.\n\nI see two important points to mandate:\n- a lower bound: don't retry a connection earlier than, say, 2 seconds\n- an exponential back-off (double the reconnect timer every time it fails - with an upper limit. Currently I limit the back-off to 60s; see below)\n- mabye add jitter (not sure if mandating it is required, but implementations may do it)\n\nNo strong feelings about the exact numbers to recommend or mandate - I've chosen mine arbitrarily.\n\nApplying the RFC5080 algorithm directly, I see one particular issue: giving up the connection attempts completely. Might be wishful for misconfigured clients, but it creates issues in certain situations: e.g. when a radius server (idp or proxy) is down for maintenance or otherwise unreachable for some time. If that time is too long, the clients would have given up and never recover without admin intervention. As an infrastructure/service operator, this is a no-go for me. For this, I also limit the back-off timer, to ensure a reasonable recovery time after a server is back alive.\n",
          "createdAt": "2025-05-23T18:40:51Z",
          "updatedAt": "2025-05-23T18:40:51Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Clients already have to (or should) implement the retransmission requirements of RFC 5080.  Using the same algorithm here should make it easier to implement.  Plus, there is no real reason to have a different algorithm.\n\nThe suggestion to stop connection attempts came from Eduroam US.  There, they see clients who have _never_ been able to connect, but who are still trying days to months later.\n\nI think it's OK either way (stop trying on error, or keep trying on error).  We just need a back-off time which is small enough that it allows systems to recover from temporary failures, but large enough that the connection attempts aren't problematic.\n\nI would also be concerned about systems which are affected by the original proposal.  For me. if the RADIUS server is down for days, then this signifies a fairly catastrophic error.  In that case, the RADIUS clients should arguably stop their connection attempts, because it likely _doesn't_ mean that the RADIUS server is down, it means that the client was misconfigured.",
          "createdAt": "2025-05-25T13:30:59Z",
          "updatedAt": "2025-05-25T13:30:59Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "> I would also be concerned about systems which are affected by the original proposal. For me. if the RADIUS server is down for days, then this signifies a fairly catastrophic error. In that case, the RADIUS clients should arguably stop their connection attempts, because it likely doesn't mean that the RADIUS server is down, it means that the client was misconfigured.\n\nI would be careful with such an assumption. While this might be the case for you, the internet is not monolithic and by restricting the standards beyond reasonable limits, we can have one of two outcomes: Either the standard doesn't get accepted/implemented/used/..., because it causes too much problems or the implementations simply ignore the annoying restrictions.\nNeither outcome is good and what we want.\nI would argue that especially the second case is highly problematic, because implementers may start ignoring requirements that are security relevant and introduce vulnerabilities. (We can't stop them from ignoring requirements, but if we add arbitrary requirements, I suspect the willingness to ignore other requirements would go way up.)\n\nOne use case from the top of my head: An organization has 3 redundant RADIUS servers. For bigger maintenance, one of the servers is taken offline for a longer period of time.\nEverything still works and is redundant, but if the goal is, for example, to perform the maintenance on each of the three servers with, let's say, one week in between, then clients would loose the connection to all three servers, because they would mark the server as dead and not retry.\n\n> Clients already have to (or should) implement the retransmission requirements of RFC 5080. Using the same algorithm here should make it easier to implement. Plus, there is no real reason to have a different algorithm.\n\nNot if the nodes are RADIUS/TLS (or RADIUS/TCP) only, since RADIUS/TLS doesn't have any retransmissions.\nI also gather that the \"retransmission of packets\" code may not translate 1:1 to \"re-opening of sessions\", so it is a non-negligible implementation effort.",
          "createdAt": "2025-05-26T08:25:43Z",
          "updatedAt": "2025-05-26T08:25:43Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On May 26, 2025, at 4:26\u202fAM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> I would be careful with such an assumption. While this might be the case for you, the internet is not monolithic and by restricting the standards beyond reasonable limits, we can have one of two outcomes: Either the standard doesn't get accepted/implemented/used/..., because it causes too much problems or the implementations simply ignore the annoying restrictions.\r\n> Neither outcome is good and what we want.\r\n\r\n  Implementations already ignore many of the requirements of the RFCs.  For me, the standard should define best practices.  That way when implementations do ridiculous things, we can point to the standard and say \"you were told not to do that\".\r\n\r\n  I am very much opposed to watering down the standards, based on a worry that a \"too strong\" standard will be ignored by implementations.  For me, that path gives implementations the ability to do whatever they want, and then to claim standards compliance.\r\n\r\n> I would argue that especially the second case is highly problematic, because implementers may start ignoring requirements that are security relevant and introduce vulnerabilities. (We can't stop them from ignoring requirements, but if we add arbitrary requirements, I suspect the willingness to ignore other requirements would go way up.)\r\n\r\n  That hasn't been my experience.\r\n\r\n> One use case from the top of my head: An organization has 3 redundant RADIUS servers. For bigger maintenance, one of the servers is taken offline for a longer period of time.\r\n> Everything still works and is redundant, but if the goal is, for example, to perform the maintenance on each of the three servers with, let's say, one week in between, then clients would loose the connection to all three servers, because they would mark the server as dead and not retry.\r\n\r\n   I'm OK with allowing the retries to continue forever.  What I don't want is for those retries to occur at a high rate, forever.\r\n\r\n> > Clients already have to (or should) implement the retransmission requirements of RFC 5080. Using the same algorithm here should make it easier to implement. Plus, there is no real reason to > have a different algorithm.\r\n> Not if the nodes are RADIUS/TLS (or RADIUS/TCP) only, since RADIUS/TLS doesn't have any retransmissions.\r\n\r\n  I doubt very much that there will be nodes without RADIUS/UDP.  This isn't a convincing argument.\r\n\r\n> I also gather that the \"retransmission of packets\" code may not translate 1:1 to \"re-opening of sessions\", so it is a non-negligible implementation effort.\r\n\r\n  The re-opening of sessions has to be done on some kind of timer.  The other choices are retry immediately, or never retry.\r\n\r\n  The code to implement any retry timer is negligible, compared to the code required to implement RADIUS/TLS.  So I'm not at all convinced that there's any issue in mandating a retry algorithm.\r\n\r\n  If we don't recommend a sane retry algorithm, then as we've seen, some implementations will retry aggressively.  This pattern has high cost for servers, because they're effectively getting a DoS attack from poor implementations.\r\n\r\n  i.e. implementations which do ridiculous things are passing their costs off to other people.  They're \"saving\" time and money by taking short-cuts, or by doing stupid and anti-social things.  They're costing other people time, effort, and money.\r\n\r\n  There is simply no reason to allow anti-social behavior, based on a worry that mandating \"good behaviour\" would have a cost for the anti-social people.  My opinion here is \"too bad\".",
          "createdAt": "2025-05-26T10:50:01Z",
          "updatedAt": "2025-05-26T10:50:01Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "But there is a difference between\n\"Don't do immediate retries, you MUST implement a backoff algorithm that will do retries at most each 60 seconds after 5 minutes\"\nand\n\"Here is a very specific mandatory-to-implement algorithm for backoff that might not fit what you need and you may already have a different algorithm that matches the goal, but ours it's MTI, so now you have to rewrite\"\n\nI'm not saying that we should ignore this.\nI'm saying that we should specify the minimum requirements for the backoff, such as \n\"There must be a minimum wait time of one second after a failed connection attempt, the interval of retries MUST increase latest after 5 consecutive failed connection attempts, and MUST increase to a minimum of 60 seconds. The maximum interval of retries SHOULD be configurable by the admin\"\n\nThis ensures that we don't have RFC-compliant RADIUS/(D)TLS clients hammering our server, but how exactly it is implemented is still in the discretion of the implementers.\n\nIt doesn't keep us from adding a reference such as \"We RECOMMEND implementing the retry behavior similar to the RADIUS retransmission algorithm in RFC 5080, Section 2.2.1\"",
          "createdAt": "2025-05-26T11:17:52Z",
          "updatedAt": "2025-05-26T11:17:52Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On May 26, 2025, at 7:18\u202fAM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> I'm saying that we should specify the minimum requirements for the backoff, such as\r\n> \"There must be a minimum wait time of one second after a failed connection attempt, the interval of retries MUST increase latest after 5 consecutive failed connection attempts, and MUST increase to a minimum of 60 seconds. The maximum interval of retries SHOULD be configurable by the admin\"\r\n> This ensures that we don't have RFC-compliant RADIUS/(D)TLS clients hammering our server, but how exactly it is implemented is still in the discretion of the implementers.\r\n> It doesn't keep us from adding a reference such as \"We RECOMMEND implementing the retry behavior similar to the RADIUS retransmission algorithm in RFC 5080, Section 2.2.1\"\r\n\r\n  I think that's fine:\r\n\r\n  Implementations MUST do something sane.  They SHOULD implement the following retry behavior.\r\n\r\n",
          "createdAt": "2025-05-26T11:49:06Z",
          "updatedAt": "2025-05-26T11:49:06Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A quick thought about a more nuanced provision whether to give up or not:\n\nIf the connection is configured static and keep permanently up (i.e. no idle timeout), of if there are active radius requests to be sent, don't give up.\nIf there are no more requests to be sent (radius requests have timed out or already sent to another server), (i.e. idle timeout with no outstanding requests), give up trying. Of course, a new attempt may start with a new radius request, but overall retry limitations MUST still apply.",
          "createdAt": "2025-05-29T19:52:36Z",
          "updatedAt": "2025-05-29T19:52:36Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOLrzygc65We8T",
      "title": "Text on Acct-Delay-Time",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/36",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Perhaps move the text on Acct-Delay-Time from Section 4.5.1, which talking about proxies.  Then add a new 4.6:\n\n4.6 Acct-Delay-Time\n\nIn order to avoid congestive collapse, is is RECOMMENDED that RADIUS/\n(D)TLS clients which originate Accounting-Request packets (i.e. not\nproxies) do not include Acct-Delay-Time in those packets. Instead,\nthose clients SHOULD include Event-Timestamp, which is the time at\nwhich the original event occurred. The Event-Timestamp MUST NOT be\nupdated on any retransmissions, as that would both negate the meaning\nof Event-Timestamp, and also create the same problem as with Acct-\nDelay-Time.\n\nNot using Acct-Delay-Time allows for RADIUS/DTLS packets to be retransmitted without change.  In contrast, updating Acct-Delay-Time would require that the client create and send a brand new packet, without signalling the server that the previous packet is no longer active.  This process can occur repeatedly, which leads to multiple different packets containing effectively the same information (except for Acct-Delay-Time).  This duplication contributes to congestive collapse of the network.\n\nNot using Acct-Delay-Time also removes an unambiguity around retransmitted packets for RADIUS/TLS.  Since there is no change to the packet contents when a retransmission timer expires, no new packet ID is allocated, and therefore no new packet is created.\n\nWhere systems do include Acct-Delay-Time in RADIUS/TLS packets, they SHOULD use timers to detect packet loss, as suggested in RFC5080 Section 2.2.1.  However, those timers MUST NOT result in transmission of any packet.  Instead, the timers could be used to log messages indicating that the client is still waiting for a reply, and to determine that packet loss has, in fact, occurred.\n\nAs TLS is a reliable transport, RADIUS/TLS clients can only retransmit a packet if a connection closes without that packet receiving a reply.  See Section 5.1, below, for more discussion of this topic.\n\n",
      "createdAt": "2025-06-02T11:01:25Z",
      "updatedAt": "2025-07-07T15:40:22Z",
      "closedAt": "2025-07-07T15:40:22Z",
      "comments": []
    },
    {
      "number": 37,
      "id": "I_kwDOLrzygc65Wo3t",
      "title": "Packet Expiry timers",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/37",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Not much in the existing text discusses the retransmission timers in RFC 5080 Section 2.2.1.  Perhaps we could add a new section, before the Acct-Delay-Time text mentioned in #36 \n\n4.x Client Timers\n\nRADIUS/(D)TLS clients MUST implement retransmission timers such as the ones which are defined in RFC 5080 Section 2.2.1.  Other methods are possible, but any timer implementation MUST have similar properties of including jitter and exponential backoff.\n\nAs TLS is a reliable transport, RADIUS/TLS clients can only retransmit a packet if a connection closes without that packet receiving a reply. \n Similarly, RADIUS/DTLS can only retransmit packets when it runs over an unreliable transport such as UDP. \n\nWhere RADIUS/(D)TLS runs over a reliable transport, these timers MUST NOT result in transmission of any packet. Instead, the timers could be used to log messages indicating that the client is still waiting for a reply, and to determine that packet loss has, in fact, occurred when RFC 5080 Section 2.2.1 MRD or MRC has been reached.\n\nSee Section 5.1, below, for more discussion of retransmission behavior.\n\n",
      "createdAt": "2025-06-02T11:14:27Z",
      "updatedAt": "2025-07-07T15:41:22Z",
      "closedAt": "2025-07-07T15:41:22Z",
      "comments": []
    },
    {
      "number": 40,
      "id": "I_kwDOLrzygc7BDH2b",
      "title": "DTLS session tracking",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/40",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per the comments on the mailing list, maybe the session tracking for DTLS can be reworded to allow different session tracking mechanisms.\n\nCurrently, the draft contains this in section 6.4:\n> Implementations may choose to use the method described here, or another, equivalent method.\n\nMaybe with this, the concerns are already met, maybe we should capitalize the \"may\", so it is a proper BCP14 \"MAY\"",
      "createdAt": "2025-07-17T09:23:19Z",
      "updatedAt": "2025-07-22T10:20:16Z",
      "closedAt": "2025-07-22T10:20:16Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Should be fixed in 8d566da",
          "createdAt": "2025-07-20T12:57:21Z",
          "updatedAt": "2025-07-20T12:57:21Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "As per the discussion in the WG session at IETF 123, I'm closing this. Feel free to re-open if the text is not sufficient.",
          "createdAt": "2025-07-22T10:20:16Z",
          "updatedAt": "2025-07-22T10:20:16Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOLrzygc7BF4x4",
      "title": "DTLS retransmissions",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/42",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When reading through the document, I noticed that in Section 6.4 we mandate a behavior for retransmissions on the server side.\nIf the server received a retransmission of a RADIUS request and already has an answer cached, it MUST re-process that cached answer through DTLS instead of just caching the DTLS record and re-sending that one.\n\nThis opens up two questions:\n\n* Why are we mandating this behavior only for servers and not for clients and their retransmissions?\n* Is this even right?\n\nRFC 9147 (DTLS 1.3), section 4.2.1 (DTLS Record Layer -> Seq Nr and Epoch -> Processing Guidelines) states:\n> Implementations MUST send retransmissions of lost messages using the same epoch and keying material as the original transmission.\n\nWe need to find out, whether or not RADIUS packet retransmissions are also included in the DTLS's definition of a retransmission.",
      "createdAt": "2025-07-17T13:10:15Z",
      "updatedAt": "2025-08-21T23:25:02Z",
      "closedAt": "2025-08-21T23:25:02Z",
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IIRC, the text for servers was the result of discussions with people familiar with DTLS.  But we should double-check this, and use a consistent approach.\n\ni.e. either DTLS sends exactly the same packet for retransmissions of application data (both client and server).  Or, DTLS sends new packets for retransmissions of application data (both client and server).\n\nChecking the DTLS RFCs, they discuss retransmissions during the handshake phase.  But they have no discussion about the application layer protocol.  The entire contents of RFC9147 related to the application data protocol is [Section 10](https://datatracker.ietf.org/doc/html/rfc9147#name-application-data-protocol), which I reproduce here in its entirety:\n\n```\nApplication data messages are carried by the record layer and are split into records and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.\n```",
          "createdAt": "2025-07-17T13:34:10Z",
          "updatedAt": "2025-07-17T13:34:10Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And commenting in 4.2.1:\n\n> Implementations MUST send retransmissions of lost messages using the same epoch and keying material as the original transmission.\n\nThe implication would be that the retransmitting a lost application message would mean sending a new DTLS message.  We will have to clarify this with the TLS people",
          "createdAt": "2025-07-17T13:36:01Z",
          "updatedAt": "2025-07-17T13:36:01Z"
        },
        {
          "author": "TheEnbyperor",
          "authorAssociation": "NONE",
          "body": "To copy from the discussion in the 123 WG:\n\nRetransmission in DTLS is retransmission for DTLS' own purposes, i.e. to maintain a lock-step handshake. Retransmission of application layer data is of no concern to DTLS. Thus, the current behaviour should be mandated for both clients and servers, and is the correct behaviour. ",
          "createdAt": "2025-07-22T08:12:36Z",
          "updatedAt": "2025-07-22T08:12:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Should be fixed with #49 ",
          "createdAt": "2025-08-21T23:25:02Z",
          "updatedAt": "2025-08-21T23:25:02Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOLrzygc7Cg-cf",
      "title": "Certificate Lifetimes",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/46",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "PR exists",
        "WGLC Comment"
      ],
      "body": "The text should probably say that connections MUST respect certificate expiry times.  If the certificate is no longer valid, then the connection needs to be torn down.",
      "createdAt": "2025-07-25T14:28:50Z",
      "updatedAt": "2025-09-11T09:42:58Z",
      "closedAt": "2025-09-11T09:42:58Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "The current draft has a SHOULD for reassessing the trust on trust base changes (such as CRL updates), so I would recommend also making this a SHOULD.\n\nThere could be reasons why one would use a short-lived certificate (e.g. 90 days Let'sEncrypt), but may still be fine with long-standing connections beyond the certificate's life span.\nFor renegotiation, the rules would then require a certificate update, since the old certificate would then fail the check.",
          "createdAt": "2025-08-15T12:48:36Z",
          "updatedAt": "2025-08-15T12:48:36Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we're OK with a `SHOULD`.  Some other applications allow connections to remain open, even after the certificate has expired.  ",
          "createdAt": "2025-08-15T14:22:30Z",
          "updatedAt": "2025-08-15T14:22:30Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #48 is merged, so I'm closing this issue.",
          "createdAt": "2025-09-11T09:42:58Z",
          "updatedAt": "2025-09-11T09:42:58Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOLrzygc7IOoho",
      "title": "Missing text on allowed packets (needed for Reverse CoA)",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/51",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "question",
        "PR exists",
        "WGLC Comment"
      ],
      "body": "The document is missing text on which packets are allowed to be processed on what port.  Likely we can just copy everything from 6614:\n\nhttps://datatracker.ietf.org/doc/html/rfc6614#section-2.5\n\nThe reverse CoA document needs this section, to replace an existing reference to RFC6614, Section 2.5.  The IESG review is that the reverse CoA document should reference this one, and not 6614 / 7360.",
      "createdAt": "2025-08-27T13:00:37Z",
      "updatedAt": "2025-09-30T14:06:22Z",
      "closedAt": "2025-09-30T14:06:22Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I deliberately left out the list of packet types, because it didn't add any value (esp. since the list was not exhaustive).\nBut we can add the CoA part.",
          "createdAt": "2025-09-11T09:37:02Z",
          "updatedAt": "2025-09-11T09:37:02Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "After looking at it again: We have text in https://radext-wg.github.io/draft-ietf-radext-radiusdtls-bis/draft-ietf-radext-radiusdtls-bis.html#name-radius-datagrams\n\nWhat exactly is needed from 6614 Section 2.5 for the Reverse CoA Document?",
          "createdAt": "2025-09-11T09:50:54Z",
          "updatedAt": "2025-09-11T09:50:54Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Hopefully fixed with merging of #55 \n\nIf not, please re-open.",
          "createdAt": "2025-09-30T14:06:22Z",
          "updatedAt": "2025-09-30T14:06:22Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOLrzygc7IOthM",
      "title": "Event-Timestamp",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/52",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs discussion",
        "WGLC Comment"
      ],
      "body": "Minor typo in https://datatracker.ietf.org/doc/html/draft-ietf-radext-radiusdtls-bis-08#name-acct-delay-time-and-event-t  `Timestap`\n\nThe text in that section doesn't say what a server / proxy should do if it receives a packet which is missing both Event-Timestamp, and Acct-Delay-Time.  Perhaps:\n\nA server receiving an Accounting-Request packet which is missing both Event-Timestamp and Acct-Delay-Time MUST assume that the time of the referenced event is the time when the packet was received.  A proxy SHOULD add an Event-Timestamp to the packet with that value before proxying it.  Adding this value ensures that delays due to transport problems or retransmissions do not affect subsequent servers which receive this packet.  A proxy MAY also add Event-Timestamp, even if the packet contains Acct-Delay-Time.",
      "createdAt": "2025-08-27T13:07:27Z",
      "updatedAt": "2025-09-11T10:27:35Z",
      "closedAt": "2025-09-11T10:27:35Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Typo is fixed, thanks.\n\nFor the other part: I would argue that this definitely isn't something that's DTLS/TLS specific, so it shouldn't be part of this document but instead of the proxy BCP document.",
          "createdAt": "2025-09-11T09:40:02Z",
          "updatedAt": "2025-09-11T09:40:02Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that's fine.  In the interest of moving this document forward, I'll close this issue.\n\nAlso another typo `In conctrast ...`",
          "createdAt": "2025-09-11T10:27:35Z",
          "updatedAt": "2025-09-11T10:27:35Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOLrzygc5sWeGl",
      "title": "Add text around Server Name Indication",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/1",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "SNI was not part of RFC6614 or RFC7360.\r\n\r\nThis is possibly breaking backwards compatibility, so I don't want to change this without a discussion within the WG.\r\n\r\nThis Pull Request can be used to comment on aspects of the text.",
      "createdAt": "2024-04-11T11:54:05Z",
      "updatedAt": "2025-08-15T16:37:01Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "97c3d68c2250b7970014b23aa2793f1de3d88ea5",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_server_name_indication",
      "headRefOid": "7d83c0346f5b7c8cbe4f49fa2280f16c872d11fd",
      "closedAt": "2025-04-10T15:11:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "With the changes in the document and the consensus that all proxy and load balancing related topics are out of scope for this document, I'm closing this pull request.",
          "createdAt": "2025-04-10T15:11:25Z",
          "updatedAt": "2025-04-10T15:11:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc523DiS",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:07:24Z",
          "updatedAt": "2024-04-11T13:07:24Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "TLS servers _may_ be hidden behind a load balancer.",
              "createdAt": "2024-04-11T13:07:24Z",
              "updatedAt": "2024-04-11T13:07:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523E9V",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:10:09Z",
          "updatedAt": "2024-04-11T13:10:10Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "What about 7585, where the destination IP isn't known in advance?\r\n\r\nI think it's preferable to base server identity on the presented server credentials.  i.e. the certificate, and not any IP/port information.\r\n\r\nThat is, we have multiple connections to the same server certificate (or similar certificate identification fields), then the client should treat all of those connections as being similar.",
              "createdAt": "2024-04-11T13:10:09Z",
              "updatedAt": "2024-04-11T13:10:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523FKx",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:10:32Z",
          "updatedAt": "2024-04-11T13:10:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This seems backwards to me?  Is this a typo, or am I missing something?",
              "createdAt": "2024-04-11T13:10:33Z",
              "updatedAt": "2024-04-11T13:10:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523GPL",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:12:34Z",
          "updatedAt": "2024-04-11T13:12:34Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It's less about SNI than presented certificate, I think.  The distinction is important.\r\n\r\nOnce a client verifies the server identity (and that it matches the SNI), then it's possible to put all similar connections into a connection pool.  And it's OK to key that off of the SNI string, but I think it should be clear that it's being based off of the _identity_ , and not the SNI.",
              "createdAt": "2024-04-11T13:12:34Z",
              "updatedAt": "2024-04-11T13:12:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523G8C",
          "commit": {
            "abbreviatedOid": "7d83c03"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:13:52Z",
          "updatedAt": "2024-04-11T13:13:52Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I'm not clear how a server can \"distinguish clients\" by SNI.  Perhaps instead just \"present different identities to clients based on SNI\". ",
              "createdAt": "2024-04-11T13:13:52Z",
              "updatedAt": "2024-04-11T13:13:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc52_KIR",
          "commit": {
            "abbreviatedOid": "7d83c03"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-12T09:00:49Z",
          "updatedAt": "2024-04-12T09:00:49Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "How about this:\r\n\r\n```suggestion\r\nBy adding Server Name Indication, a RAIDUS/(D)TLS server can now provide different services (i.e. access to different roaming consortia) under the same destination IP address and port, or could present different certificates to clients or apply specific policies depending the server name the clients use in the SNI extension of the TLS Client Hello.\r\n```",
              "createdAt": "2024-04-12T09:00:49Z",
              "updatedAt": "2024-04-12T09:00:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc52_Mli",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-12T09:04:45Z",
          "updatedAt": "2024-04-12T09:04:45Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "See discussion on the ML on that one:\r\nhttps://mailarchive.ietf.org/arch/msg/radext/pX1cn_RnaRnqeu5MBXc-sohK_SQ",
              "createdAt": "2024-04-12T09:04:45Z",
              "updatedAt": "2024-04-12T09:04:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc52_NCK",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-12T09:05:44Z",
          "updatedAt": "2024-04-12T09:05:45Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nFor RADIUS/(D)TLS, this distinction is not that simple, i.e. because different RADIUS servers may be hidden behind a load balancer with one public IP address, and the load balancer dispatches the connections based on the Server Name Indication in the first TLS handshake record.\r\n```",
              "createdAt": "2024-04-12T09:05:44Z",
              "updatedAt": "2024-04-12T09:05:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc53B5ys",
          "commit": {
            "abbreviatedOid": "7d83c03"
          },
          "author": "mcr",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-12T13:18:09Z",
          "updatedAt": "2024-04-12T13:18:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOLrzygc5v_-MV",
      "title": "try to address proxying issues.  Helps with #2",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/3",
      "state": "MERGED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "My initial stab at addressing the proxying issues.",
      "createdAt": "2024-05-20T20:26:01Z",
      "updatedAt": "2025-07-17T12:13:19Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "0e3b595bd851c9e1fcf4e0bd227f269f8609754e",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "issue2",
      "headRefOid": "5d64d5f3f674c55f0e4f9293f3388898d3566bbc",
      "closedAt": "2024-07-08T17:49:21Z",
      "mergedAt": "2024-07-08T17:49:21Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "36cab8101d92b069730f390e8251f3f2a44d5ea1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "PR_kwDOLrzygc52L816",
      "title": "apply RFC9525 guidance for validating certificate identities",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/4",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "RFC9525 provides guidance on what/how to specify certificate identity validation. This PR applies those rules and references RFC9525 explicitly. \r\n\r\nIn addition the NAIrealm identity is generalized as it might be applied outside dynamic discovery.",
      "createdAt": "2024-07-23T09:00:17Z",
      "updatedAt": "2024-10-21T19:08:57Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-rfc9525-guidance",
      "headRefOid": "503d39d9a9e9b1ea9b6d604f5c3fcb2cfc9c5252",
      "closedAt": "2024-10-21T19:04:59Z",
      "mergedAt": "2024-10-21T19:04:59Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "b99af9528e8a20cbc246789eedb9e09ba502350a"
      },
      "comments": [
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the 'Selfie attack' discussion on the radext mailing list, this prposal might need an update too, related to omitting the identity check... ",
          "createdAt": "2024-07-25T11:20:15Z",
          "updatedAt": "2024-07-25T11:20:15Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "NONE",
          "body": "In regards to wildcard certificates, [RFC 9525](https://www.rfc-editor.org/rfc/rfc9525.html#name-matching-the-dns-domain-nam) talks about clients matching server wildcard certificate. How clear do we need to be about wildcard certificate use? For example, if software uses a wildcard certificate for accepting (D)TLS connections it must use a different non-wildcard certificate when it initiates a (D)TLS connections.",
          "createdAt": "2024-10-04T17:16:33Z",
          "updatedAt": "2024-10-04T17:16:33Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I will leave this PR open until we have finished the discussion on the selfie/loopback/... attack, to keep it visible.\r\n\r\nThe other text is merged with #19 ",
          "createdAt": "2024-10-21T19:02:21Z",
          "updatedAt": "2024-10-21T19:02:21Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "apparently github thinks that once a commit is merged in a different pull request, this one should be closed too. I'm sorry. I don't think that I can re-open it, so it still appears in the open PR list.\r\nI'll keep this PR in mind for further discussions.",
          "createdAt": "2024-10-21T19:08:56Z",
          "updatedAt": "2024-10-21T19:08:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L8fUz",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:02:38Z",
          "updatedAt": "2024-10-04T12:02:38Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "As per Russ' comments in his [secdir early review](https://mailarchive.ietf.org/arch/msg/radext/LMeW527YwDyovkhP-_2VwmAT_Fk) this needs to be adjusted.\r\n\r\nI've tried to change the wording here as one example, I'm not sure if this is correct.\r\nWe should probably get confirmation from folks that this is in fact correct to say.\r\n\r\n```suggestion\r\n  - If the expected RADIUS/(D)TLS server is associated with a specific NAI realm, e.g. by dynamic discovery {{!RFC7585}} or static configuration, that realm is matched against any naiRealm label contained in the subjectAltName extension.\r\n```",
              "createdAt": "2024-10-04T12:02:38Z",
              "updatedAt": "2024-10-04T12:02:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L8gGw",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:04:23Z",
          "updatedAt": "2024-10-04T12:04:23Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n  - If the expected RADIUS/(D)TLS server was configured as a hostname, or the hostname was yielded by a dynamic discovery procedure, the configured name is matched against the presented names from the subjectAltName:DNS extension. Since a dynamic discovery might by itself not be secured, implementations MAY require the use of DNSSEC {{!RFC4033}} to ensure the authenticity of the DNS result before considering this identity as valid. \r\n```\r\n\r\nJust for clarity.",
              "createdAt": "2024-10-04T12:04:23Z",
              "updatedAt": "2024-10-04T12:04:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L8hlV",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:07:48Z",
          "updatedAt": "2024-10-04T12:07:48Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I would be more explicit here, because the \"without doing so\" is a bit vague.\r\nWhat is it exactly that we mean? Is it sufficient that the client checks the \"issuer\" attribute of the certificate?\r\nWhy is this sentence of looping just here? The loop attack could possibly also happen with other scenarios (like DNS without DNSSEC and the NAPTR just points back to the server)",
              "createdAt": "2024-10-04T12:07:48Z",
              "updatedAt": "2024-10-04T12:07:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L8iLS",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:09:03Z",
          "updatedAt": "2024-10-04T12:09:03Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n  * If configured by the administrator, the identity check MAY be omitted after a successful {{RFC5280}} trust chain check, e.g. if the client used dynamic lookup there is no configured client identity to verify. The clients authorization MUST then be validated using a certificate policy OID unless both peers are part of a trusted network.\r\n```\r\n(just two typos)",
              "createdAt": "2024-10-04T12:09:03Z",
              "updatedAt": "2024-10-04T12:09:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L-biJ",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T15:51:42Z",
          "updatedAt": "2024-10-04T15:51:42Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The intention here is that a client MUST identy the server by any element that clearly identifies it. I think this includes subject, subjectAltNames, issuer+certificate serial (but not the issuer by itself).\r\n\r\nThe loop attack refers to the same issue we discussed regarding TLS-PSK, that an attacker could loop the TLS packets (without decrypting them) back to the client and it would accept that connection (if it generally accepts incomming connections, i.e. proxies).",
              "createdAt": "2024-10-04T15:51:42Z",
              "updatedAt": "2024-10-04T15:51:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L-gzS",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T16:03:32Z",
          "updatedAt": "2024-10-04T16:03:32Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Thanks for the heads-up. I will try to incorporate Russ' feedback. Have to check RFC9525 again, maybe it already suggests the correct wording.",
              "createdAt": "2024-10-04T16:03:32Z",
              "updatedAt": "2024-10-04T16:03:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L_Xk8",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T17:18:24Z",
          "updatedAt": "2024-10-04T17:18:24Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I have two points here:\r\nFirst, the text should explicitly state something like \"Clients MUST NOT accept any certificate without validating at least something\" instead of the general \"without doing so\"\r\nSecond, the Loop attack is a general attack, so maybe it is worth to put it in security considerations, have a few words here about it and then reference the security considerations section for details?",
              "createdAt": "2024-10-04T17:18:24Z",
              "updatedAt": "2024-10-04T17:18:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MLBps",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T11:39:14Z",
          "updatedAt": "2024-10-07T11:39:14Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "agreed to both points. This was as a last minute addition anyway, after it got mentioned in the TLS-PSK context.",
              "createdAt": "2024-10-07T11:39:14Z",
              "updatedAt": "2024-10-07T11:39:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MYtRg",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T18:52:59Z",
          "updatedAt": "2024-10-08T18:52:59Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": ">  Second, the Loop attack is a general attack, so maybe it is worth to put it in security considerations, have a few words here about it and then reference the security considerations section for details?\r\n\r\nOne workaround would be to check that the client/server random (in OpenSSLese, `SSL_get_client_random` and `SSL_get_server_random`) do not match.",
              "createdAt": "2024-10-08T18:52:59Z",
              "updatedAt": "2024-10-08T18:52:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MsyYP",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-10T14:24:36Z",
          "updatedAt": "2024-10-10T14:24:36Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "don't know how exactly client/server random works, but even experimentally, I'm struggling to see how this would work.\r\n\r\nIf I call `get_client_random` and `get_server_random` both on the connecting and accepting side of a tls connection, I actually get 4 different values, even when both sides run in the same process and use the same ssl context.\r\n\r\nAm I missing something?",
              "createdAt": "2024-10-10T14:24:36Z",
              "updatedAt": "2024-10-10T14:24:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MtVDT",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-10T15:12:16Z",
          "updatedAt": "2024-10-10T15:12:16Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> don't know how exactly client/server random works, but even experimentally, I'm struggling to see how this would work.\r\n> \r\n> If I call `get_client_random` and `get_server_random` both on the connecting and accepting side of a tls connection, I actually get 4 different values, even when both sides run in the same process and use the same ssl context.\r\n> \r\n> Am I missing something?\r\n\r\nThe first four bytes is the `gmt_unix_time` (legacy, and I think now purely random) when shown in `openssl s_client ...`, so that may be it, otherwise Works for Me(tm).\r\n\r\nApply the ghetto patch to https://github.com/openssl/openssl/tree/master/demos/sslecho, compile and run `sslecho s`:\r\n```\r\ndiff --git a/demos/sslecho/main.c b/demos/sslecho/main.c\r\nindex eec8e13a47..b4fca946cd 100644\r\n--- a/demos/sslecho/main.c\r\n+++ b/demos/sslecho/main.c\r\n@@ -7,6 +7,7 @@\r\n  *  https://www.openssl.org/source/license.html\r\n  */\r\n \r\n+#include <assert.h>\r\n #include <stdio.h>\r\n #include <unistd.h>\r\n #include <string.h>\r\n@@ -213,6 +214,18 @@ int main(int argc, char **argv)\r\n \r\n                 printf(\"Client SSL connection accepted\\n\\n\");\r\n \r\n+                unsigned char random[32];\r\n+                assert(SSL_get_client_random(ssl, random, sizeof(random)) == sizeof(random));\r\n+                printf(\"client random: \");\r\n+                for (int i = 0; i < sizeof(random); i++)\r\n+                    printf(\"%02X\", random[i]);\r\n+                printf(\"\\n\");\r\n+                assert(SSL_get_server_random(ssl, random, sizeof(random)) == sizeof(random));\r\n+                printf(\"server random: \");\r\n+                for (int i = 0; i < sizeof(random); i++)\r\n+                    printf(\"%02X\", random[i]);\r\n+                printf(\"\\n\");\r\n+\r\n                 /* Echo loop */\r\n                 while (true) {\r\n                     /* Get message from client; will fail if client closes connection */\r\n```\r\n\r\nAs the client run `openssl s_client -trace -connect localhost:4433`:\r\n```\r\nCONNECTED(00000003)\r\nSent Record\r\nHeader:\r\n  Version = TLS 1.0 (0x301)\r\n  Content Type = Handshake (22)\r\n  Length = 292\r\n    ClientHello, Length=288\r\n      client_version=0x303 (TLS 1.2)\r\n      Random:\r\n        gmt_unix_time=0x919DE39C                                                                <----\r\n        random_bytes (len=28): 97E42A6040AD6B9FA248D29B5C2C153E3F92AD9E14412CB875F8BF78         <----\r\n      session_id (len=32): 1557C0A035FB2A3DF97F5067FC534FC9E71BC106FB929E823A998467C893C6A0\r\n      cipher_suites (len=62)\r\n\r\n[snipped]\r\n\r\nReceived Record\r\nHeader:\r\n  Version = TLS 1.2 (0x303)\r\n  Content Type = Handshake (22)\r\n  Length = 122\r\n    ServerHello, Length=118\r\n      server_version=0x303 (TLS 1.2)\r\n      Random:\r\n        gmt_unix_time=0x99B5F850                                                              <----\r\n        random_bytes (len=28): 30BCD49D1F53AFE61C5A63B16AD7FABE3B444EEE5D1093D78E878639       <----\r\n      session_id (len=32): 1557C0A035FB2A3DF97F5067FC534FC9E71BC106FB929E823A998467C893C6A0\r\n      cipher_suite {0x13, 0x02} TLS_AES_256_GCM_SHA384\r\n      compression_method: No Compression (0x00)\r\n\r\n[snipped]\r\n```\r\n\r\nThe output I got matched.\r\n\r\nI am assuming this works in during the pre-establish handshake phase? That I did not test...",
              "createdAt": "2024-10-10T15:12:16Z",
              "updatedAt": "2024-10-10T15:19:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6M_HE6",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T05:48:44Z",
          "updatedAt": "2024-10-14T05:48:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Thanks for the detailed explanation; looks like I goofed up my experiment.\r\n\r\nSo yes, one could compare client/server randoms, but upon opening (or accepting) a connection, you would have to compare its random to verey other TLS connection. I.e. the client and server random of a single conneciton are always different (I guess as they should be for security reasons)",
              "createdAt": "2024-10-14T05:48:44Z",
              "updatedAt": "2024-10-14T05:48:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6NAK4T",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T07:36:44Z",
          "updatedAt": "2024-10-14T07:36:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I think you only need to limit the check window to the pool of the systems own not-yet-established TLS connections, as those connections have to come from yourself and be pending for this attack to work, right?",
              "createdAt": "2024-10-14T07:36:44Z",
              "updatedAt": "2024-10-14T07:37:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N6xzG",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T06:00:21Z",
          "updatedAt": "2024-10-21T06:00:22Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yes, but still this might be tricky to implement for the exact timing and potential race-conditions. After all the client and server side code very intentionally run at the same time. ",
              "createdAt": "2024-10-21T06:00:21Z",
              "updatedAt": "2024-10-21T06:00:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N74e_",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T08:20:55Z",
          "updatedAt": "2024-10-21T08:20:55Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "During the client hello callback (`SSL_CTX_set_client_hello_cb`) the connection is not established and the server side is yet to fully process the request.\r\n\r\nMaybe I am missing something, I do not see a race. If there was, you would be unable to use this function to select a server certificate (ie. ALPN) which is one of the primary use cases for it.\r\n\r\nIt does become slightly more complicated if the 'server' is actually a pool of nodes, but all that would require is an RPC call out to the other nodes to see what connections are outstanding.\r\n\r\nMeanwhile the connection under inspection is frozen in time until the callback completes.\r\n\r\nCan you think of a situation where this fails?\r\n\r\nI am only lobbying for it, as if this is a good defence (which implementing aside we still do not know) it is trivial to implement. Helping us is the connection pool churn is low and so the length of the list of being established in flight TLS connections is low (ie. less than 1000).",
              "createdAt": "2024-10-21T08:20:55Z",
              "updatedAt": "2024-10-21T08:20:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N8xqj",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T09:53:47Z",
          "updatedAt": "2024-10-21T09:53:47Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Its two threads (or more, at least for me) and a network connection, which for me always puts on the warning light, be careful. There can always be events from the network (timeouts, a connecting being closed) and the race conditions may arise when two legitimate connections happen a the same time. In the end one thread has to access data from another, which requires careful coordination.\r\n\r\nI do agree that it's a good idea and definitely worth a shot, I just anticipate that its not going to be as trivial to implement as at first glance it might seem.\r\n\r\nBesides that, these are implementaiton details. I guess the question we should ask here is what we should recommend or even mandate in the RFC.",
              "createdAt": "2024-10-21T09:53:47Z",
              "updatedAt": "2024-10-21T09:53:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N-gtL",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T12:53:20Z",
          "updatedAt": "2024-10-21T12:53:21Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> Its two threads (or more, at least for me) and a network connection, which for me always puts on the warning light, be careful.\r\n\r\nSure, but you have described the effect of language and design decisions and the usual trade off and balances we all make. For others, sharing memory may not even be possible in their language (functional, actor model, etc) so this would simply not be a concern for them.\r\n\r\nAs such, definitely I would agree that mandating this would be unfair to implementers but it would be well placed as recommendations on one of several ways to avoid this problem.\r\n\r\nWe do need something though as related to this all is https://github.com/radext-wg/draft-ietf-radext-tls-psk/issues/4 where stated is a KDF should be used (and crucially 'context' populated) but the two major public implementations do not.\r\n\r\nIf the two-step KDF 'dance' is to be dropped, something would be needed and maybe checking handshake random numbers and provide the backwards compatible sticky tape.",
              "createdAt": "2024-10-21T12:53:20Z",
              "updatedAt": "2024-10-21T12:53:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6OCoN8",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T18:42:55Z",
          "updatedAt": "2024-10-21T18:42:55Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "One possible solution would be to compare the TLS keying material after the TLS session is established. If two connections have the same, something is fishy.\r\n\r\nBut that would either mean comparing it to all open connections (bad, if there are a lot) or checking only against the newest ones (also not really ideal, may be hard to implement, still have to check a lot of connections) or keeping track of the pending connections and once there are no pending connections, dropping all established connections from the comparison-pool, since they can't be similar any more (also requires a lot of implementation)\r\n\r\nI am slightly tempted to use a TLS extension to send a randomized number generated at startup of the software and comparing this number for each incoming connection.",
              "createdAt": "2024-10-21T18:42:55Z",
              "updatedAt": "2024-10-21T18:42:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOLrzygc52M_3H",
      "title": "unify idle-timeout between TLS and DTLS",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/5",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "TLS and DTLS specify idle timeout and session limits with different levels of detail. Those limits should apply to both equally.",
      "createdAt": "2024-07-23T11:31:57Z",
      "updatedAt": "2024-10-21T20:42:51Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-idle-timeout",
      "headRefOid": "7efae6bceb6ed11212a611d2e8da900d12e48870",
      "closedAt": "2024-10-21T20:42:50Z",
      "mergedAt": "2024-10-21T20:42:50Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "7efae6bceb6ed11212a611d2e8da900d12e48870"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6CydbS",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for your input. Highly appreciated. See the comments in the review",
          "createdAt": "2024-07-23T15:03:42Z",
          "updatedAt": "2024-07-23T15:23:05Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I can imagine that this can lead to problems.\r\n\r\nOne would be Reverse-CoA where you rely on sending the CoA packet \"backwards\" through RAIDUS/(D)TLS and that doesn't work if the client is behind a NAT, unless the connection stays open.\r\n\r\nThe second would be monitoring.\r\nIf you have a number of Service Providers, all behind a NAT, then the only good monitoring for Liveness of the SP is \"does the server have a (D)TLS session with this client\"\r\nIf the client would just close it, then this monitoring would not be possible anymore.\r\n\r\nI would suggest: Replace `SHOULD` with `MAY` and add some text like `[...], the configuration SHOULD allow to disable the idle timeout session shutdown`",
              "createdAt": "2024-07-23T15:03:42Z",
              "updatedAt": "2024-07-23T15:23:05Z"
            },
            {
              "originalPosition": 6,
              "body": "I don't understand this last sentence (and unfortunately I can't infer from context what word is missing)",
              "createdAt": "2024-07-23T15:19:46Z",
              "updatedAt": "2024-07-23T15:23:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6CzkYv",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-23T17:00:15Z",
          "updatedAt": "2024-07-23T17:00:15Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "maybe add a note about reverse CoA, and say also that systems SHOULD leave at least one connection open, to avoid delays opening new connections when traffic goes from zero to >0",
              "createdAt": "2024-07-23T17:00:15Z",
              "updatedAt": "2024-07-23T17:00:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DEgTC",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T11:05:23Z",
          "updatedAt": "2024-07-25T11:05:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Ah, mabye its just the type r/from/form/, but the point was to emphasize that current setups often use long-lived TLS connections.\r\n\r\nI will try to reword...",
              "createdAt": "2024-07-25T11:05:23Z",
              "updatedAt": "2024-07-25T11:05:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DElT9",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T11:16:07Z",
          "updatedAt": "2024-07-25T11:16:07Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Have to get a bit more into Reverse-CoA.\r\n\r\nI guess in the end this puts even more emphasis on the statement to which values to use:  'it very much depends...'. There is no one size fits all here.",
              "createdAt": "2024-07-25T11:16:07Z",
              "updatedAt": "2024-07-25T11:16:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DKax2",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T22:08:20Z",
          "updatedAt": "2024-07-25T22:08:20Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "ok, I think the from/form correction clarifies what is meant.\r\nLet's see what the WG says",
              "createdAt": "2024-07-25T22:08:20Z",
              "updatedAt": "2024-07-25T22:08:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DRqCa",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-26T18:04:55Z",
          "updatedAt": "2024-07-26T18:04:55Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think advising cilents to keep a connection open would be a bit misplaced in _this_ document (e.g. with dynamic discovery it might not be apropriate), but its very valid to acknowledge that some scenarios do require it.\r\n\r\nA quick cross-read of reverse-CoA, it might more clearly state that the client MUST keep at least one conneciton open (it's kind of implied, but not clearly stated).",
              "createdAt": "2024-07-26T18:04:55Z",
              "updatedAt": "2024-07-26T18:04:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOLrzygc52OTP7",
      "title": "move TLS response cache invalidation to common section",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/6",
      "state": "CLOSED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "wontfix"
      ],
      "body": "Invalidation of response cache applies to both TLS and DTLS since both are TLS session based. Move paragraph to the common section.",
      "createdAt": "2024-07-23T14:20:26Z",
      "updatedAt": "2025-07-07T17:38:30Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-response-cache",
      "headRefOid": "3de1750bff196d9c05782019bc455da166b26058",
      "closedAt": "2025-07-07T17:38:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\nSince the client connection is closed, those responses from the home server to the proxy server SHOULD be silently discarded by the proxy\r\n```\r\n\r\nMaybe make this MUST?  If the home server replies, there's no way for the proxy to send the packet anywhere.",
          "createdAt": "2024-07-23T17:03:07Z",
          "updatedAt": "2024-07-23T17:03:07Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Maybe make this MUST? If the home server replies, there's no way for the proxy to send the packet anywhere.\r\n\r\nAgreed; updated.",
          "createdAt": "2024-07-24T16:29:30Z",
          "updatedAt": "2024-07-24T16:29:30Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would change the title of this section.\r\nIt's not limited to cached response packets, it's also outstanding requests and all the other stuff that can happen if a connection gets torn down.\r\nI'll try to suggest a different title for this soon.\r\n\r\nOn another note: This again is something that is not necessarily specific to RADIUS/(D)TLS, it only comes up since we now have the concept of \"sessions\", where in RADIUS/UDP the proxy would just forward the response to the original client, despite it being down (since UDP does not have the concept of sessions, so how would the proxy know that the client is gone?)",
          "createdAt": "2025-04-14T16:38:55Z",
          "updatedAt": "2025-04-14T16:38:55Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1.  It's _all_ responses.  I'll also note the text in https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/6/commits/6c10a64b51930fd027cff1bf1405aeb1ac30ed2b doesn't make it clear that this is for _incoming_ connections\r\n\r\ni.e.\r\n* in an incoming connection is closed, then there is no way to send responses to anu requests which were received on that connection.  As a result, all requests MUST be discarded / stopped processing.  etc.\r\n* if an outgoing connection is closed, the proxy or client SHOULD try to send the packet over another outgoing connection.  Further details are outside of the scope of this specification.\r\n\r\nWe have this issue with TCP, too.  But that can be ignored.\r\n\r\nFor UDP, we have no way of knowing if the client is gone, so the server just always replies.",
          "createdAt": "2025-04-14T17:27:23Z",
          "updatedAt": "2025-04-14T17:27:23Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Very good point. I will try to come up with an updated text.",
          "createdAt": "2025-04-15T17:19:32Z",
          "updatedAt": "2025-04-15T17:19:32Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated proposed text.\r\n\r\nI've also added a sentence that associated EAP MAY continue with a RAIDUS request on a new connection. @alandekok please correct me if this is not true. The underlying EAP session will (or at least can) also do retransmissions, sent in a completely new RADIUS request?",
          "createdAt": "2025-04-16T05:11:55Z",
          "updatedAt": "2025-04-16T05:11:55Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking some more, there are more corner cases.  Perhaps:\r\n\r\nIf an incoming (D)TLS session or the underlying connection is closed or broken, then there is no way to send any response to the client.  The server behavior then depends on the types of packets being processed, and on the behavior of the server.\r\n\r\nA proxy which forwards packet MUST discard all requests associated with the closed connection.  As no response can be sent over the (D)TLS connection, and any further processing of requests is pointless.  A discarded request may have a cached RADIUS response packet ({{!RFC5080, Section 2.2.2}}), in which case the cached response is also discarded.  If there is no cached response packet, then the request is still being processed.  The server SHOULD immediately stop processing all such requests for this incoming connection.\r\n\r\nA home server which receives Access-Request packets MUST behave as defined above for a proxy.  Where a RADIUS packet is part of a multi-packet authentication session (e.g. EAP), the underlying authentication session could be continued, or the underlying authentication session data could be discarded.  The server may be able to receive and process another packet for that session via a different incoming connection.  It is difficult to make more recommendations for managing partially processed authentication sessions, as such recommendations depend strongly on the authentication method being used.  As a result, further behavior is implementation defined.\r\n\r\nA home server which receives other kinds of packets (Accounting-Request, CoA-Request, Disconnect-Request) MAY finish processing outstanding requests, and then discard any response.  This behavior ensures that the desired action is still taken, even if the home server cannot inform the client of the results of that action.",
          "createdAt": "2025-04-16T12:27:54Z",
          "updatedAt": "2025-04-16T12:27:54Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I've moved the text to a new pull request ( #33 )\r\n\r\nI'll mark this one as \"wontfix\", further discussion should happen in the new pull request",
          "createdAt": "2025-05-13T12:32:51Z",
          "updatedAt": "2025-05-13T12:32:51Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with #33 ",
          "createdAt": "2025-07-07T17:38:29Z",
          "updatedAt": "2025-07-07T17:38:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOLrzygc52OyfL",
      "title": "unify session resumption",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/7",
      "state": "CLOSED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "wontfix"
      ],
      "body": "TLS session resumption is currently a SHOULD requirement for DTLS and for TLS-PSK.\r\n\r\nUnify this recommendation for all use of (D)TLS and provide guidance for re-authorization as proposed by TLS-PSK.",
      "createdAt": "2024-07-23T15:22:02Z",
      "updatedAt": "2025-07-07T17:38:02Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-session-resumption",
      "headRefOid": "28da1b8ed627e6d410f89d907c9f0dc68fd5f7e9",
      "closedAt": "2025-07-07T17:38:02Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've be in favor of making it a MUST.  I don't see any benefit for an implementation to _not_ implement resumption.",
          "createdAt": "2024-07-23T17:01:57Z",
          "updatedAt": "2024-07-23T17:01:57Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I've be in favor of making it a MUST. I don't see any benefit for an implementation to _not_ implement resumption.\r\n\r\nI vote against a MUST. The benefit for implementos is saving time and effort (if a particular device or application is unlikely to gain much from it, thinking of Wifi APs rather just keep a connection open at all times). And _not_ implementing it doesn't break anything.",
          "createdAt": "2024-07-24T16:22:27Z",
          "updatedAt": "2024-07-24T16:22:27Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps a server MUST implement it.  I expect that all of them will do it anyways, so there's no harm here.\r\n\r\nClients which expect to implement many connections SHOULD implement it.  Clients which rarely open connections do not benefit as much from session resumption.",
          "createdAt": "2024-10-01T18:27:47Z",
          "updatedAt": "2024-10-01T18:27:47Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Done with #34 ",
          "createdAt": "2025-07-07T17:38:02Z",
          "updatedAt": "2025-07-07T17:38:02Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 8,
      "id": "PR_kwDOLrzygc52Xkvx",
      "title": "Edits to grammar/spelling.",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/8",
      "state": "MERGED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Grammatical edits as per my comments in the mailing list.",
      "createdAt": "2024-07-24T17:08:36Z",
      "updatedAt": "2024-10-04T13:54:34Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "ethompson-grammar-edits",
      "headRefOid": "4c4f7e86e4f0eed27e468a3f59741032c6a1e9a0",
      "closedAt": "2024-10-04T12:14:03Z",
      "mergedAt": "2024-10-04T12:14:03Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "35ae6a4ca2c9231c266cf008734673a1952814a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOLrzygc52Xohl",
      "title": "Update draft-ietf-radext-radiusdtls-bis.md flow",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/9",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I believe \"if no matches exist\" flows better in the text.",
      "createdAt": "2024-07-24T17:17:48Z",
      "updatedAt": "2024-10-05T15:45:27Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "Edits-to-text-flow",
      "headRefOid": "8bc754363c6fada03b5b62a2b7e1024aace4e35f",
      "closedAt": "2024-10-05T15:45:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These statements (matching CN) are obsoleted by RFC9525 anyway. PR #4 (should we accept it) removes them completely. ",
          "createdAt": "2024-07-25T09:55:48Z",
          "updatedAt": "2024-07-25T09:55:48Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> These statements (matching CN) are obsoleted by RFC9525 anyway. PR #4 (should we accept it) removes them completely.\r\n\r\n+1",
          "createdAt": "2024-10-01T18:24:46Z",
          "updatedAt": "2024-10-01T18:24:46Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I will close this in favor of #4 , keeping the changes made here in mind.",
          "createdAt": "2024-10-05T15:45:27Z",
          "updatedAt": "2024-10-05T15:45:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 10,
      "id": "PR_kwDOLrzygc52XqPe",
      "title": "Update draft-ietf-radext-radiusdtls-bis.md clarity",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/10",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarifying that a bad RADIUS secret could be caused by a misbehaving party OR a misconfigured one.",
      "createdAt": "2024-07-24T17:22:44Z",
      "updatedAt": "2024-10-05T15:46:27Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "misbehaving-or-misconfigured-party",
      "headRefOid": "2eec15be8d84d7a7dca662e858d100eac849854c",
      "closedAt": "2024-10-05T15:46:26Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll close this PR, if there are strong opinions in the interim about this, we can always include it, but I don't see the need.",
          "createdAt": "2024-10-05T15:46:26Z",
          "updatedAt": "2024-10-05T15:46:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L8mOZ",
          "commit": {
            "abbreviatedOid": "2eec15b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:18:12Z",
          "updatedAt": "2024-10-04T12:18:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"misconfigured\" would mean that it is acceptable to configure a shared secret. Since we mandate \"radsec\" resp. \"radius/dtls\" as shared secret, any deviation from that is (at least formally) not standard-compliant and thus misbehaving.\r\n\r\n(I know that most RADIUS/TLS implementations still allow to configure a custom shared secret)",
              "createdAt": "2024-10-04T12:18:12Z",
              "updatedAt": "2024-10-04T12:18:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L9ciw",
          "commit": {
            "abbreviatedOid": "2eec15b"
          },
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T13:56:33Z",
          "updatedAt": "2024-10-04T13:56:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I see your point, and I agree. I suppose I was getting caught up on the difference between \"behaving maliciously\" and being \"misconfigured\", though on another pass I think \"misbehaving\" does not necessarily imply malice. I am happy to drop this edit",
              "createdAt": "2024-10-04T13:56:33Z",
              "updatedAt": "2024-10-04T13:59:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOLrzygc56jx3x",
      "title": "Idle Timeout Configuration",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/11",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": " Added two sentences about exposing the idle timeout configuration to the administrator (from RFC 7360 Section 5.1.1)",
      "createdAt": "2024-09-05T17:54:37Z",
      "updatedAt": "2025-04-14T21:36:09Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "idle-timeout",
      "headRefOid": "307e5491319600fdb21f027445a123ec0a7c8b18",
      "closedAt": "2025-04-14T21:36:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems good to me",
          "createdAt": "2024-10-01T18:26:13Z",
          "updatedAt": "2024-10-01T18:26:13Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is possibly unnecessary if we choose to accept #5 ",
          "createdAt": "2024-10-06T20:00:49Z",
          "updatedAt": "2024-10-06T20:00:49Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "With #5 merged I think this is obsolete now.\r\nI'm closing it.",
          "createdAt": "2025-04-14T21:36:09Z",
          "updatedAt": "2025-04-14T21:36:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6MYvE0",
          "commit": {
            "abbreviatedOid": "307e549"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T18:56:44Z",
          "updatedAt": "2024-10-08T18:56:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Should be noted that for non-stream setup UDP sockets, Linux's Netfilter uses a timeout of 30 seconds, so might be worth lowering the bottom end to match?",
              "createdAt": "2024-10-08T18:56:44Z",
              "updatedAt": "2024-10-08T18:56:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOLrzygc56jySj",
      "title": "Parallel Connection Requests",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/12",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added text regarding the parallel connection requests detailed in RFC 6614 Section 2.3",
      "createdAt": "2024-09-05T17:55:47Z",
      "updatedAt": "2025-05-14T18:09:00Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "parallel-connection-requests",
      "headRefOid": "d33d9a1c2667393a88415511aec80f0b287a7e83",
      "closedAt": "2025-05-14T18:09:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would suggest to move this specification maybe even in an own paragraph.\r\n\r\nThis is not linked to (D)TLS directly, more in the direction of handling the underlying connection, and I think we need to add a few sentences for this exponential back-off mechanism.",
          "createdAt": "2024-10-04T12:24:29Z",
          "updatedAt": "2024-10-04T12:24:29Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It may be useful to have a section on managing connections, and distributing packets across connections.",
          "createdAt": "2024-10-04T13:04:00Z",
          "updatedAt": "2024-10-04T13:04:00Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a general RADIUS proxying issue and not limited to RADIUS/(D)TLS, so it is out-of-scope for this document.",
          "createdAt": "2025-05-14T18:08:58Z",
          "updatedAt": "2025-05-14T18:08:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOLrzygc56jyhL",
      "title": "EAP Section",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/13",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added EAP section to include details from RFC 6613",
      "createdAt": "2024-09-05T17:56:26Z",
      "updatedAt": "2025-04-14T16:22:12Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "section-EAP-sessions",
      "headRefOid": "e09d7ebb3ac8f26ff23fcad4616953c94788e506",
      "closedAt": "2025-04-14T16:22:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's worth noting that one has to be careful when proxying EAP requests.\r\nI agree with Fabian that if the RADIUS/(D)TLS client is the \"first in line\", they should know the EAP session and take care of the correct path themselves, so it is only relevant for proxies.\r\n\r\nI would include a bit more reasoning why EAP is different than other RADIUS traffic, so people reading this can understand why they should care.",
          "createdAt": "2024-10-04T12:45:54Z",
          "updatedAt": "2024-10-04T12:45:54Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the connection / load-balancing issues are similar for a client which originates traffic, and a proxy which forwards traffic.  So the text should be similar.\r\n\r\nThe connection issue isn't limited to EAP, it's \"all packets for one session\".  e.g., MFA challenge / response.\r\n\r\nIf an authentication step takes one packet, then it doesn't matter how the client does packet load-balancing.  The failure of any one connection will only affect authentications which go over that one connection.\r\n\r\nWhen authentication requires multiple packets, we have a choice for load-balancing:\r\n\r\n1. put all packets for the same session over the same connection\r\n2. distribute packets for the same session across multiple connections\r\n\r\nThe client does not know if the server is an IdP / home server, or a proxy.  The client does not even know if the connections are to multiple \"equivalent\" home servers.  As a result, when the client initiates an authentication session with a particular server, that authentication session MUST be tied to one connection.  Distributing packets for one session across multiple connections means that in some valid architectures, multiple home servers will see packets for one authentication session.\r\n\r\nWhile this situation may work in some limited scenarios, it guarantees that authentication cannot work in other scenarios which are in use today.\r\n\r\nThe situation isn't much different if the next hop is a proxy.\r\n\r\nWith (1), the failure of any one connection will affect only the sessions which use that connection.  i.e. for 5 active connections which then has one fail, 1/5 of authentication sessions will be affected.  It is likely that those authentication sessions will fail, especially if the connections are to separate home servers.  At the minimum, 1/5 authentication sessions will experience increased timeouts and instability as the client does fail-over.\r\n\r\nWith (2) the failure of any one connection will affect _all_ of the authentication sessions.  In the above scenario, any multi-round authentication session will have 1/5 of the packets sent across each connection.  So when a connection fails, _every_ ongoing session is affected.\r\n\r\nIn order to help with network robustness, clients MUST put all packets for one authentication session across the same connection.  If that connections fails, clients MAY distribute packets to a different connection, but this will work in only limited situations, and those authentication sessions are likely to fail.\r\n\r\nThe issue is different for accounting.  Each packet is stand-alone, and the packets are far enough apart in time that there is no benefit to putting them on the same connection.",
          "createdAt": "2024-10-04T13:25:23Z",
          "updatedAt": "2024-10-04T13:25:23Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "But then we have the problem of defining a \"session\".\r\nWe don't have any reliable easy-to-find indication which RADIUS packets belong to the same session.\r\nSo as far as I can see we have two options here:\r\n\r\nOption 1: mandate that load-balancing must only be done on the basis of the source of the RADIUS packet (i.e. if your proxy has two connected clients (A,B) and two servers (C,D), the proxy MAY load-balance so that all packets from A go to C and all packets from B go to D. If every RADIUS peer in the chain follows this procedure, we will always have a deterministic path through the RADIUS proxy fabric.\r\nThis is the safe option, but also ineffective.\r\n\r\nOption 2: Mandate nothing. Just say \"Proxying is hard. Beware, there be dragons\" and elaborate on what operators may have to consider if they want to enable load-balancing.\r\nIf the operators are running a RADIUS service that is strictly single request-response, then there is no harm in randomly throwing the packets to all the servers equally.\r\nIf the operators know that their RADIUS service has sessions and the sessions have to go to the same server, then they can disable load-balancing and instead move to a hot-standby configuration",
          "createdAt": "2024-10-04T13:35:27Z",
          "updatedAt": "2024-10-04T13:36:17Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 9:35 AM, Jan-Frederik Rieckers ***@***.***> wrote\n> But then we have the problem of defining a \"session\".\n> We don't have any reliable easy-to-find indication which RADIUS packets belong to the same session.\n\n  The State attribute connects multiple packets across one authentication session.\n\n  However, the State attribute is random, and can change between packets.  So we can't use that.\n\n  The practical solution as implemented by many sites is:\n\n* load-balance on hash of Calling-Station-Id if it exists\n* otherwise load-balance on hash of User-Name\n\n> So as far as I can see we have two options here:\n> \n> Option 1: mandate that load-balancing must only be done on the basis of the source of the RADIUS packet (i.e. if your proxy has two connected clients (A,B) and two servers (C,D), the proxy MAY load-balance so that all packets from A go to C and all packets from B go to D\n> This is the safe option, but also ineffective.\n\n  It doesn't work.\n\n> Option 2: Mandate nothing. Just say \"Proxying is hard. Beware, there be dragons\" and elaborate on what operators may have to consider if they want to enable load-balancing.\n\n  The RFCs contain near-zero discussion of load-balancing.  At the same time, implementors and administrators have converged on a common set of practices.  It would be good to at least document these practices as known working suggestions.\n\n> If the operators are running a RADIUS service that is strictly single request-response, then there is no harm in randomly throwing the packets to all the servers equally.\n\n  Yes.\n\n> If the operators know that their RADIUS service has sessions and the sessions have to go to the same server, then they can disable load-balancing and instead move to a hot-standby configuration\n\n  But if the load-balancing is done as described above, there's no need to do any of this.  Everything just works.  It doesn't matter if authentication sessions are one packet or many packets.  It doesn't matter if the next hop is an IdP / home server or proxy.  It doesn't matter what kind of architecture has been set up for load-balancing on the server side.\n\n  It all just works.",
          "createdAt": "2024-10-04T13:55:07Z",
          "updatedAt": "2024-10-04T13:55:07Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would opt for documenting some best practices, and suggest, but not mandate behavior.",
          "createdAt": "2024-10-04T14:00:50Z",
          "updatedAt": "2024-10-04T14:00:50Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 10:01 AM, Jan-Frederik Rieckers ***@***.***> wrote:\n> I would opt for documenting some best practices, and suggest, but not mandate behavior.\n\n  Sure.  With the caveat that if this practice isn't followed, then things are likely to go wrong, for the above-described reasons.\n\n",
          "createdAt": "2024-10-04T14:03:12Z",
          "updatedAt": "2024-10-04T14:03:12Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "NONE",
          "body": "Hashing with primarily `Calling-Station-Id` and `User-Name`; \ud83d\udc4d for that. We use the both by default and it works. I haven't ever seen them change during the EAP authentication exchange. MAC address randomisation may cause the C-S-I to change, but that would affect the subsequent (re)authentications only.\r\n\r\nA note about hashing: Let's say that there are 5 connections and hashing uses modulo 5 to choose the next hop. When a connection goes down, it would be good if the hashing is still done so that the existing EAP exchanges do not switch the next hop, for example, hashing being done with module 4.",
          "createdAt": "2024-10-08T16:49:50Z",
          "updatedAt": "2024-10-08T16:49:50Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Since this is not specific to RADIUS/(D)TLS, but a general RADIUS proxying issue, I think this is out-of-scope for this document.\r\nI'm therefore closing this PR without merging.",
          "createdAt": "2025-04-14T16:22:11Z",
          "updatedAt": "2025-04-14T16:22:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6LgHgs",
          "commit": {
            "abbreviatedOid": "e09d7eb"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T13:57:58Z",
          "updatedAt": "2024-10-01T13:57:58Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'm a bit confused about this MUST requirement.\r\n\r\nJust for my own understanding: we are talking about actual clients (i.e. NAS), and not proxies?\r\n\r\nI'm not very familiar with EAP on a NAS. I would expect that a client is always aware of the EAP sessions - but its details area outside of this specification. To me this is a prerequieiste for this MUST statement. If we can't guarantee this for a client, then we can't put a MUST here.\r\n\r\nThe second paragraph is confusing me. Having to keep EAP sessions together based on a radius attribute is something a proxy might do - as stated above a client should already know the EAP sessions. If a client has to guess the EAP sessions from a radius attribute, we can't call this a MUST.\r\n\r\nI would propose to remove the second paragraph (if my initial assumption of clients having perfect knowledge about EAP sessions is true).",
              "createdAt": "2024-10-01T13:57:58Z",
              "updatedAt": "2024-10-01T13:57:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOLrzygc56jz8n",
      "title": "Implementation Guidelines / Connected Sockets",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/14",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs discussion"
      ],
      "body": "Added section including the details from RFC 7360 Section 6. I didn't feel like this text would fit well in any of the existing sections, so I created a new one",
      "createdAt": "2024-09-05T17:59:30Z",
      "updatedAt": "2025-07-20T12:00:47Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "section-implementation-guidelines",
      "headRefOid": "7cf6645ec8727a844d8ab701f318ad13c6225982",
      "closedAt": "2025-07-20T12:00:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 7, 2024, at 5:46 AM, Jan-Frederik Rieckers ***@***.***> wrote:\n> ..\n> +RADIUS/(D)TLS clients should use a single source (IP + port) when sending packets to a particular RADIUS/(D)TLS server. Doing so minimizes the number of (D)TLS session setups. It also ensures that information about the home server state is discovered only once.\n> \n> This could be a problem if a single RADIUS/(D)TLS peer has so much packet throughput that a single connection would be clogged (due to the limited ID space), and in this case the client would have to open a second connection to the same server to increase the usable space for packets-in-flight.\n> \n> I think we don't have text for that in the document yet, maybe it should be included in #13\n\n  Perhaps instead of a \"single\" connection, they should use the \"minimal\" number of connections.",
          "createdAt": "2024-10-07T11:26:56Z",
          "updatedAt": "2024-10-07T11:26:56Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I am closing this PR since most of it is out-of-scope. (Feel free to re-open if it should still be included)",
          "createdAt": "2025-05-14T18:12:49Z",
          "updatedAt": "2025-05-14T18:12:49Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure why it is out of scope?  DTLS implementations issues are not covered in any of the underlying DTLS RFCs.  This text gives implementers specific and actionable guidelines for how to create servers that work.\r\n\r\nOne of my pet peeves over the years is RFCs which describe how to encode / decode packets, and then leave absolutely everything else unspecified.  The result is endless interoperability issues, bugs, etc.\r\n\r\nI'd like a larger discussion on the RADEXT list about scope, so I'll re-open this issue.",
          "createdAt": "2025-05-14T18:34:14Z",
          "updatedAt": "2025-05-14T18:34:14Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "  Hmm. Double checking osx and FreeBSD, they all have the same text about connected udp sockets. I missed that, and had  found other references which said something else. \n\n  Ok, my objections are withdrawn, and I'll go over the text for any needed updates. \n",
          "createdAt": "2025-05-23T17:00:53Z",
          "updatedAt": "2025-05-23T17:00:53Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed at the hackathon, this is mostly already in the document, so we can close this.",
          "createdAt": "2025-07-20T12:00:47Z",
          "updatedAt": "2025-07-20T12:00:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6IH8lB",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T18:18:57Z",
          "updatedAt": "2024-09-05T18:18:58Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Perhaps \"historic\" or \"legacy\" instead of \"traditional\"",
              "createdAt": "2024-09-05T18:18:58Z",
              "updatedAt": "2024-09-05T18:18:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6IH9Kl",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T18:20:21Z",
          "updatedAt": "2024-09-05T18:20:21Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "The use of unconnected sockets is only for UDP / DTLS.",
              "createdAt": "2024-09-05T18:20:21Z",
              "updatedAt": "2024-09-05T18:20:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LhOL6",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T15:32:45Z",
          "updatedAt": "2024-10-01T15:32:45Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I'm opposing this recommendation. \r\n\r\nTo my knowledge, the stated limitation not beeing able to accept packets from different clients on the same port is wrong.\r\n\r\nUsing connected UDP sockets works perfectly fine and simplifies DTLS implementation a lot. Having to manually manage DTLS sessions and hand over received DTLS frames to the correct TLS context would be extremely tedious. Using connected UDP sockets and letting the TLS library do the hard work is way easier. ",
              "createdAt": "2024-10-01T15:32:45Z",
              "updatedAt": "2024-10-01T15:32:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LijjY",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T18:18:37Z",
          "updatedAt": "2024-10-01T18:18:38Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Where the src/dst ip/port is known in advance, connected UDP sockets work fine.  Where there is instead a \"wildcard\" socket for receiving packets from known clients but unknown source ports, connected UDP sockets have unavoidable race conditions in the network stack.\r\n\r\nA RADIUS server would typically perform the following steps to get a connected socket:\r\n\r\n1. open wildcard socket \"*:1812\" for UDP\r\n2. accept packets for that socket\r\n3. see new client source IP and source port\r\n4. Open new UDP socket on the same source IP/port (SO_REUSEADDR / SO_REUSEPORT)\r\n5. call connect() to connect to the client source IP and port\r\n6. receive packets on the connected socket\r\n\r\nFor a TCP connection, steps (4) and (5) are handled by `accept()`, which is atomic.  It both opens a new socket, and ties that socket to a particular src/dst IP/port.\r\n\r\nIn contrast for UDP, steps (4) and (5) are done as separate system calls by the application.  There is no clear way to know what happens to packets during that window.\r\n\r\ni.e. if there are multiple packets in the receive queue, does the `connect()` pull all packets out of the wildcard socket, and move them to the new socket?  Or do some packets go to the new connected socket, while other packets go to the original wildcard socket?\r\n\r\nAll of this is OS dependent.\r\n\r\nIf will _usually_ work, for the simple reason that the inter-packet spacing is larger than the time between system calls in steps (4) and (5).  But there is no _guarantee_ that it works.\r\n\r\nIf we do suggest that connected sockets are fine, then these issues should be explained, so that implementors are aware of them and can address them. \r\n\r\nThis issue is address in more detail in a cloudflare article:  https://blog.cloudflare.com/everything-you-ever-wanted-to-know-about-udp-sockets-but-were-afraid-to-ask-part-1/",
              "createdAt": "2024-10-01T18:18:38Z",
              "updatedAt": "2024-10-01T18:18:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LwOrL",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-03T05:26:33Z",
          "updatedAt": "2024-10-03T05:26:34Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I think here steps 4-5 are a non-issue. It may be in a general case (depending on the protocol, like quic), but since we are dealing explicitly with DTLS, its not.\r\n\r\nYes, between steps 3 and 5 any packet that arrives in that time frame _on the same 5-tuple_ will unpredictably be received by either the wildcard socekt or the connected socket. However in DTLS, there is no legal packat that can arrive _on the same 5-tuple_ between the initial client hello and an apropriate response from the server - which it will only send after connecting the socket. \r\n\r\n(sidenote: the initial client hello MUST fit into a single UDP packet; I stumbled over this when it didn't and OpenSSL would immediatley error out telling me so)\r\n\r\nThe worst thing that can happen is if duplicate UDP packets (client hello) arrive. If the connected socket gets it, I'm not shure how OpenSSL handles it, probably silently discards. If the wildcard socket gets it, it will try to connect another socket to the same 5-tuple, which will then fail.",
              "createdAt": "2024-10-03T05:26:34Z",
              "updatedAt": "2024-10-03T05:26:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LzyKi",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-03T13:22:07Z",
          "updatedAt": "2024-10-03T13:22:07Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "> However in DTLS, there is no legal packat that can arrive on the same 5-tuple between the initial client hello and an apropriate response from the server - which it will only send after connecting the socket.\r\n\r\nGood point.  I agree then that DTLS connections SHOULD use connected sockets.\r\n\r\nThis issue should be described and explained in the spec.",
              "createdAt": "2024-10-03T13:22:07Z",
              "updatedAt": "2024-10-03T13:22:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MKCBu",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T09:43:11Z",
          "updatedAt": "2024-10-07T09:43:11Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe text above describes the protocol. In this section, we give additional implementation guidelines. These guidelines are not part of the protocol, but they may help implementors create simple, secure, and efficient implementations.\r\n```\r\nI would argue that the \"interoperable\" part is the responsibility of the protocol specification. So I would not put \"interoperable\" here, but a different word. I'm not sure if \"efficient\" is the right one, maybe something along \"predictable\" in the meaning that administrators of different RADIUS/(D)TLS servers by different vendors can rely on a somewhat similar behavior under the same circumstances.",
              "createdAt": "2024-10-07T09:43:11Z",
              "updatedAt": "2024-10-07T09:43:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MKDhY",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T09:45:47Z",
          "updatedAt": "2024-10-07T09:45:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This could be a problem if a single RADIUS/(D)TLS peer has so much packet throughput that a single connection would be clogged (due to the limited ID space), and in this case the client would have to open a second connection to the same server to increase the usable space for packets-in-flight.\r\n\r\nI think we don't have text for that in the document yet, maybe it should be included in #13",
              "createdAt": "2024-10-07T09:45:47Z",
              "updatedAt": "2024-10-07T09:45:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MKJyX",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T09:56:47Z",
          "updatedAt": "2024-10-07T09:56:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "We already have some of this text in the \"Client Subsystems\" section in the Security considerations. Would you suggest merging the \"Client Subsystems\" section in this section?\r\nOtherwise, this text should at least reference the security considerations.",
              "createdAt": "2024-10-07T09:56:47Z",
              "updatedAt": "2024-10-07T09:56:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qvosQ",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-23T14:23:06Z",
          "updatedAt": "2025-05-23T14:23:06Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think\r\n> use a single source (IP + port) when sending packets to a particular RADIUS/(D)TLS server\r\n\r\nwould be wrong. We can only associate packets to a TLS session using the 5-tuple. For TCP this is implicit, for UDP, we can tell the kernel to do it by using connected sockets, or do it manually - but there is no more information besides the 5-tuple to do it.\r\nWithout RADIUS/1.1, we need the possibility of multiple TLS sessions to mitigate ID-exhaustion.\r\nIf any, the client shoud minimize the number of TLS sessions.",
              "createdAt": "2025-05-23T14:23:06Z",
              "updatedAt": "2025-05-23T14:23:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qwSdI",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-23T15:12:57Z",
          "updatedAt": "2025-05-23T15:12:57Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I agree that clients should minimize the number of TLS sessions.\r\n\r\nIn most cases, the 5-tuple will be enough to track a UDP \"connection\".   However, this is not guaranteed to work when NATs are used.  It will generally be OK, but the NAT RFCs allow NATs to re-use a source port after 30 seconds.\r\n\r\nPlus, UDP connected sockets do not work like TCP connected sockets.  I spent some time looking into this over the past few months.\r\n\r\nUDP connected sockets do what you expect _only_ for sending packets.  They allow an application to call `write()` instead of `sendto()` for UDP data.\r\n\r\nFor receiving packets, the OS will deliver UDP packets to the destination IP / port _no matter what the source IP is_.  As a result, a system receiving packets always has to use `recvfrom()`, and then check the source IP.  This is needed even for connected UDP sockets.\r\n\r\nThis usually isn't an issue in practice, because not many people are spamming UDP packets to RADIUS IP/ports.  But if a DTLS server is publicly available, this will happen.\r\n\r\nIn general, this means that servers can't use connected UDP sockets to track a \"UDP session\".",
              "createdAt": "2025-05-23T15:12:57Z",
              "updatedAt": "2025-05-23T15:12:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qxLbk",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-23T16:30:20Z",
          "updatedAt": "2025-05-23T16:30:20Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "We have to use exatley the 5-tuple, there is no other information to associate an incoming packet with a TLS session. If the NAT descides to reuse a port after not seeing a packet for 30 seconds, it will stomp on that connection and break it. The TLS layer will take care of it and not accept any TLS messages not belonging to the old session. Same could happen if the client restarts (wihtout closing the DTLS conection) and reuses the port. \r\n\r\nConnected UDP sockets are perfectly fine for DTLS - I have a working implementation. In terms of steering incoming packets to the correct socket, it works exactly like TCP - you just have to implement the `accept()` logic yourself (i.e. getting the first packet with `recvfrom()` and then creating a new socket and `bind()` plus `connect()` it to the incoming 5-tuple). The linux manpage about `connect()` explicitly states: \r\n>If the socket sockfd is of type SOCK_DGRAM, then addr is the\r\n       address to which datagrams are sent by default, and the only\r\n       address from which datagrams are received.\r\n\r\nBut in the end its irrelevant wether you use connected sockets or not, the provisions of associating a 5-tuple with a tls session remain the same.\r\n",
              "createdAt": "2025-05-23T16:30:20Z",
              "updatedAt": "2025-05-23T16:30:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOLrzygc56kd9E",
      "title": "CA Trust for RADIUS/(D)TLS Clients",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/15",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "wontfix"
      ],
      "body": "Added blurb on how CA trust for RADIUS/(D)TLS clients should be configured (from RFC 7360 Section 10.4)",
      "createdAt": "2024-09-05T19:57:29Z",
      "updatedAt": "2025-05-27T08:54:01Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "client-trusted-authorities",
      "headRefOid": "daba6298ee529e95e6bbc0f78766654d43d63652",
      "closedAt": "2025-05-27T08:54:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2024-09-06T14:01:17Z",
          "updatedAt": "2024-09-06T14:01:17Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 9:07 AM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> \u2b07\ufe0f Suggested change\r\n\r\n  Looks good.\r\n\r\n",
          "createdAt": "2024-10-04T14:22:36Z",
          "updatedAt": "2024-10-04T14:22:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "With the general rewrite of the document, I'm not sure if this PR is still applicable, and I would appreciate feedback from the WG participants on whether or not this text is needed.",
          "createdAt": "2025-04-14T16:31:45Z",
          "updatedAt": "2025-04-14T16:31:45Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's necessary to have some text which says \"clients MUST NOT come with a pre-configured list of trusted CAs\".",
          "createdAt": "2025-04-14T17:29:32Z",
          "updatedAt": "2025-04-14T17:29:32Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #35 ",
          "createdAt": "2025-05-27T08:54:01Z",
          "updatedAt": "2025-05-27T08:54:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L8_ON",
          "commit": {
            "abbreviatedOid": "8f7c295"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T13:06:58Z",
          "updatedAt": "2024-10-04T13:06:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "The idea is good, I completely agree.\r\n\r\nI'm just not really comfortable with the text, I've tried to re-word it a bit, maybe you see where my problems are.\r\nIf you have an alternative: I'm happy to throw my re-wording away ;)\r\n\r\n```suggestion\r\nIf this model is implemented, RADIUS/(D)TLS clients SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer. Instead, the clients SHOULD start off with an empty CA list. The addition of a CA SHOULD be done only when manually configured by an administrator.\r\n\r\nThe goal of RADIUS/(D)TLS is to securely communicate with only a small set of well-known peers.\r\nThese peers will use specific certificates, potentially even from a private purpose-specific CA.\r\nThis scenario is different from a common use case of PKIX where an entity wants to communicate securely with unknown remote entities (i.e. web browsing), that use the public CAs to establish a trust path to this unknown entity.\r\n```",
              "createdAt": "2024-10-04T13:06:59Z",
              "updatedAt": "2024-10-04T13:06:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L-ASL",
          "commit": {
            "abbreviatedOid": "8f7c295"
          },
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T14:57:19Z",
          "updatedAt": "2024-10-04T14:57:20Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I am happy with these changes",
              "createdAt": "2024-10-04T14:57:19Z",
              "updatedAt": "2024-10-04T14:57:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MYyzO",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T19:04:50Z",
          "updatedAt": "2024-10-08T19:04:50Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I would suggest amending this to reflect should not be pre-configured as *already* trusted for the client.\r\n\r\nI could perceive an onboarding process that assists the administrator to know which CA to add as a trust anchor for the given client; it would show the chain but the administrator would still be expected to approve it.",
              "createdAt": "2024-10-08T19:04:50Z",
              "updatedAt": "2024-10-08T19:05:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6NyyC-",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-18T20:13:50Z",
          "updatedAt": "2024-10-18T20:13:50Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nIf this model is implemented, RADIUS/(D)TLS peers SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer that are enabled by default. Instead, the peers SHOULD start off with an empty CA list. The addition of a CA SHOULD be done only when manually configured by an administrator.\r\nThis does not mean that vendors or manufactures cannot include trust lists in their products, but enabling these lists should always be a conscious decision of the administrator.\r\n\r\nThe goal of RADIUS/(D)TLS is to securely communicate with only a small set of well-known peers.\r\nThese peers will use specific certificates, potentially even from a private purpose-specific CA.\r\nThis scenario is different from a common use case of PKIX where an entity wants to communicate securely with unknown remote entities (i.e. web browsing), that use the public CAs to establish a trust path to this unknown entity.\r\n```",
              "createdAt": "2024-10-18T20:13:50Z",
              "updatedAt": "2024-10-18T20:13:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6Nyyky",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-18T20:15:26Z",
          "updatedAt": "2024-10-18T20:15:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This is a suggestion to include the feedback from the interim.\r\nWordsmithing welcome, I'm not completely satisfied with the wording.\r\nLeaving the second should in lowercase was intended. This sentence is just information and not normative.",
              "createdAt": "2024-10-18T20:15:26Z",
              "updatedAt": "2024-10-18T20:15:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N0oja",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-19T11:41:07Z",
          "updatedAt": "2024-10-19T11:41:07Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I like the second part as is, it is helpful in explaining why someone should not just blindly leap and lean pre-trusting the web forum certs (which I probably would have done myself as an implementer), so my bike shedding suggestion is really only for the first part:\r\n\r\n\"If this model is implemented, RADIUS/(D)TLS peers SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer that are enabled by default. Instead, the peers SHOULD begin untrusted (ie. an empty CA list) and the process of trusting a given CA SHOULD be a manually step performed by an administrator.\r\n\r\nThis does not preclude vendors or manufactures including trust lists in their products, but the enabling of those lists should be a conscious decision by an administrator.\"",
              "createdAt": "2024-10-19T11:41:07Z",
              "updatedAt": "2024-10-19T11:41:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N_zQ_",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T14:32:44Z",
          "updatedAt": "2024-10-21T14:32:44Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I don't like the \"should begin untrusted\". The peers themselves are not untrusted, they are just untrusting (so to speak).\r\nAnd shouldn't it be \"should be a manual step performed by ...\" or \"manually performed step\"?",
              "createdAt": "2024-10-21T14:32:44Z",
              "updatedAt": "2024-10-21T14:33:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6ODSbt",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T20:17:56Z",
          "updatedAt": "2024-10-21T20:17:56Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I think a hybrid of the two for the \"first chunk\" would be good:\r\n\r\n\"If this model is implemented, RADIUS/(D)TLS peers SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer that are enabled by default. Instead, the peers SHOULD start off with an empty CA list. The addition of a CA SHOULD be done only when manually configured by an administrator.\r\n\r\nThis does not preclude vendors or manufactures including trust lists in their products, but the enabling of those lists should be a conscious decision by an administrator.\"\r\n\r\nAs for the \"second chunk\", I would change the wording slightly to something like:\r\n\r\n\"The goal of RADIUS/(D)TLS is to communicate securely with only a small set of well-known peers.\r\n\r\nThese peers will use specific certificates, potentially from a private, purpose-specific CA.\r\n\r\nThis scenario is different from the common use case of PKIX, where the goal is to communicate securely with unknown remote entities (e.g., web browsing) that use public CAs to bootstrap trust.\"\r\n\r\nThough, I'm not in love with saying \"specific certificates\" since I think that could be a little vague or confusing.",
              "createdAt": "2024-10-21T20:17:56Z",
              "updatedAt": "2024-10-21T20:17:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOLrzygc56q4EP",
      "title": "Security Consideration: Network Address Translation",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/16",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs discussion"
      ],
      "body": "Added subsection on Network Address Translation (from RFC 7360 Section 10.5)",
      "createdAt": "2024-09-06T13:49:12Z",
      "updatedAt": "2025-07-20T12:05:51Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "Network-Address-Translation",
      "headRefOid": "3b26c0292bf02130fefe81928dd882b4c82b3c1b",
      "closedAt": "2025-07-20T12:05:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2024-09-06T14:02:59Z",
          "updatedAt": "2024-09-06T14:02:59Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 9:19 AM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> +## Network Address Translation\r\n> +\r\n> +Network Address Translation (NAT) is fundamentally incompatible with RADIUS/UDP. RADIUS/UDP uses the source IP address to determine the shared secret for the client, and NAT hides many clients behind one source IP address. As a result, RADIUS/UDP clients cannot be located behind a NAT gateway.\r\n> +\r\n> +In addition, port reuse on a NAT gateway means that packets from different clients may appear to come from the same source port on the NAT. That is, a RADIUS server may receive a RADIUS/DTLS packet from one source IP/port combination, followed by the reception of a RADIUS/UDP packet from that same source IP/port combination. If this behavior is allowed, then the server would have an inconsistent view of the client\u2019s security profile, allowing an attacker to choose the most insecure method.\r\n> \r\n> I'm not sure exactly what the problem here is and if the proposed solution is correct.\r\n> \r\n> I'll try to put it the way I understand the problem:\r\n> \r\n> A 10.0.0.1 (RADIUS/DTLS) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:2083\r\n> B 10.0.0.2 (RADIUS/UDP) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:1812\r\n> \r\n> So now the RADIUS server has two UDP connections to 192.0.2.1:12345, but since the port on the RADIUS server side is different, the NAT can translate the UDP packets from source port 2083 to A and the ones from 1812 to B.\r\n\r\n  Yes.  The issue is the network security model.\r\n\r\n> In my view, the problem here is that, if the server mixes those up, the server is at fault for allowing the client list for RADIUS/UDP to merge with the client list for RADIUS/DTLS.\r\n> Those two client lists should be separate (at least in terms of IP-Addr/Port).\r\n\r\n  We don't know what source port will be used by the client.  So we can't rely on that.\r\n\r\n  All we know is that one IP is sending us RADIUS/UDP, and RADIUS/TLS.  The question is not just what to do, but what we _can_ do in that situation.\r\n\r\n> We cannot force every client behind a NAT to behave this way, because the NAT may be responsible for a huge variety of customer nets, and we can't mandate them to speak to each other.\r\n> \r\n> Example: Carrier-Grade NAT (CGN), Company A has a Dual-Stack internet connection with CGN for v4 and uses legacy-RADIUS, Company B has the same, but uses RADIUS/(D)TLS for their connection. We can't define a standard where Company A would now be forced to migrate to RADIUS/(D)TLS. They have no way of knowing that Company B is using DTLS with the same server. And we shouldn't mandate that the CGN keeps track of all possible connections and makes sure that no source port gets re-used if RADIUS/(D)TLS and RAIDUS/UDP are used with the same server.\r\n\r\n  Agreed.\r\n\r\n  To a certain extent, there is no technical reason why a server can't accept both RADIUS/UDP and RADIUS/TLS from the same source IP.  The packets are clearly distinguishable.\r\n\r\n  The problem we're trying to solve is to stop down-bidding attacks.  The simplest approach then is to say that both UDP and TLS may be allowed for compatibility, but that this configuration is NOT RECOMMENDED.",
          "createdAt": "2024-10-04T14:21:48Z",
          "updatedAt": "2024-10-04T14:21:48Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see benefit in adding this text to the document, so I'm closing this PR.\r\nFeel free to re-open if it is still needed.",
          "createdAt": "2025-05-14T18:31:13Z",
          "updatedAt": "2025-05-14T18:31:13Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps the text could be reworded to be less NAT specific?  Many people operate RADIUS clients behind a NAT gateway, so it could be useful to explain how NAT affects RADIUS/(D)TLS.",
          "createdAt": "2025-05-14T18:36:00Z",
          "updatedAt": "2025-05-14T18:36:00Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "The question is: Is this RADIUS/(D)TLS specific?\r\nI would argue that any effect of NAT also applies to a RADIUS/UDP with multiple different ports.",
          "createdAt": "2025-05-14T20:44:07Z",
          "updatedAt": "2025-05-14T20:44:07Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In RADIUS/UDP, clients are uniquely identified based on source IP address.  In contrast, NAT hides multiple different clients behind one IP address.  The two are therefore fundamentally incompatible.\r\n\r\nSome implementations have addressed this by looking at the contents of the RADIUS packet.  If the packet contains `NAS-IP-Address = IP1`, then it is identified as \"client 1\".  If the packet contains `NAS-IP-Address = IP2` then it is identified as \"client 2\".  This practice \"works\", for various values of \"works\".\r\n\r\nWhile the NAT usually maps one (source IP/port) to one outbound port on the NAT box, this mapping is not guaranteed.  It can change over time, without notice to either RADIUS client or server.  The server therefore can _mostly_ treat packets from one NAT port as being from the \"same\" client, but it cannot _guarantee_ that they are from the same client.  If some time has passed with no traffic, the port can be re-used.\r\n\r\n[RFC 4787 Section 4.3](https://datatracker.ietf.org/doc/html/rfc4787#section-4.3) suggests that the timeouts SHOULD be 5 minutes.  However, sites like Google Cloud default to [30 seconds](https://cloud.google.com/nat/docs/tune-nat-configuration#nat-timeouts).  Linux also appears to default to 30 seconds.\r\n\r\nIn order to keep the port mapping alive, the client must send network traffic within that timeout period.  But many clients don't send keep-alives, as [RFC 2865 Section 2.6](https://datatracker.ietf.org/doc/html/rfc2865#section-2.6) says that keep-alives are harmful.\r\n\r\nThese limitations mean that the server can only determine client identity by examining the contents every packet RADIUS/UDP in isolation.  This behavior is at best a hack, and is not standardized in any RADIUS RFC.\r\n\r\nIn contrast, with DTLS, there is a way to uniquely identify a client: the TLS session.  This identification is independent of source IP or source port.  With TLS, the identification is even stronger: the underlying TCP connection.  The properties of TCP ensure that the TCP connections won't conflict with each other, even if the NAT box reuses a source port.\r\n\r\nAs a result, NAT is fundamentally incompatible with RADIUS/UDP, but makes zero difference to RADIUS/(D)TLS.\r\n\r\nThere is an additional issue, as pointed out in the suggested text.\r\n\r\nWhen multiple clients are placed behind a NAT, the security of the system as a whole is limited by the least secure client.  Since the NAT gateway uses the same source IP for both RADIUS/UDP clients, and RADIUS/(D)TLS clients, the server must allow RADIUS/UDP from that source IP.  Which means that it's possible for a misconfiguration change the RADIUS/(D)TLS clients so that they use RADIUS/UDP.  The server has essentially no way of knowing that this has taken place, because (as noted above) it has few options for distinguishing RADIUS/UDP clients behind a NAT.\r\n\r\nAs a result, I think the text is useful, and should stay in.",
          "createdAt": "2025-05-17T11:45:52Z",
          "updatedAt": "2025-05-17T11:45:52Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "should be fixed with the new paragraph introduced in f16113d",
          "createdAt": "2025-07-20T12:05:51Z",
          "updatedAt": "2025-07-20T12:05:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L9F4L",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T13:18:51Z",
          "updatedAt": "2024-10-04T13:18:51Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'm not sure exactly what the problem here is and if the proposed solution is correct.\r\n\r\nI'll try to put it the way I understand the problem:\r\n\r\nA 10.0.0.1 (RADIUS/DTLS) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:2083\r\nB 10.0.0.2 (RADIUS/UDP) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:1812\r\n\r\nSo now the RADIUS server has two UDP connections to 192.0.2.1:12345, but since the port on the RADIUS server side is different, the NAT can translate the UDP packets from source port 2083 to A and the ones from 1812 to B.\r\n\r\nIn my view, the problem here is that, if the server mixes those up, the server is at fault for allowing the client list for RADIUS/UDP to merge with the client list for RADIUS/DTLS.\r\nThose two client lists should be separate (at least in terms of IP-Addr/Port).\r\n\r\nWe cannot force every client behind a NAT to behave this way, because the NAT may be responsible for a huge variety of customer nets, and we can't mandate them to speak to each other.\r\n\r\nExample: Carrier-Grade NAT (CGN), Company A has a Dual-Stack internet connection with CGN for v4 and uses legacy-RADIUS, Company B has the same, but uses RADIUS/(D)TLS for their connection. We can't define a standard where Company A would now be forced to migrate to RADIUS/(D)TLS. They have no way of knowing that Company B is using DTLS with the same server. And we shouldn't mandate that the CGN keeps track of all possible connections and makes sure that no source port gets re-used if RADIUS/(D)TLS and RAIDUS/UDP are used with the same server.",
              "createdAt": "2024-10-04T13:18:51Z",
              "updatedAt": "2024-10-04T13:18:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MYUsP",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T18:05:08Z",
          "updatedAt": "2024-10-08T18:05:08Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Fortunately any kind of NAT is not going to blend this to the same source IP and port (to the same destination IP and port) as it would have no way to figure out what to do with the responses from the server (ie. which client gets them); ignoring the case of the idle timeout ending a flow and starting the new one.\r\n\r\nOtherwise I can only see this attack working if a server ignored the destination IP/port. Maybe I am missing something...",
              "createdAt": "2024-10-08T18:05:08Z",
              "updatedAt": "2024-10-08T19:29:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qvyDq",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Over all, I don't see NAT as a security consideration. Yes (D)TLS works way better behind a NAT than UDP - but that's just one more point why to use TLS in the first place - for practical reasons.",
          "createdAt": "2025-05-23T14:35:16Z",
          "updatedAt": "2025-05-23T14:46:35Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "This statement is fundametally wrong. RADIUS/UDP works perfeclty fine behind a NAT, as many Wifi deployments where each individual AP talks to the radius server directly demonstrates. The only caveat is that all RADIUS clients behind a nat MUST use the same shared secret.",
              "createdAt": "2025-05-23T14:35:16Z",
              "updatedAt": "2025-05-23T14:46:35Z"
            },
            {
              "originalPosition": 16,
              "body": "as @jimdigriz mentioned, a NAT cannot reuse a 5-tuple. In practice any NAT implementation I've come across won't even reuse the source port. So this is a non-issue to me.\r\nEven if a NAT would do that, the provisions in this draf state that any given port on a server MUST only accept one protocol, i.e. a port accepting DTLS packets must discard any packets that is not a TLS message.",
              "createdAt": "2025-05-23T14:42:26Z",
              "updatedAt": "2025-05-23T14:46:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qwKhF",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-23T15:03:38Z",
          "updatedAt": "2025-05-23T15:03:38Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "The \"fundamentally incompatible\" phrase is not about whether it works, but whether it breaks the security model of RADIUS.  Having multiple clients behind a NAT might \"work\", but it has not been standardized in the RFCs.\r\n\r\nHaving multiple clients share the same secret is bad security practice, and should not be recommended by a standard,.",
              "createdAt": "2025-05-23T15:03:38Z",
              "updatedAt": "2025-05-23T15:03:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qwW1k",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-23T15:19:07Z",
          "updatedAt": "2025-05-23T15:19:07Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Aa NAT is allowed to re-use a source port after 30 seconds without traffic.  So the issue should be discussed here, I think.\r\n\r\nHaving different server ports for UDP vs DTLS addresses some of the security issues, but it still allows for down-grade attacks.\r\n\r\nWhen there are both UDP and DTLS clients are behind a NAT, then it is possible for a misconfiguration to turn a DTLS client into a UDP client.  Since the server accepts both kinds of packets, it must accept these packets.  And it may be difficult for the server to tell that this is happening.\r\n\r\nWe should really recommend against allowing both UDP and DTLS clients behind a NAT.  If we don't discuss it here, then I expect the SECDIR reviewer or the IESG will point it out.",
              "createdAt": "2025-05-23T15:19:07Z",
              "updatedAt": "2025-05-23T15:19:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOLrzygc56q4c1",
      "title": "Security Consideration: Wildcard Clients",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/17",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added subsection for Wildcard Clients (from RFC 7360 Section 10.6)",
      "createdAt": "2024-09-06T13:50:05Z",
      "updatedAt": "2025-05-14T18:38:21Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "wildcard-clients",
      "headRefOid": "1c0759df6ab4a748b1ae3b37557166d63dbbdf3c",
      "closedAt": "2025-05-14T18:38:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2024-09-06T14:01:36Z",
          "updatedAt": "2024-09-06T14:01:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good, though I'm not convinced it warrants opening a whole new section. Maybe we could include this specification somewhere else?\r\nWe have a bit of discussion on IP ranges already in the \"Connecting Client Identity\" section (currently 4.3)\r\n\r\nEdit: Sorry, didn't see that this was in the security considerations section.\r\nMy point still somewhat stands, but with one addition: For security considerations, I would suggest to add a bit more text why this is not an issue with RADIUS/(D)TLS, what we gain from identifying the client, etc.",
          "createdAt": "2024-10-04T13:22:09Z",
          "updatedAt": "2024-10-04T13:24:47Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "NONE",
          "body": "Could we change 'wildcard' to something else? One reason is that because this document relates to TLS, it's easy to get confused between wildcard clients and wildcard certificates. The second reason is that it gives the possibility to use 'wildcard' only when discussing about wildcard certificate.\r\n\r\nI see that there's nothing about wildcard certificates currently in the draft or RFCs. There probably should be? Ban them altogether (easy) or define how they are to be used (more work). Edit: pull request #4 adds a note about wildcard certificates.",
          "createdAt": "2024-10-04T17:03:18Z",
          "updatedAt": "2024-10-04T17:07:13Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 for not using \"wildcard\" when talking about clients.",
          "createdAt": "2024-10-04T17:22:07Z",
          "updatedAt": "2024-10-04T17:22:07Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the whole \"Connecting Client Identity\" is not used anywhere in this document, there is no point in mentioning this again for ip-range-config clients.\r\n\r\nHow to identify clients and what to do when you have identified a client is out-of-scope for this document.\r\nWe only make sure that the client has a valid config. Whether or not it's the same client is not important for RADIUS/(D)TLS, but a general RADIUS issue.\r\nI'm going to close the PR.",
          "createdAt": "2025-05-14T18:38:21Z",
          "updatedAt": "2025-05-14T18:38:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOLrzygc56rxFz",
      "title": "Security Consideration: Crypto-Agility",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/18",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "Added some basic text to reference the Deprecating Insecure Practices in RADIUS document (to address RFC 7360 Section 10.1)",
      "createdAt": "2024-09-06T16:02:52Z",
      "updatedAt": "2025-05-14T18:41:47Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "security-considerations-crypto-agility",
      "headRefOid": "75f3d6d19314e14940458386c31434a16f23572d",
      "closedAt": "2025-05-14T18:41:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps\r\n\r\n\r\n# Crypto-Agility\r\n\r\nCrypto-agility requirements were discussed extensively in {{RFC6421}}.  {{RFC6614, Appendix C}} described how these requirements were met for RADIUS/TLS.  {{RFC7360, Section 10.1}} described how these requirements were met for RADIUS/DTLS.   The final outcome of the {{RFC6421}} crypto-agility requirements are discussed in {{?I-D.ietf-radext-deprecating-radius, Section 6.3}}.\r\n\r\nThis specification defers to {{?I-D.ietf-radext-deprecating-radius}} for all discussion of crypto-agility in RADIUS.  In short, TLS satisfies the requirements of {{?I-D.ietf-radext-deprecating-radius}}, and there is no need to define RADIUS-specific cryptographic primitives.\r\n\r\n\r\n",
          "createdAt": "2024-09-06T20:24:16Z",
          "updatedAt": "2024-09-06T20:24:33Z"
        },
        {
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I like your suggestion much better",
          "createdAt": "2024-09-09T14:08:24Z",
          "updatedAt": "2024-09-09T14:08:24Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I also like the suggestion from Alan.\r\nI'd reference the deprecating radius draft as normative and have them published as cluster. (But that's editorial. The content looks good to me)",
          "createdAt": "2024-10-04T13:27:49Z",
          "updatedAt": "2024-10-04T13:27:49Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd prefer to publish the deprecating document first.  It's essentially done.  Given issues like the BlastRADIUS vulnerability, I think it's preferable to have an official RFC describing what to do.  Otherwise as we've seen, implementors may do \"inventive\" things.\r\n\r\nThe TLSbis document is likely to take a while to settle.",
          "createdAt": "2024-10-04T13:34:47Z",
          "updatedAt": "2024-10-04T13:34:47Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fine by me, in this case it's even easier to reference it as normative.",
          "createdAt": "2024-10-04T13:37:32Z",
          "updatedAt": "2024-10-04T13:37:32Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "see #20, further discussion over there.",
          "createdAt": "2025-05-14T18:41:46Z",
          "updatedAt": "2025-05-14T18:41:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOLrzygc5_XSYB",
      "title": "Update to RFC9525 Guidance",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/19",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've added this pull request as documentation for further discussions.\r\n\r\nThis is mainly the discussion from #4 with the things removed/added we discussed in the interim.",
      "createdAt": "2024-10-21T18:58:43Z",
      "updatedAt": "2025-07-17T12:13:07Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c458813a6d507981a69298ce6c3716b492b0aee0",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-rfc9525-guidance",
      "headRefOid": "5ef77e7823114e7d57b6bec750c006af3cce812e",
      "closedAt": "2024-10-21T19:04:57Z",
      "mergedAt": "2024-10-21T19:04:57Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "4f6bcde1ac3354dd4cc057e88d89a02297b6f962"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 20,
      "id": "PR_kwDOLrzygc6AuVgx",
      "title": "Add some text for agility",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/20",
      "state": "CLOSED",
      "author": "jimdigriz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Moved the text from draft-ietf-radext-deprecate-radius and rejig it to work here.\r\n\r\nAs draft-ietf-radext-deprecate-radius does not deliver the agility it-self on these points whilst draft-ietf-radext-radiusdtls-bis (and RFC6614 and RFC7360) do, the references I feel should belong here.\r\n\r\nAddresses https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/18",
      "createdAt": "2024-11-03T12:54:41Z",
      "updatedAt": "2025-06-01T10:24:18Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "6f6500732cf450eeee8d2363d4c5a986266f6173",
      "headRepository": null,
      "headRefName": "agility",
      "headRefOid": "5f2d1afb7c9e2b1beb1800a33ef9f5764d947251",
      "closedAt": "2025-06-01T10:24:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6pWMMF",
          "commit": {
            "abbreviatedOid": "5f2d1af"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T18:41:25Z",
          "updatedAt": "2025-05-14T18:41:26Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nCrypto-agility requirements for the RADIUS protocol were discussed extensively in {{?RFC6421}}. {{RFC6614, Appendix C}} described how those requirements were met for RADIUS/TLS and {{RFC7360, Section 10.1}} describes the same for RADIUS/DTLS. For clarity, the final outcome of the those discussions are repeated, using the text of {{RFC7360}} with some minor modifications to update references, without changing the content.\r\n```\r\n\r\nIt's not \"crypto-agility in general\" but \"crypto-agility for RADIUS\"\r\nWe should make that clear.",
              "createdAt": "2025-05-14T18:41:25Z",
              "updatedAt": "2025-05-14T18:41:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6pWO7r",
          "commit": {
            "abbreviatedOid": "5f2d1af"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T18:46:27Z",
          "updatedAt": "2025-05-14T18:46:27Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Perhaps add a ref to https://datatracker.ietf.org/doc/html/draft-ietf-radext-deprecating-radius-05, which discusses crypto agility",
              "createdAt": "2025-05-14T18:46:27Z",
              "updatedAt": "2025-05-14T18:46:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOLrzygc6LdgeP",
      "title": "Propose Loopback-Attack text",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/21",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Propose Loopback-Attack text and move to subsection of Proxy",
      "createdAt": "2025-02-17T13:27:37Z",
      "updatedAt": "2025-03-03T22:10:55Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "96e64c166fece6d27cf5dc6912990feedb9ded1d",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-security-loopback-attack",
      "headRefOid": "36937ce0849a0ea499f393da398936526926bed9",
      "closedAt": "2025-03-03T22:10:55Z",
      "mergedAt": "2025-03-03T22:10:55Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "d57d9a112ea3755738996987c40e6f92ec3b30c1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6c82uJ",
          "commit": {
            "abbreviatedOid": "9411b45"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T14:27:31Z",
          "updatedAt": "2025-02-21T14:34:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nRADIUS/(D)TLS nodes that are configured to act both as client and server, typically in a proxy configuration, may be vulnerable to attacks where an attacker mirrors back all traffic to the node.\r\nTherefore, nodes that are capable of acting as both client and server SHOULD implement mitigations to avoid accepting connections from itself.\r\nOne example of a potentially vulnerable configuration is a setup where the RADIUS/(D)TLS server is accepting incoming connections from any address (or a wide address range).\r\nSince the server may not be able to verify the certificate subject or subject alternate names, the trust is based on the certificate issuer or certificate OID.\r\nHowever, in this case, the client certificate which the RADIUS/(D)TLS node uses for outgoing connections on the client side might also satisfy the trust check of the server side.\r\nOther scenarios where the identification of an outgoing connection satisfies the trust check of an incoming one are possible, but are not enumerated here.\r\n```",
              "createdAt": "2025-02-21T14:27:31Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nEither through misconfiguration, erroneous or spoofed dynamic discovery, or an attacker rerouting TLS packets, a proxy might thus open a connection to itself, creating a loop.\r\nSuch attacks have been described for TLS-PSK [selfie], dubbed a selfie-attack, but are much broader in the Radius/(D)TLS case. In particular, as described above, they also apply to certificate based authentication.\r\n```\r\n\r\nThe link to `[selfie]` has not been provided. This should be included in the references.",
              "createdAt": "2025-02-21T14:29:41Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nImplementations SHOULD therefore detect connections from itself, and reject them.\r\nThere is currently no detection method that works universally for all use-cases and TLS implementations.\r\nSome possible detection methods are listed below:\r\n\r\n```\r\n\r\n(always add an empty line between text and item lists. the markdown parser does not recognize the itemized list as such otherwise.",
              "createdAt": "2025-02-21T14:30:55Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nThe application layer RADIUS protocol also offers some loop detection, e.g. using a Proxy-State attribute.\r\nHowever, these methods are not capable of reliably detecting and suppressing these attacks in every case and are outside the scope of this document. \r\n```",
              "createdAt": "2025-02-21T14:34:12Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6c_MrL",
          "commit": {
            "abbreviatedOid": "a1adfb9"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T17:43:53Z",
          "updatedAt": "2025-02-21T17:43:57Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nSuch attacks have been described for TLS-PSK {{?RFC9257}}, dubbed a selfie-attack, but are much broader in the RADIUS/(D)TLS case. In particular, as described above, they also apply to certificate based authentication.\r\n```",
              "createdAt": "2025-02-21T17:43:54Z",
              "updatedAt": "2025-02-21T17:43:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6c_OdK",
          "commit": {
            "abbreviatedOid": "a1adfb9"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T17:47:26Z",
          "updatedAt": "2025-02-21T17:47:27Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nHowever, these methods are not capable of reliably detecting and suppressing these attacks in every case and are outside the scope of this document.\r\n```\r\n\r\n(the automatic build complains about trailing whitespaces)",
              "createdAt": "2025-02-21T17:47:26Z",
              "updatedAt": "2025-02-21T17:47:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6eNjtg",
          "commit": {
            "abbreviatedOid": "a040d73"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-03T14:49:02Z",
          "updatedAt": "2025-03-03T15:00:40Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n- Comparing client or server random used in the TLS handshake. While this is a very effective method, it requires access to values which are normally private to the TLS implementation.\r\n```",
              "createdAt": "2025-03-03T14:49:02Z",
              "updatedAt": "2025-03-03T15:00:40Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n- Sending a custom random number in an extension in the TLS client hello. Again, this is verify effective, but requires extension of the TLS implementation.\r\n```",
              "createdAt": "2025-03-03T14:49:27Z",
              "updatedAt": "2025-03-03T15:00:40Z"
            },
            {
              "originalPosition": 22,
              "body": "I don't really understand what this means.\r\nThe scenario I had in mind here was the following (can be either from the client or the server side, I'll make an example for the client side):\r\n* Client connects\r\n* Server sends server certificate\r\n* Client checks if the server certificate is equal to any server certificate that it would send itself\r\n\r\nThere should be no mixing of client and server certificates, because a scenario where the same cert is used as client and server cert is possible, but not what we are trying to solve here.\r\nIt is perfectly fine to have two separate certificates (one client, one server) and with the text above, as I read it, this check would say \"everything's fine\" because the client cert does not match any configured server certs.\r\n\r\n```suggestion\r\n- Comparing the incoming server certificate to all server certificates configured on the proxy. While in some scenarios this can be a valid detection method, using the same server certificate on multiple servers would keep these servers from connecting with each other, even when this connection is legitimate.\r\n```",
              "createdAt": "2025-03-03T15:00:32Z",
              "updatedAt": "2025-03-03T22:07:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOLrzygc6MDSzT",
      "title": "Malformed packets apply to both TLS and DTLS",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/22",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Statement about malformed packets apply to both TLS and DTLS. Reword slighlty and move to section 4.",
      "createdAt": "2025-02-21T13:41:22Z",
      "updatedAt": "2025-02-21T14:53:34Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "96e64c166fece6d27cf5dc6912990feedb9ded1d",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-malformed-packets",
      "headRefOid": "3edeec56cca17142207fe6cd01846239496a20b8",
      "closedAt": "2025-02-21T14:53:34Z",
      "mergedAt": "2025-02-21T14:53:34Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "8801686b7f1a9805600e52c809228f11b1f8b0d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6c8nuq",
          "commit": {
            "abbreviatedOid": "cd7e338"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T14:05:36Z",
          "updatedAt": "2025-02-21T14:14:25Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nAs a result the behavior with respect to discarded packets has to change, since a malformed RADIUS packet could impact the decoding of succeeding packets.\r\n\r\nWith DTLS, the \"next\" packet does not depend on proper decoding of the previous packet, since the RADIUS packets are sent in independent DTLS records.\r\nHowever, since both TLS and DTLS provide integrity protection and ensure that the packet was sent by the peer, a protocol violation at this stage implies that the peer is misbehaving.\r\n```",
              "createdAt": "2025-02-21T14:05:36Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nImplementations of this specification SHOULD read the \"silently discard\" texts in the RADIUS specification referenced above as \"silently discard and close the connection\".\r\n```\r\n\r\nor\r\n\r\n```suggestion\r\nImplementations of this specification SHOULD treat the \"silently discard\" texts in the RADIUS specification referenced above as \"silently discard and close the connection\".\r\n```",
              "createdAt": "2025-02-21T14:07:33Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            },
            {
              "originalPosition": 13,
              "body": "(Error was the same in the previous version, but now I noticed it.)",
              "createdAt": "2025-02-21T14:08:03Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThat is, the implementation SHOULD send a TLS close notification and, in the case of RADIUS/TLS, the underlying TCP connection MUST be closed if any of the following circumstances are seen:\r\n```\r\n\r\nThe original text was specific for RADIUS/TLS, and RADIUS/DTLS does not have a \"connection\", and closing the UDP socket is an implementation detail.\r\nI don't have a strong opinion about it, but that's what just came to my mind.",
              "createdAt": "2025-02-21T14:13:11Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOLrzygc6MDrUs",
      "title": "update DTLS packet legnths",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/23",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "DTLS handles application data based on DTLS records, so length and padding statements should apply to those records and not the the whole packet.",
      "createdAt": "2025-02-21T14:26:12Z",
      "updatedAt": "2025-02-21T14:37:09Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "dc4229e4cfa2237b231a4261b6f127a28ac2d362",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-dtls-packet-length",
      "headRefOid": "91ad0c7b53bded178b0c81507e9d2bae114c2eea",
      "closedAt": "2025-02-21T14:37:09Z",
      "mergedAt": "2025-02-21T14:37:09Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "e165b488000948c597a70e86b986fd3b93ff1b49"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOLrzygc6NzWfs",
      "title": "Suggestion for text for post-handshake auth",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/25",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Text as per Heikki's comments on the radext ML",
      "createdAt": "2025-03-07T16:52:02Z",
      "updatedAt": "2025-07-17T12:12:59Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_handshake_authentication",
      "headRefOid": "959bc0e0019125c693ef1707652037b17a1def57",
      "closedAt": "2025-05-26T11:49:46Z",
      "mergedAt": "2025-05-26T11:49:46Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "787bd2fdf7a6ec74d9983a73c7cc4eece0bb770f"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this looks fine.",
          "createdAt": "2025-04-16T11:48:07Z",
          "updatedAt": "2025-04-16T11:48:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 30,
      "id": "PR_kwDOLrzygc6V1mU-",
      "title": "Update text for Path MTU",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/30",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a suggestion for different wording on Path MTU. (See #27 for some discussion)\r\n\r\nThis change probably should go to the list of changes, since in RFC 7360, PMTU was `SHOULD`, I changed it out to `MAY`\r\n\r\nSuggestions/comments/... welcome.",
      "createdAt": "2025-05-12T13:18:46Z",
      "updatedAt": "2025-07-17T12:13:04Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_path_mtu_discovery",
      "headRefOid": "098deeafd64792b58f84ab4f5376a04bf0c5ed75",
      "closedAt": "2025-05-26T11:48:18Z",
      "mergedAt": "2025-05-26T11:48:18Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "e4796194f788be6d7ab7c336f6cbec697f10948d"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me.",
          "createdAt": "2025-05-12T13:37:06Z",
          "updatedAt": "2025-05-12T13:37:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 31,
      "id": "PR_kwDOLrzygc6V2Te6",
      "title": "Text suggestion for TLS Record count limitation",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/31",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "see #28 for discussion\r\n\r\nfeedback/improvements/... welcome",
      "createdAt": "2025-05-12T14:21:44Z",
      "updatedAt": "2025-07-17T12:13:05Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_tls_record_count_limit",
      "headRefOid": "e064fb7de19ebb6205ade741ff97260b44be0243",
      "closedAt": "2025-05-27T08:57:49Z",
      "mergedAt": "2025-05-27T08:57:49Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "b7c70027805779e0f53267e644072047a5989319"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6o4wSp",
          "commit": {
            "abbreviatedOid": "0f9aebf"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:27:24Z",
          "updatedAt": "2025-05-12T14:27:24Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Perhaps explain when they're rotated?\r\n\r\n```\r\n... the encryption keys have to be rotated regularly, depending on both the amount of data which was transferred, and on the encryption method.  See {{RFC8446, Section 5.5}} for more information.\r\n```",
              "createdAt": "2025-05-12T14:27:24Z",
              "updatedAt": "2025-05-12T14:27:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6o5NNZ",
          "commit": {
            "abbreviatedOid": "0f9aebf"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T15:00:37Z",
          "updatedAt": "2025-05-12T15:00:37Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Sounds good. I've also added the reference to the CFRG draft on AEAD limits",
              "createdAt": "2025-05-12T15:00:37Z",
              "updatedAt": "2025-05-12T15:00:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOLrzygc6V2eUm",
      "title": "Reword the DTLS padding handling on the receiving end",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/32",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As suggested by Alexander Clouter @jimdigriz in #24 \r\n\r\nI have changed the wording a bit, not exactly as suggested, hopefully still making it a bit less ambiguous.\r\n\r\nSuggestions/Improvements/Comments/... welcome.",
      "createdAt": "2025-05-12T14:37:47Z",
      "updatedAt": "2025-07-17T12:13:06Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_dtls_record_padding",
      "headRefOid": "bf7368e72618f74094a4405acbbeabfb28cd9f77",
      "closedAt": "2025-05-26T11:49:11Z",
      "mergedAt": "2025-05-26T11:49:11Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "4b8a40d4033b624022e6468825a1ebc3b1e37559"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "PR_kwDOLrzygc6V-9FG",
      "title": "Alternative wording for session closure.",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/33",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Originally proposed text from #6, with the changes suggested by Alan. Slight changes in the text.\r\n\r\nOne discussion item: Should for RADIUS proxies\r\nAccounting-Request/CoA-Request/Disconnect-Requests  still be processed on the outgoing layer and retransmitted?\r\n\r\nFor the RADIUS server we say that the server may process these packets, and just discard the answer.\r\nMaybe the same should be done for RADIUS proxies. On the other hand, if we discard the answer anyway, retransmitting may also be pointless.",
      "createdAt": "2025-05-13T11:28:17Z",
      "updatedAt": "2025-07-07T14:21:09Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_response_cache",
      "headRefOid": "799f5014c136ed6f8ac35296b6a4a29984a5a676",
      "closedAt": "2025-07-07T14:20:56Z",
      "mergedAt": "2025-07-07T14:20:56Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "a0d726694003ea9acefa93f1dea73aec6d6be13b"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would say that on closing a session, all packets which were sent on that session (without a response) should be treated as if they had just been received from the client.  The packets should be re-processed through the forwarding path.",
          "createdAt": "2025-05-13T14:44:55Z",
          "updatedAt": "2025-05-13T14:44:55Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "For the \"client\" side of the broken connection. yes.\r\nThe question is for the \"server\" side of the broken connection. should they retransmit on their uplink or just delete the packet and trust that the client will try a different path for the outstanding packet?",
          "createdAt": "2025-05-13T14:59:26Z",
          "updatedAt": "2025-05-13T14:59:26Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For a client which sees a broken \"outbound\" connection, it can retransmit the packet on another connection.  This applies to proxies, too.\r\n\r\nFor a server which sees a broken \"inbound\" connection, it should just discard the request.  There is no globally unique packet ID, so the server has no way of detecting the \"same\" packet which is retransmitted from the client over a different inbound link.  So no matter what the server does, it can't send any reply to the client.\r\n\r\nTherefore, the only thing that the server can do is to discard the request.",
          "createdAt": "2025-05-13T15:05:18Z",
          "updatedAt": "2025-05-13T15:05:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOLrzygc6WNHNF",
      "title": "Move text for session resumption and clarify",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/34",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Text taken from #7 with some minor changes:\r\n\r\nInstead of generally referencing RFC5077, it is now referenced specifically for servers, since servers issue the tickets. The client must still cache all relevant data.",
      "createdAt": "2025-05-14T18:07:31Z",
      "updatedAt": "2025-07-17T12:12:58Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_session_resumption",
      "headRefOid": "b7cde9b15aaf2223316aa6bccc56ac101dc65ee3",
      "closedAt": "2025-07-07T16:30:23Z",
      "mergedAt": "2025-07-07T16:30:23Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "5911967dd58d4f919aa14719e37f22ead7864946"
      },
      "comments": [
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm personally no longer convinced that session resumption SHOULD be implemented - given that connections tend to be long running anyway and the complexity it infers. Of course, it MAY be implemented.\r\n\r\nBut I'm not going to argue about that detail. The important thing is what to do **if** it is implemented, which is fine with me.\r\n\ud83d\udc4d ",
          "createdAt": "2025-05-23T15:21:48Z",
          "updatedAt": "2025-05-23T15:22:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @fmauchle , that's a good comment.\r\n\r\nMaybe we can do it similar to the \"RADIUS/TLS or RADIUS/DTLS\"\r\n\r\nMy suggestion would then be:\r\nRADIUS/(D)TLS clients MAY implement session resumption.\r\nRADIUS/(D)TLS servers SHOULD implement session resumption.\r\n\r\nThe need for session resumption highly depends on whether or not the sessions are re-opened on a regular basis or if they are long-standing.\r\nI would assume that in most cases, the RADIUS/(D)TLS client will decide on whether or not to close the connection, and in this case clients that leave the connection open for a long time would not have the need to implement session resumption.\r\nFor the server, implementing session resumption is helpful when dealing with clients that re-connect often.\r\n\r\nBut I would not be opposed to make this a MAY altogether.",
          "createdAt": "2025-05-26T08:29:35Z",
          "updatedAt": "2025-05-26T08:29:35Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On May 26, 2025, at 4:29\u202fAM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> My suggestion would then be:\r\n> RADIUS/(D)TLS clients MAY implement session resumption.\r\n> RADIUS/(D)TLS servers SHOULD implement session resumption.\r\n\r\n  If we're not doing to use \"MUST\", then I would lean towards \"SHOULD\" for both client and server.\r\n\r\n> The need for session resumption highly depends on whether or not the sessions are re-opened on a regular basis or if they are long-standing.\r\n> I would assume that in most cases, the RADIUS/(D)TLS client will decide on whether or not to close the connection, and in this case clients that leave the connection open for a long time would not have the need to implement session resumption.\r\n\r\n  The overhead of doing a full re-authentication is tiny, compared to a long-lived connection.\r\n\r\n  That being said, I don't see any reason to _not_ implement session resumption.  Most RADIUS servers which do EAP (i.e. all of the major ones) already do session resumption for TLS-based EAP methods.  Doing session resumption for RADIUS/TLS is a tiny cost.\r\n\r\n  I don't have strong reasons for requiring session resumption.  I can't think of cases where it would make a significant difference.  In contrast, doing session resumption for TLS-based EAP methods has a noticeable effect on authentication latency.\r\n\r\n",
          "createdAt": "2025-05-26T10:54:20Z",
          "updatedAt": "2025-05-26T10:54:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDOLrzygc6WNRJm",
      "title": "Add text for default trust anchors",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/35",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Rewording from #15, see discussion there.\r\n\r\nI have left out the reasoning for this, since it does not fit in the normative text, if needed, we can add a subsection in the security considerations.",
      "createdAt": "2025-05-14T18:28:40Z",
      "updatedAt": "2025-07-17T12:12:56Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_trust_anchor",
      "headRefOid": "fefc43cbe17c8d170fb9a3fef4fd329a0f5b4ba3",
      "closedAt": "2025-05-26T11:43:28Z",
      "mergedAt": "2025-05-26T11:43:28Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "fe5f8a0fef3bb2168576f67085c7f95aeb115822"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6rHrIp",
          "commit": {
            "abbreviatedOid": "fefc43c"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T12:40:19Z",
          "updatedAt": "2025-05-27T12:40:20Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Typo \"preclude\" and \"configured\"",
              "createdAt": "2025-05-27T12:40:20Z",
              "updatedAt": "2025-05-27T12:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6rHvmS",
          "commit": {
            "abbreviatedOid": "fefc43c"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T12:46:12Z",
          "updatedAt": "2025-05-27T12:46:12Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "fixed in commit 52122b4\r\nThanks.",
              "createdAt": "2025-05-27T12:46:12Z",
              "updatedAt": "2025-05-27T12:46:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 38,
      "id": "PR_kwDOLrzygc6fK-UI",
      "title": "clarify practical use of PKIX client identity",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/38",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarify the technicality of PKIX identity versus its practical use of subject or subjectAltName, to address #26.",
      "createdAt": "2025-07-16T11:59:08Z",
      "updatedAt": "2025-07-17T08:26:19Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "5911967dd58d4f919aa14719e37f22ead7864946",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "pkix-client-identity",
      "headRefOid": "2c0bbed81c083199c4d50584c55ce1e8ce62b5cb",
      "closedAt": "2025-07-17T08:26:19Z",
      "mergedAt": "2025-07-17T08:26:19Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "83f68e29cbe83e29253721b989e26079fc533f91"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc60gRxG",
          "commit": {
            "abbreviatedOid": "611f89d"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T07:56:03Z",
          "updatedAt": "2025-07-17T07:56:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The general issue of \"what do I use to apply policies\" is not unique to TLS-X.509-PKIX, so I would suggest putting it in a separate paragraph.\r\nI've reworded it slightly. (and removed the whitespace at the end of the line, so kdrfc doesn't complain)\r\n\r\n```suggestion\r\nWith TLS-X.509-PKIX, a client is uniquely identified by the tuple of the serial number of the presented client certificate and the issuer.\r\n\r\nIn practice, identification of unique clients is not always necessary and could be based on the subject of the presented certificate or a subjectAltName entry.\r\nWhile this identification technique could match multiple distinct certificates and therefore distinct clients, it is often sufficient, e.g. for the purpose of applying policies.\r\n```",
              "createdAt": "2025-07-17T07:56:03Z",
              "updatedAt": "2025-07-17T07:56:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "PR_kwDOLrzygc6fLGhw",
      "title": "Forbid CN only for servers",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/39",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think this proposal was lost among the lenghy discussion on the mailing list:\r\n\r\nRFC9525 mainly applies to identify servers, but not clients. Specifically the provision that Common Name MUST NOT be used to identify a server doesn't really apply to clients. To the contrary it seems to be perfectly reasonable to identfy a client based on its Common Name.\r\n\r\nProposal: move the Common Name provision to the details of server identity validation perfomred by clients.",
      "createdAt": "2025-07-16T12:12:43Z",
      "updatedAt": "2025-07-20T11:46:15Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "9d0f45f9b88ed231cf51b18424ca851330aa9f0f",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "forbid-cn-server-only",
      "headRefOid": "f1671665cb1afeca0dcd9fef7701e84af39e1405",
      "closedAt": "2025-07-20T11:46:15Z",
      "mergedAt": "2025-07-20T11:46:15Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "daa3c02c7f3ba9304be937a8966ca156a7302109"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would argue differently.\r\nThe problem with the CN RDN, as far as I understand, is that it is not typed. This can be a problem for both client and server.\r\n\r\nIf we want to identify a client based on a domain name, then we should not use the CN, but SAN:DNS. If it's an IP address, SAN:IP.\r\nOnly if we want to identify a client based on an arbitrary string with custom format (e.g. a customer number stored in CN) and within a private CA it is ok to use the CN.\r\n\r\nThe reasoning for this approach:\r\nIf we use identifiers with well-defined format, (such as IP addresses or DNS names), we should use the well-defined certificate fields, and we can use the same validation routines for client and server certificate validation.\r\nOnly if explicitly configured the validation should use the CN.\r\n\r\nTheoretically we could also allow CN for such identifiers for server certificates, I'm not sure whether this is needed (and this would be in direct violation of RFC9525)\r\n\r\nThe draft currently states:\r\n> Implementations MAY allow configuration of a set of additional properties of the certificate to check for a peer's authorization to communicate\r\n\r\nEven if it contradicts the \"MUST NOT use CN\", it could be possible to configure a CN check via this route.",
          "createdAt": "2025-07-17T07:48:28Z",
          "updatedAt": "2025-07-17T07:48:28Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The draft still requires the use of subjectAltNames for client certificates, **IF** its DNS name or IP address is known.\r\n\r\nHowever, for clients this is more often not the case (in contrast to servers), so strictly forbidding the use of CN might be overkill (CN should still not be used to match a DNS name)",
          "createdAt": "2025-07-17T08:21:30Z",
          "updatedAt": "2025-07-17T08:21:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 41,
      "id": "PR_kwDOLrzygc6fXjpD",
      "title": "Add explicit text explaining how to send RADIUS pkt via TLS",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/41",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When looking over the document, I noticed that at no point we had an explicit specification that RADIUS packets are to be concatenated, without padding, and so on.\r\nThis fixes this, and it does nothing else than document explicitly what is inferred at many points in the document already.\r\n(Theoretically, it is implied at many points in this document, that this is the case, but it's always better to have it explicitly in there)\r\n\r\nMaybe this is worth adding in the \"list of changes\", maybe not, I'm open for suggestions on this.",
      "createdAt": "2025-07-17T12:09:38Z",
      "updatedAt": "2025-07-22T18:42:10Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "9d0f45f9b88ed231cf51b18424ca851330aa9f0f",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_explicit_tls_transmission",
      "headRefOid": "e2b4146b4194c2bea68f548a6fd0a025327ec229",
      "closedAt": "2025-07-20T11:43:37Z",
      "mergedAt": "2025-07-20T11:43:37Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "10ada7cdbb12f2401971c16ddfa8ac38ac1d803f"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Minor comments, but I think this is a good addition.",
          "createdAt": "2025-07-17T13:08:08Z",
          "updatedAt": "2025-07-17T13:08:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc60kd-C",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T13:05:11Z",
          "updatedAt": "2025-07-17T13:05:11Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "\"RADIUS\"",
              "createdAt": "2025-07-17T13:05:11Z",
              "updatedAt": "2025-07-17T13:05:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc60kfmW",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T13:06:56Z",
          "updatedAt": "2025-07-17T13:06:56Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I don't think this is true?  Even RADIUS/UDP depended on the Length field.  RFC 2865 says:\r\n\r\n```\r\n      Octets outside the range of the Length field\r\n      MUST be treated as padding and ignored on reception.\r\n```\r\n\r\nSo the length of the packet is explicit, not implicit.\r\n\r\nPerhaps just delete this sentence.  ",
              "createdAt": "2025-07-17T13:06:56Z",
              "updatedAt": "2025-07-17T13:06:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc60kfzx",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T13:07:10Z",
          "updatedAt": "2025-07-17T13:07:10Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Perhaps `Length` field?",
              "createdAt": "2025-07-17T13:07:10Z",
              "updatedAt": "2025-07-17T13:07:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc60nVq7",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T16:19:40Z",
          "updatedAt": "2025-07-17T16:19:41Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "fixed. *sigh*",
              "createdAt": "2025-07-17T16:19:40Z",
              "updatedAt": "2025-07-17T16:19:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc60nV34",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T16:19:58Z",
          "updatedAt": "2025-07-17T16:19:58Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I've reworded it to be more clear what I mean. I hope it's fixed with that.",
              "createdAt": "2025-07-17T16:19:58Z",
              "updatedAt": "2025-07-17T16:19:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc60nXFd",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T16:21:43Z",
          "updatedAt": "2025-07-17T16:21:43Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I've changed it to code environment, and changed the other instances of this too.",
              "createdAt": "2025-07-17T16:21:43Z",
              "updatedAt": "2025-07-17T16:21:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOLrzygc6frVQ1",
      "title": "Convert 4-tuple to 5-tuple",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/43",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Generally, any session tracking is described with a 5-tuple, that also includes the protocol.\r\n\r\nTo be consistent with other specs, literature, ... we could just modify this and just statically set protocol to `UDP`\r\n\r\n(Thanks Fabian for the suggestion)",
      "createdAt": "2025-07-19T10:02:36Z",
      "updatedAt": "2025-07-22T18:42:14Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "9d0f45f9b88ed231cf51b18424ca851330aa9f0f",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_5tuple",
      "headRefOid": "bd326bf2fe3f281f0952fa0b6b28429d444a0c4a",
      "closedAt": "2025-07-20T11:42:12Z",
      "mergedAt": "2025-07-20T11:42:12Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "5250ccc41d17a566cfffda1b0cfe6851c0117f66"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 44,
      "id": "PR_kwDOLrzygc6gH58N",
      "title": "Fix typo in draft",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/44",
      "state": "MERGED",
      "author": "chrohrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "WGLC Comment"
      ],
      "body": "",
      "createdAt": "2025-07-22T18:16:55Z",
      "updatedAt": "2025-07-22T18:55:37Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "17514bba596a8c0997beac5a9e022a2bfdeaf406",
      "headRepository": "chrohrer/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "conctrast-typo",
      "headRefOid": "2816812dcca224142f176e8032c0ecd3d4795ece",
      "closedAt": "2025-07-22T18:55:37Z",
      "mergedAt": "2025-07-22T18:55:37Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "2fcc1a6a8c460262f7e7975f8f7906cdd01cadb6"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2025-07-22T18:55:32Z",
          "updatedAt": "2025-07-22T18:55:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 45,
      "id": "PR_kwDOLrzygc6gIDn1",
      "title": "Update draft-ietf-radext-radiusdtls-bis.md",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/45",
      "state": "MERGED",
      "author": "chrohrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "WGLC Comment"
      ],
      "body": "Remove reference to RADIUS/DTLS in RADIUS/TLS specific section",
      "createdAt": "2025-07-22T18:34:44Z",
      "updatedAt": "2025-07-22T18:59:13Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "17514bba596a8c0997beac5a9e022a2bfdeaf406",
      "headRepository": "chrohrer/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "remove-dtls-reference-in-tls-section",
      "headRefOid": "983f5c445a01a5b471d89bb1f5a1bb7769076730",
      "closedAt": "2025-07-22T18:59:13Z",
      "mergedAt": "2025-07-22T18:59:12Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "327a20e780522389338370d2f4905a6f5eec780c"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Ooops. good catch. Thank you.",
          "createdAt": "2025-07-22T18:59:00Z",
          "updatedAt": "2025-07-22T18:59:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 47,
      "id": "PR_kwDOLrzygc6gqoK5",
      "title": "be explicit about client source IP",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/47",
      "state": "CLOSED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs discussion",
        "WGLC Comment"
      ],
      "body": "When validating client certificates, the fact that the client may only connect from IP addresses to which a given DNS name resolves to (or the actual source addres when multiple IPs or IP prefix is configured) is only implied. Maybe better to state it explicitly.",
      "createdAt": "2025-07-25T17:12:34Z",
      "updatedAt": "2025-09-19T12:40:18Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "0bdcd9908d3ab5f231d631449fd42e481defd87d",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-explicit-client-source-ip",
      "headRefOid": "15eaff5b7344d078962f69c6a453215da598ad3e",
      "closedAt": "2025-09-19T12:40:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think that this should be mandated. It opens up a whole can of worms.\r\n* At which time is the lookup done?\r\n* What happens if the DNS changes?\r\n* How should the implementation behave if there is no DNS entry?\r\n\r\nI know that radsecproxy does this a certain way, other implementations might do it differently.\r\n\r\nWe could add a sentence with a word of warning that this should be considered, but I wouldn't mandate a special behavior.",
          "createdAt": "2025-07-28T13:59:14Z",
          "updatedAt": "2025-07-28T13:59:14Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's a balance between allowing people to do anything, and giving them guidance which is too specific. \r\n\r\nIt may be worth mentioning the issue, and giving options as to what can be done.\r\n\r\nMy concern (as always) is that if the spec is silent on a topic, people have no idea what to do, and therefore do something problematic.",
          "createdAt": "2025-07-28T14:34:12Z",
          "updatedAt": "2025-07-28T14:34:12Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think that this should be mandated. It opens up a whole can of worms.\r\n\r\nWe alerady mandate it for IP prefix, so I think it would only be consostent to the same for DNS names. This describes the default certificate validation, similar to whate we do to server certificates. And we already allow this check to be omitted, if the situation doesn't provide a fixed DNS name or IP address.\r\n\r\n> * At which time is the lookup done?\r\n> * What happens if the DNS changes?\r\n\r\nThis is implementation specific, and the same issue exists for clients resolving servers in the DNS. To be technically correct, repeating the lookup should be done latest when the DNS TTL expires (i.e. the DNS cache lifetime).\r\n\r\n> * How should the implementation behave if there is no DNS entry?\r\n\r\nThis paragraph describes explicitly the situation when a DNS entry exists. If it doesn't (but the client is configured by DNS name, it's simply an unknown client).\r\n\r\n> I know that radsecproxy does this a certain way, other implementations might do it differently.\r\n\r\nThat is exactly the point. While updating client cert validation to the current draft, I noticed it might accept a certificate (with SAN DNS) from a client, whose source address is not what that DNS name resolves to - and I think that is the wrong behavior. ",
          "createdAt": "2025-08-04T12:07:33Z",
          "updatedAt": "2025-08-04T12:07:55Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I get the point, I am convinced. Now the question is: should there be more explicit text for how and when to resolve DNS names to IP addresses on the server side?\r\n\r\nRight now the suggested change does not have any text explaining when and why to do this, and I think there should be at least some explanation and guidance.",
          "createdAt": "2025-08-15T12:26:46Z",
          "updatedAt": "2025-08-15T12:26:46Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the main issue with DNS queries is that the POSIX API doesn't return TTL.  So applications are pretty much stuck.\r\n\r\nFor new connections:\r\n\r\n* do lookups when the server needs to connect to a new server (first time it does lookup, or when it transitions from no connections to 1+ connection to the server)\r\n\r\nThen for ongoing connections:\r\n\r\n* do DNS lookups when DNS TTL expires (this is hard, as the POSIX APIs don't return TTL)\r\n* do DNS lookups any time any new connection is opened\r\n* do DNS lookups periodically, say every hour or two\r\n\r\nThere's also the issue of when to close connections.  If a server wishes to change all of the IPs associated with itself, it should first spin up servers at the new IPs, then update DNS, then shut down connections to the old IPs.\r\n\r\ni.e. if a connection remains open and active, there's no reason for the client to close the connection just because DNS changes.",
          "createdAt": "2025-08-15T14:30:53Z",
          "updatedAt": "2025-08-15T14:30:53Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, in theory you would have to do a lookup every time you need the IP address (i.e. for every new connection, outgoing and incoming), everything else is just caching. Hoever in practice, this caching is rather important especially for incoming connections. (I think stating the fact that you have to do a lookup in the first place is useless)\r\n\r\nAs Alan stated, at least the POSIX API doesn't provide caching hints (TTL), and I have no clue what would happen if you query that API for the same name repeatedly - would it do the caching? (I don't think so).\r\n\r\nWe may add a statement that servers \"SHOULD NOT cache longer than the DNS responses TTL\" (and referencd STD13 for its definition), being fully aware that most implementations won't follow that advise by the letter.",
          "createdAt": "2025-08-21T05:40:52Z",
          "updatedAt": "2025-08-21T05:40:52Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> As Alan stated, at least the POSIX API doesn't provide caching hints (TTL), and I have no clue what would happen if you query that API for the same name repeatedly - would it do the caching? (I don't think so).\r\n\r\nThe local C library should cache the results of the DNS query, for at least the TTL.  Perhaps this means that we should recommend clients do a DNS lookup every time they need to open a new connection.",
          "createdAt": "2025-08-21T14:27:10Z",
          "updatedAt": "2025-08-21T14:27:10Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "> Perhaps this means that we should recommend clients do a DNS lookup every time they need to open a new connection.\r\n\r\nThe problem is not the client, there the process of DNS lookup is quite easy.\r\nThe problem is the server, if clients are only configured by DNS name and not by IP address.\r\nShould the server look up every DNS-configured client the moment it gets a new connection to find out which one it is?\r\nWhat happens if there are multiple clients defined with a DNS name that resolves to the same IP address?\r\n\r\nI think it is ok to state that configuring a client by DNS only is only a convenience to put a human-readable name in the configuration instead of an IP address, and that the server should do a lookup at startup and then maybe periodically.",
          "createdAt": "2025-08-21T23:23:39Z",
          "updatedAt": "2025-08-21T23:23:39Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The problem is the server, if clients are only configured by DNS name and not by IP address.\r\n> Should the server look up every DNS-configured client the moment it gets a new connection to find out which one it is?\r\n\r\nIn theory yes. In practice its unrealistic, so implementors have to do some caching, or rely on the underlying library/OS to do the caching. A quick test on Debian (libc) it does no caching at all, every call to getaddrino() triggers multiple DNS queries (for A and AAAA records)\r\n\r\n> What happens if there are multiple clients defined with a DNS name that resolves to the same IP address?\r\n\r\nYou select the one for which its certificates SAN DNS matches the configured DNS name. \r\n",
          "createdAt": "2025-08-22T10:05:00Z",
          "updatedAt": "2025-08-22T10:05:00Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With rough consensus on the mailing list, this is not the right approach. Closing this PR.",
          "createdAt": "2025-09-19T12:40:18Z",
          "updatedAt": "2025-09-19T12:40:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 48,
      "id": "PR_kwDOLrzygc6j2R1R",
      "title": "Recommend closing connection upon certificate expiry",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/48",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Text suggestion for #46 ",
      "createdAt": "2025-08-15T14:33:56Z",
      "updatedAt": "2025-09-19T09:58:47Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "327a20e780522389338370d2f4905a6f5eec780c",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_cert_lifetime",
      "headRefOid": "d98f7caccad67d31b20a98bdc6c26c593338268c",
      "closedAt": "2025-09-11T09:42:31Z",
      "mergedAt": "2025-09-11T09:42:31Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "83c6ec7177f4c1d3268b92fe5245172566b620da"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 49,
      "id": "PR_kwDOLrzygc6j5ytL",
      "title": "Add text for RADIUS/DTLS retransmission behavior",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/49",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a first text suggestion for #42 ",
      "createdAt": "2025-08-15T22:28:00Z",
      "updatedAt": "2025-09-19T09:58:50Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "327a20e780522389338370d2f4905a6f5eec780c",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_dtls_retransmissions",
      "headRefOid": "94c02342fe7a080777ec475ef210c46fa621e23e",
      "closedAt": "2025-08-21T23:24:13Z",
      "mergedAt": "2025-08-21T23:24:13Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "f90b8f249cc7450eb7c85c78d827d6c48efc8f34"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1",
          "createdAt": "2025-08-21T14:28:51Z",
          "updatedAt": "2025-08-21T14:28:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDOLrzygc6knqRn",
      "title": "Silent discard vs Protocol-Error",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/50",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "WGLC Comment"
      ],
      "body": "Changes to section 4.5 require sending Protocol-Error instead of silently discrading packets. Apply the same provision to section 4.10.",
      "createdAt": "2025-08-21T06:26:26Z",
      "updatedAt": "2025-09-19T09:50:16Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "327a20e780522389338370d2f4905a6f5eec780c",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-silentd-discard-vs-protocol-error",
      "headRefOid": "42bf09bb17eabe85a4f232e75b7362ec00b8da06",
      "closedAt": "2025-09-19T09:50:16Z",
      "mergedAt": "2025-09-19T09:50:16Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "1c9ef6bee61473d936bb28bf23f3c6b28fcb2c74"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me.",
          "createdAt": "2025-08-21T14:27:54Z",
          "updatedAt": "2025-08-21T14:27:54Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me, but maybe we should add a recommendation on the Error-Cause attribute?",
          "createdAt": "2025-09-10T14:01:20Z",
          "updatedAt": "2025-09-10T14:01:20Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@janfred yes, adding Error-Cause would be good, too",
          "createdAt": "2025-09-10T15:37:09Z",
          "updatedAt": "2025-09-10T15:37:09Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me",
          "createdAt": "2025-09-11T10:28:57Z",
          "updatedAt": "2025-09-11T10:28:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6_WX3L",
          "commit": {
            "abbreviatedOid": "0c4b2b8"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-11T09:46:53Z",
          "updatedAt": "2025-09-11T09:47:51Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nFor request packets that would have been silently discarded in the previous specifications, servers SHOULD reply with a Protocol-Error {{!RFC7930, Section 4}} message to avoid request ID exhaustion, and servers SHOULD include an Error-Cause attribute indicating the type of failure. In any case, further processing of the original request MUST stop.\r\n```",
              "createdAt": "2025-09-11T09:46:54Z",
              "updatedAt": "2025-09-11T09:47:51Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n* Packet with an invalid code field (see {{radius_datagrams}} for details)\r\n```",
              "createdAt": "2025-09-11T09:47:19Z",
              "updatedAt": "2025-09-11T09:47:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDOLrzygc6pepg-",
      "title": "Add client source IP for clients configured by DNS",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/53",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs discussion",
        "WGLC Comment"
      ],
      "body": "This is an alternate text for #47 which does not mandate any behavior and instead just mentions this as option.\r\n\r\nIt does not contain any hints on what implementations / operators should do because I don't think we can say anything definitive about this.",
      "createdAt": "2025-09-19T10:35:09Z",
      "updatedAt": "2025-09-30T17:57:12Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "0bdcd9908d3ab5f231d631449fd42e481defd87d",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature/hint_dns_client_ip",
      "headRefOid": "b122b7b2ca15a07f0346528c5f17a3af3ec90dc9",
      "closedAt": "2025-09-25T11:33:33Z",
      "mergedAt": "2025-09-25T11:33:33Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "95d8e84137041e676db88f0896fc73f52d7ab458"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOLrzygc6qfTw7",
      "title": "Additional text as hint that TCP also changes transmission times",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/54",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per comments on the mailing list, maybe this is something that people implementing RADIUS/TLS should keep in mind. The most prominent case is Event-Timestamp vs. Acct-Delay-Time, but maybe it's also relevant for other cases.",
      "createdAt": "2025-09-25T11:44:15Z",
      "updatedAt": "2025-09-30T17:57:08Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "95d8e84137041e676db88f0896fc73f52d7ab458",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature/hint_transmission_time",
      "headRefOid": "b5b75e37c4c01ee870c48abed4970b61a1b66857",
      "closedAt": "2025-09-30T17:55:19Z",
      "mergedAt": "2025-09-30T17:55:19Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "a0450adbf505a092f2a8511a5272b224255f3530"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Additonally, this can lead to a significantly increased transmission time, especially compared to RADIUS/UDP, where a RADIUS packet either arrives only with the negligible transport delay or it is lost and needs to be retransmitted.\r\n\r\nThis isn't clear to me that TCP delays can be seconds.  Perhaps\r\n\r\nAdditonally, TCP retransmissions can occur seconds after the original data was sent, leading to a significantly increased transmission time, especially compared to RADIUS/UDP.  In contrast, RADIUS/UDP packets are usually received either quickly, or not at all.",
          "createdAt": "2025-09-25T15:19:04Z",
          "updatedAt": "2025-09-25T15:19:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7DzwqK",
          "commit": {
            "abbreviatedOid": "36ff710"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-30T14:12:29Z",
          "updatedAt": "2025-09-30T14:12:30Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nAdditionally, due to the architecture of TCP as reliable stream transport, TCP retransmissions can occur significantly later, even multiple seconds, after the original data was passed to the network stack by the application.\r\nIn contrast, RADIUS/UDP packets are usually received either quickly, or not at all, in which case the RADIUS/UDP stack triggers a retransmission of the packet on the application layer.\r\n```",
              "createdAt": "2025-09-30T14:12:29Z",
              "updatedAt": "2025-09-30T14:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7DzyHq",
          "commit": {
            "abbreviatedOid": "36ff710"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-30T14:13:18Z",
          "updatedAt": "2025-09-30T14:13:18Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "@alandekok I've reworded your suggestion a bit, I hope it captures what we want to say.",
              "createdAt": "2025-09-30T14:13:18Z",
              "updatedAt": "2025-09-30T14:13:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7D2Wv-",
          "commit": {
            "abbreviatedOid": "36ff710"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-30T16:22:36Z",
          "updatedAt": "2025-09-30T16:22:36Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "+1 from me",
              "createdAt": "2025-09-30T16:22:36Z",
              "updatedAt": "2025-09-30T16:22:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOLrzygc6qfge6",
      "title": "Add examples of allowed packet types",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/55",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Maybe this is a good example of what we want to say with the sentence before. It's always good to give examples.\r\n\r\nMaybe sufficient to fix #51 ?",
      "createdAt": "2025-09-25T12:02:08Z",
      "updatedAt": "2025-09-30T17:57:11Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "95d8e84137041e676db88f0896fc73f52d7ab458",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature/example_packet_types",
      "headRefOid": "d2d0b4cdc9295a49d6adfba33f84b9177911153c",
      "closedAt": "2025-09-30T14:05:55Z",
      "mergedAt": "2025-09-30T14:05:55Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "4db3d23c05a9fc1e3a1efc4e5fcf8bb186b4734f"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me.",
          "createdAt": "2025-09-25T15:19:23Z",
          "updatedAt": "2025-09-25T15:19:23Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDOLrzygc6sTZhs",
      "title": "Suggestions from 2025-10-03 radext emails",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/56",
      "state": "CLOSED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "These commits contain suggestions from my emails to radext on 2025-10-03. Most of them are clarifications. Main proposed changes are:\r\n* remove all TLS renegotiations 3e474a3c3b4aedd70e838d07d2815455380e7604\r\n* stop sending when Error-Cause is 406 'Unsupported Extension' 5916c67d5752b6cf3f32cb4195ed6776f6903e50\r\n\r\nCommit 738ab370157f6ec29ec04250ccc7b5bae4b08dc9 also attempts to clarify RFC 6614 response types replaced with Protocol-Error response. My understanding is that the RFC 6614 behaviour is replaced, but please check 738ab370157f6ec29ec04250ccc7b5bae4b08dc9",
      "createdAt": "2025-10-06T15:32:51Z",
      "updatedAt": "2025-10-23T08:09:33Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "hvn-oct-1",
      "headRefOid": "24bb5e1f68eb787b40c74187133b00df4e0180d6",
      "closedAt": "2025-10-23T08:09:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "In general:\r\nIt's a bit unfortunate, that this is one big pull request.\r\nNow we have to sort through everything at once and cannot discuss each issue separately.",
          "createdAt": "2025-10-06T16:04:20Z",
          "updatedAt": "2025-10-06T16:04:20Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In general: It's a bit unfortunate, that this is one big pull request. Now we have to sort through everything at once and cannot discuss each issue separately.\r\n\r\nI can easily split them into individual PRs(sans e.g. the 'unwanted' commit). Let me do that and we can then continue.",
          "createdAt": "2025-10-06T16:30:48Z",
          "updatedAt": "2025-10-06T16:30:48Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "> I can easily split them into individual PRs(sans e.g. the 'unwanted' commit). Let me do that and we can then continue.\r\n\r\nThanks :)\r\nAlso thanks for reading through the document and commenting.\r\n\r\nSome of the issues should definitely be fixed before publication.",
          "createdAt": "2025-10-07T09:41:11Z",
          "updatedAt": "2025-10-07T09:41:11Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I switched this PR to a draft PR. There are things I'll suggest differently while making a note of the comments so far.",
          "createdAt": "2025-10-11T08:33:51Z",
          "updatedAt": "2025-10-11T08:33:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7FB2pC",
          "commit": {
            "abbreviatedOid": "24bb5e1"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-06T15:47:17Z",
          "updatedAt": "2025-10-06T15:47:17Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I think the change to \"handshake or record\" is dangerous.\r\nWhat we mean is: either it's DTLS or it gets thrown away. with this change we would restrict what type of DTLS messages can be sent and that's not what we want.",
              "createdAt": "2025-10-06T15:47:17Z",
              "updatedAt": "2025-10-06T15:47:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7FCBAy",
          "commit": {
            "abbreviatedOid": "24bb5e1"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-06T15:54:30Z",
          "updatedAt": "2025-10-06T15:54:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This is wrong.\r\nIt's not just unsupported types, it's really unwanted packets.\r\n\r\nThis includes an Accounting packet that the proxy might accept in general, but may not be able to send it to the requested destination. This doesn't mean that the client should stop sending Accounting packets.",
              "createdAt": "2025-10-06T15:54:30Z",
              "updatedAt": "2025-10-06T15:54:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7FCHSb",
          "commit": {
            "abbreviatedOid": "24bb5e1"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-06T15:58:47Z",
          "updatedAt": "2025-10-06T15:58:47Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I would prefer leaving the parentheses in.\r\nThe deduction can be correct, if the server is actually down, but it may also be incorrect. The parentheses emphasize that the deduction is not always wrong.",
              "createdAt": "2025-10-06T15:58:47Z",
              "updatedAt": "2025-10-06T15:58:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7FCLv4",
          "commit": {
            "abbreviatedOid": "24bb5e1"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-06T16:01:54Z",
          "updatedAt": "2025-10-06T16:01:54Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I don't see any reason why we should forbid renegotiation.",
              "createdAt": "2025-10-06T16:01:54Z",
              "updatedAt": "2025-10-06T16:01:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7FC1Cc",
          "commit": {
            "abbreviatedOid": "24bb5e1"
          },
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-06T16:28:36Z",
          "updatedAt": "2025-10-06T16:28:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Correct, I'll drop this. For some reason I managed to skip the discussion that used unroutable realm as an example of an unwanted packet.",
              "createdAt": "2025-10-06T16:28:37Z",
              "updatedAt": "2025-10-06T16:28:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOLrzygc6sU1JS",
      "title": "Update to Detecting live servers - per connection",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/57",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change makes it clear that the watchdog needs to be on a per-connection basis.",
      "createdAt": "2025-10-06T17:15:24Z",
      "updatedAt": "2025-10-06T17:15:24Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "after-wglc/detecting-live-servers",
      "headRefOid": "5e1ccd40b75a79245084bb800be5e96c464bc400",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 58,
      "id": "PR_kwDOLrzygc6svfOh",
      "title": "radiusdtls-bis-09 - terminology",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/58",
      "state": "MERGED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reference to radext-gw mailing list message:\r\nhttps://mailarchive.ietf.org/arch/msg/radext/X5lyKic2hrxGj9YZbZ66U8N0PDs/\r\n\r\nI'd like to make sure the use of terms 'packet', 'message', 'datagram', etc. is uniform. My suggestion:\r\n- RADIUS packet, RADIUS packet type  - from RFC 2865\r\n- (D)TLS record - from the DTLS RFC 9147: a DTLS record always fits into one UDP datagram\r\n- UDP datagram\r\n- TCP segment\r\n- IP packet (not currently used by the draft)\r\n\r\nThe two commits in this pull request are examples of what kind of terminology check-up I'm thinking of.",
      "createdAt": "2025-10-08T16:52:12Z",
      "updatedAt": "2025-10-20T21:08:04Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "radius-packet-datagram",
      "headRefOid": "5a887b3c108b023ba098a434e33507f2bc81c3b0",
      "closedAt": "2025-10-20T21:08:04Z",
      "mergedAt": "2025-10-20T21:08:04Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "ceadd99f367e027b5a4f01199454f0b57866f7aa"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "It's always good to be clear and consistent :+1:\r\nI'll look through the document too and see if I see other instances where this should be changed.",
          "createdAt": "2025-10-08T18:43:42Z",
          "updatedAt": "2025-10-08T18:43:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7Fp1zA",
          "commit": {
            "abbreviatedOid": "5a887b3"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-08T18:42:19Z",
          "updatedAt": "2025-10-08T18:42:19Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I would leave `DTLS messages` in this specific instance as-is, because we're really talking about the payload of the UDP datagram, not about the UDP datagram itself.\r\nIt makes it clear, that this is something that must probably be handled at crypto-API level and not on the network stack.\r\n\r\nIn most (if not all) cases, the software is not splitting the DTLS records on the network layer and passing them individually to the TLS library, it's passing the UDP datagram to the TLS library, and then the software needs to make sure to use calls to the library that ensure only one DTLS record is handled at a time.",
              "createdAt": "2025-10-08T18:42:19Z",
              "updatedAt": "2025-10-08T18:42:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Fr1s5",
          "commit": {
            "abbreviatedOid": "5a887b3"
          },
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-08T21:37:15Z",
          "updatedAt": "2025-10-08T21:37:15Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "> I would leave `DTLS messages` in this specific instance as-is, because we're really talking about the payload of the UDP datagram, not about the UDP datagram itself. It makes it clear, that this is something that must probably be handled at crypto-API level and not on the network stack.\r\n\r\nFirst, I'd like to note that the [previous paragraph](https://www.ietf.org/archive/id/draft-ietf-radext-radiusdtls-bis-09.html#section-6.1-2) already says the following about sending RADIUS packets:\r\n\r\n`We note that a single UDP datagram may, however, contain multiple DTLS records.`\r\n\r\nTherefore it would be symmetric to use 'UDP datagram' also in this paragraph that talks about receiving RADIUS packets.\r\n\r\nSecond, the DTLS 1.3 RFC also says [`DTLS messages`](https://www.rfc-editor.org/rfc/rfc9147.html#section-4.3-1) when it talks about data that is transferred with DTLS records. TLS 1.3 also says that [records carry messages](https://www.ietf.org/archive/id/draft-ietf-tls-rfc8446bis-14.html#name-record-protocol). For these reason I'd avoid saying that DTLS messages contain DTLS records.\r\n\r\nThird, I'd say that UDP datagram is the synonym for the UDP datagram payload in this document. Or then this document could say 'UDP datagram payload' when there's a need to emphasise the payload.\r\n\r\n> In most (if not all) cases, the software is not splitting the DTLS records on the network layer and passing them individually to the TLS library, it's passing the UDP datagram to the TLS library, and then the software needs to make sure to use calls to the library that ensure only one DTLS record is handled at a time.\r\n\r\nI fully agree on this. Maybe this draft could simply says that received UDP datagrams are opaque data for a RADIUS server and must be directly passed to the TLS library. It seems, this is what the next section ['6.2 Server behavior' ](https://www.ietf.org/archive/id/draft-ietf-radext-radiusdtls-bis-09.html#section-6.2-1) already says?\r\n\r\n```\r\nWhen a RADIUS/DTLS server receives packets on the configured\r\nRADIUS/DTLS port, all packets MUST be treated as being DTLS.\r\nRADIUS/UDP packets MUST NOT be accepted on this port.\r\n```\r\nSomething I just noted: there is no text in the next section ['6.3 Client behavior'](https://www.ietf.org/archive/id/draft-ietf-radext-radiusdtls-bis-09.html#name-client-behavior) that says the similar thing about received UDP datagrams: all MUST be treated as being DTLS when the port is configured for sending RADIUS/DTLS requests.",
              "createdAt": "2025-10-08T21:37:15Z",
              "updatedAt": "2025-10-08T21:37:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 59,
      "id": "PR_kwDOLrzygc6svzJK",
      "title": "radiusdtls-bis-09 - Detecting Live Servers - absence of reply",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/59",
      "state": "OPEN",
      "author": "h-vn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Clarify that the updated paragraph covers both the correct and incorrect cases. That is, when the client draws a conclusion that the server is unavailable, the conclusion may be correct or incorrect and the pargraph covers the both cases, not just the problems with the incorrect conclusion.\r\n\r\nI've so far understood the paragraph to only address the problems that arise when the conclusion is incorrect. Janfred's comment clarified this is not the case and I hope the updated text is also clearer about this.",
      "createdAt": "2025-10-08T17:26:47Z",
      "updatedAt": "2025-10-08T17:26:47Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "live-servers-parens",
      "headRefOid": "b33514050ff6cbfee8c0ab7ebd37cdff7684db9c",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOLrzygc6tT4nQ",
      "title": "radiusdtls-bis-09 - Clarify text related to unwanted packet handling and comparisons to respective RFC 6614 behaviour",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/60",
      "state": "MERGED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "These changes aim to clarify the current text in section '4.5 RADIUS Datagrams'. In short:\r\n- two last two paragraphs are now in different order\r\n- the long paragraph that discusses RFC 6614 unwanted packets is now split to multiple paragraphs with bulletted list\r\n- a new sentence is added to clearly say RFC 6614 responses to unwanted packets is replaced by this document\r\n- imperfect and passive tense is replaced with present tense that states what RFC 6614 says\r\n\r\nSee the individual commits for more detailed descriptions per commit.\r\n\r\nFunctional changes are not intentional, these should be only clarifications.",
      "createdAt": "2025-10-12T13:02:36Z",
      "updatedAt": "2025-10-20T20:51:24Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "unwanted-packets",
      "headRefOid": "d51f60571b0f5ea65da4ef5649aefb8ff9f04905",
      "closedAt": "2025-10-20T20:51:24Z",
      "mergedAt": "2025-10-20T20:51:24Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "70baed6e125e27286a82c040b3ebe05aa9f9e548"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me.",
          "createdAt": "2025-10-13T10:08:47Z",
          "updatedAt": "2025-10-13T10:08:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 61,
      "id": "PR_kwDOLrzygc6tVQ9q",
      "title": "radiusdtls-bis-09 - Mostly DTLS specific updates",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/61",
      "state": "OPEN",
      "author": "h-vn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The overhead and retransmissions commits aim to clarify the existing text.\r\n\r\nThe third commit, '(D)TLS data is opaque', attempts to clarify that any data received over a TLS/TCP or DTLS/UDP port should be pushed to the (D)TLS implementation for processing. (D)TLS then tells what happens next.\r\n\r\nThe text the third commit adds is intended to say what Janfred commented earlier, [What we mean is: either it's DTLS or it gets thrown away](https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/56/commits/dcc543c0066b12fa3592a2d813a5fa8d9952fbb4#r2407121622), with the help of (D)TLS implementation. The removed text, from a point of RADIUS server implementator, reads as if the RADIUS server needs to understand what's the state of TLS connection or DTLS association.\r\n\r\nIn any case, I'd say the two removed paragraph should be in the 'Packet / Connection Handling' in case they are kept.",
      "createdAt": "2025-10-12T17:12:15Z",
      "updatedAt": "2025-10-13T09:36:39Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "dtls-specific-updates",
      "headRefOid": "bfb8515761d74b52b5769487c1925102c295310c",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1, modulu some minor comments",
          "createdAt": "2025-10-13T09:36:38Z",
          "updatedAt": "2025-10-13T09:36:38Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 62,
      "id": "PR_kwDOLrzygc6tWY3B",
      "title": "radiusdtls-bis-09 - Assorted fixes and other commits",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/62",
      "state": "OPEN",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Move two paragraphs to the enclosing section because they describe changes to RADIUS in general. The other commits fix typos, unify US vs UK spelling and fix some RADIUS messages types in an example.",
      "createdAt": "2025-10-12T21:26:40Z",
      "updatedAt": "2025-10-24T15:35:28Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c6c9b0f67f23913899fce54dfda92e028895da0d",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "assorted-commits",
      "headRefOid": "defa7edf5fda5c1f33584ed54008d5bb44b4c96d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1, other than I think the \"home server\" commit should be dropped.",
          "createdAt": "2025-10-13T09:35:04Z",
          "updatedAt": "2025-10-13T09:35:04Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> +1, other than I think the \"home server\" commit should be dropped.\r\n\r\nThat's fine with me, I just thought it looks odd that home server receives the said dynauth message types. It's correct to say that it can, even if the messages were unexpected, finish processing them and do whatever is needed.\r\n",
          "createdAt": "2025-10-15T12:56:36Z",
          "updatedAt": "2025-10-15T12:56:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "@h-vn I've added most of the changes already, could you rebase the branch, so the PR only shows the changes that are still pending?",
          "createdAt": "2025-10-23T08:08:53Z",
          "updatedAt": "2025-10-23T08:08:53Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll do it soon but not right now",
          "createdAt": "2025-10-23T21:43:27Z",
          "updatedAt": "2025-10-23T21:43:27Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The changes that now remain look correct. It may be useful to hold this since Margaret wrote on the list that she's working on the shepherding process. ",
          "createdAt": "2025-10-24T15:35:28Z",
          "updatedAt": "2025-10-24T15:35:28Z"
        }
      ],
      "reviews": []
    }
  ]
}