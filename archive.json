{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-03-06T00:49:54.327410+00:00",
  "repo": "radext-wg/draft-ietf-radext-radiusdtls-bis",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOLrzygc6HDCk-",
      "title": "Add / update text on UDP -> TCP and TCP -> UDP proxying issues",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/2",
      "state": "OPEN",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "6613 etc. discuss UDP to TCP, but not TCP to UDP.\r\n\r\nPlus, there's the whole issue of Accounting-Request and Acct-Delay-Time being updated on retransmits.  Which contributes to congestive collapse when doing UDP to TCP proxying.\r\n\r\nFor TCP to UDP, it may be rarer, but it's possible.  Should the proxy then take care of retransmitting packets over UDP?\r\n\r\nI need to suggest some text.",
      "createdAt": "2024-04-26T12:50:13Z",
      "updatedAt": "2024-04-26T15:51:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC 2866 says:\r\n\r\n```\r\n A forwarding server may either perform its forwarding function in a\r\n   pass through manner, where it sends retransmissions on as soon as it\r\n   gets them, or it may take responsibility for retransmissions, for\r\n   example in cases where the network link between forwarding and remote\r\n   server has very different characteristics than the link between NAS\r\n   and forwarding server.\r\n```\r\n\r\nAlex Clouter also mentioned we have the same issue on TCP -> TCP proxying, if the two connections have different throughputs",
          "createdAt": "2024-04-26T15:51:03Z",
          "updatedAt": "2024-04-26T15:51:03Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOLrzygc6st84w",
      "title": "clarity on (D)TLS record padding",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/24",
      "state": "OPEN",
      "author": "jimdigriz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From[1]:\n```\nFor the receiving RADIUS/DTLS node, the length checks defined in [[RFC2865](https://www.rfc-editor.org/rfc/rfc2865)], [Section 3](https://rfc-editor.org/rfc/rfc2865#section-3) still apply, but MUST use the length of the decrypted DTLS record instead of the UDP packet length.\n```\n\nThis is confusing to me as I am aware UDP is (typically) being used in the mix here so I could unintentionally read this as if I need to figure out the size of the UDP packet the record came in which would be obviously unlikely to be even possible :)\n\nMaybe a rewording to be explicit that as the UDP packet length is no longer available nor meaningful the application is to use the TLS record length to determine the end of the RADIUS packet, so maybe wording along the lines of:\n\n\"... still apply, but the TLS record length is used in place of the now no longer available nor meaningful UDP packet length.\"\n\nFrom[2]\n```\nExaclty one RADIUS packet is encapsulated in a DTLS record, ...\n```\n\nTypo of `Exaclty` which should be `Exactly`.\n\nFrom[3]:\n```\nFor UDP packets containing multiple DTLS records, each DTLS record MUST be parsed individually and padding at the end of each DTLS record MUST be ignored, instead of treating it as the beginning of a new packet, as it would be treated with RADIUS/TLS.\n```\n\nIt is unclear if you mean here:\n\n * [(D)TLS record padding](https://datatracker.ietf.org/doc/html/rfc8446#section-5.4)\n * [RADIUS (plaintext) data padding](https://datatracker.ietf.org/doc/html/rfc2865#section-3)\n\nMaybe this is because when I think of the return from `SSL_read()` I do not think \"I have a TLS record\" but 'plaintext data'. The OpenSSL manpage does talk in terms of records though so not doubt the problem is more with me.\n\nI would suggest dropping the mentioning of padding altogether here as your first sentence[1] covers what to do and leave it as:\n\n\"For UDP packets containing multiple DTLS records, each DTLS record MUST be parsed individually.\"\n\n[1] https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/blob/d57d9a112ea3755738996987c40e6f92ec3b30c1/draft-ietf-radext-radiusdtls-bis.md?plain=1#L508\n[1] https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/blob/d57d9a112ea3755738996987c40e6f92ec3b30c1/draft-ietf-radext-radiusdtls-bis.md?plain=1#L509\n[2] https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/blob/d57d9a112ea3755738996987c40e6f92ec3b30c1/draft-ietf-radext-radiusdtls-bis.md?plain=1#L510\n\n",
      "createdAt": "2025-03-05T15:54:38Z",
      "updatedAt": "2025-03-05T15:54:38Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOLrzygc5sWeGl",
      "title": "Add text around Server Name Indication",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/1",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "SNI was not part of RFC6614 or RFC7360.\r\n\r\nThis is possibly breaking backwards compatibility, so I don't want to change this without a discussion within the WG.\r\n\r\nThis Pull Request can be used to comment on aspects of the text.",
      "createdAt": "2024-04-11T11:54:05Z",
      "updatedAt": "2024-07-08T17:54:15Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "97c3d68c2250b7970014b23aa2793f1de3d88ea5",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_server_name_indication",
      "headRefOid": "7d83c0346f5b7c8cbe4f49fa2280f16c872d11fd",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc523DiS",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:07:24Z",
          "updatedAt": "2024-04-11T13:07:24Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "TLS servers _may_ be hidden behind a load balancer.",
              "createdAt": "2024-04-11T13:07:24Z",
              "updatedAt": "2024-04-11T13:07:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523E9V",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:10:09Z",
          "updatedAt": "2024-04-11T13:10:10Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "What about 7585, where the destination IP isn't known in advance?\r\n\r\nI think it's preferable to base server identity on the presented server credentials.  i.e. the certificate, and not any IP/port information.\r\n\r\nThat is, we have multiple connections to the same server certificate (or similar certificate identification fields), then the client should treat all of those connections as being similar.",
              "createdAt": "2024-04-11T13:10:09Z",
              "updatedAt": "2024-04-11T13:10:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523FKx",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:10:32Z",
          "updatedAt": "2024-04-11T13:10:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This seems backwards to me?  Is this a typo, or am I missing something?",
              "createdAt": "2024-04-11T13:10:33Z",
              "updatedAt": "2024-04-11T13:10:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523GPL",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:12:34Z",
          "updatedAt": "2024-04-11T13:12:34Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It's less about SNI than presented certificate, I think.  The distinction is important.\r\n\r\nOnce a client verifies the server identity (and that it matches the SNI), then it's possible to put all similar connections into a connection pool.  And it's OK to key that off of the SNI string, but I think it should be clear that it's being based off of the _identity_ , and not the SNI.",
              "createdAt": "2024-04-11T13:12:34Z",
              "updatedAt": "2024-04-11T13:12:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523G8C",
          "commit": {
            "abbreviatedOid": "7d83c03"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:13:52Z",
          "updatedAt": "2024-04-11T13:13:52Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I'm not clear how a server can \"distinguish clients\" by SNI.  Perhaps instead just \"present different identities to clients based on SNI\". ",
              "createdAt": "2024-04-11T13:13:52Z",
              "updatedAt": "2024-04-11T13:13:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc52_KIR",
          "commit": {
            "abbreviatedOid": "7d83c03"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-12T09:00:49Z",
          "updatedAt": "2024-04-12T09:00:49Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "How about this:\r\n\r\n```suggestion\r\nBy adding Server Name Indication, a RAIDUS/(D)TLS server can now provide different services (i.e. access to different roaming consortia) under the same destination IP address and port, or could present different certificates to clients or apply specific policies depending the server name the clients use in the SNI extension of the TLS Client Hello.\r\n```",
              "createdAt": "2024-04-12T09:00:49Z",
              "updatedAt": "2024-04-12T09:00:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc52_Mli",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-12T09:04:45Z",
          "updatedAt": "2024-04-12T09:04:45Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "See discussion on the ML on that one:\r\nhttps://mailarchive.ietf.org/arch/msg/radext/pX1cn_RnaRnqeu5MBXc-sohK_SQ",
              "createdAt": "2024-04-12T09:04:45Z",
              "updatedAt": "2024-04-12T09:04:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc52_NCK",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-12T09:05:44Z",
          "updatedAt": "2024-04-12T09:05:45Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nFor RADIUS/(D)TLS, this distinction is not that simple, i.e. because different RADIUS servers may be hidden behind a load balancer with one public IP address, and the load balancer dispatches the connections based on the Server Name Indication in the first TLS handshake record.\r\n```",
              "createdAt": "2024-04-12T09:05:44Z",
              "updatedAt": "2024-04-12T09:05:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc53B5ys",
          "commit": {
            "abbreviatedOid": "7d83c03"
          },
          "author": "mcr",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-12T13:18:09Z",
          "updatedAt": "2024-04-12T13:18:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOLrzygc5v_-MV",
      "title": "try to address proxying issues.  Helps with #2",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/3",
      "state": "MERGED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "My initial stab at addressing the proxying issues.",
      "createdAt": "2024-05-20T20:26:01Z",
      "updatedAt": "2024-07-08T17:49:22Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "0e3b595bd851c9e1fcf4e0bd227f269f8609754e",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "issue2",
      "headRefOid": "5d64d5f3f674c55f0e4f9293f3388898d3566bbc",
      "closedAt": "2024-07-08T17:49:21Z",
      "mergedAt": "2024-07-08T17:49:21Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "36cab8101d92b069730f390e8251f3f2a44d5ea1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "PR_kwDOLrzygc52L816",
      "title": "apply RFC9525 guidance for validating certificate identities",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/4",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "RFC9525 provides guidance on what/how to specify certificate identity validation. This PR applies those rules and references RFC9525 explicitly. \r\n\r\nIn addition the NAIrealm identity is generalized as it might be applied outside dynamic discovery.",
      "createdAt": "2024-07-23T09:00:17Z",
      "updatedAt": "2024-10-21T19:08:57Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-rfc9525-guidance",
      "headRefOid": "503d39d9a9e9b1ea9b6d604f5c3fcb2cfc9c5252",
      "closedAt": "2024-10-21T19:04:59Z",
      "mergedAt": "2024-10-21T19:04:59Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "b99af9528e8a20cbc246789eedb9e09ba502350a"
      },
      "comments": [
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the 'Selfie attack' discussion on the radext mailing list, this prposal might need an update too, related to omitting the identity check... ",
          "createdAt": "2024-07-25T11:20:15Z",
          "updatedAt": "2024-07-25T11:20:15Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "NONE",
          "body": "In regards to wildcard certificates, [RFC 9525](https://www.rfc-editor.org/rfc/rfc9525.html#name-matching-the-dns-domain-nam) talks about clients matching server wildcard certificate. How clear do we need to be about wildcard certificate use? For example, if software uses a wildcard certificate for accepting (D)TLS connections it must use a different non-wildcard certificate when it initiates a (D)TLS connections.",
          "createdAt": "2024-10-04T17:16:33Z",
          "updatedAt": "2024-10-04T17:16:33Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I will leave this PR open until we have finished the discussion on the selfie/loopback/... attack, to keep it visible.\r\n\r\nThe other text is merged with #19 ",
          "createdAt": "2024-10-21T19:02:21Z",
          "updatedAt": "2024-10-21T19:02:21Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "apparently github thinks that once a commit is merged in a different pull request, this one should be closed too. I'm sorry. I don't think that I can re-open it, so it still appears in the open PR list.\r\nI'll keep this PR in mind for further discussions.",
          "createdAt": "2024-10-21T19:08:56Z",
          "updatedAt": "2024-10-21T19:08:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L8fUz",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:02:38Z",
          "updatedAt": "2024-10-04T12:02:38Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "As per Russ' comments in his [secdir early review](https://mailarchive.ietf.org/arch/msg/radext/LMeW527YwDyovkhP-_2VwmAT_Fk) this needs to be adjusted.\r\n\r\nI've tried to change the wording here as one example, I'm not sure if this is correct.\r\nWe should probably get confirmation from folks that this is in fact correct to say.\r\n\r\n```suggestion\r\n  - If the expected RADIUS/(D)TLS server is associated with a specific NAI realm, e.g. by dynamic discovery {{!RFC7585}} or static configuration, that realm is matched against any naiRealm label contained in the subjectAltName extension.\r\n```",
              "createdAt": "2024-10-04T12:02:38Z",
              "updatedAt": "2024-10-04T12:02:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L8gGw",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:04:23Z",
          "updatedAt": "2024-10-04T12:04:23Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n  - If the expected RADIUS/(D)TLS server was configured as a hostname, or the hostname was yielded by a dynamic discovery procedure, the configured name is matched against the presented names from the subjectAltName:DNS extension. Since a dynamic discovery might by itself not be secured, implementations MAY require the use of DNSSEC {{!RFC4033}} to ensure the authenticity of the DNS result before considering this identity as valid. \r\n```\r\n\r\nJust for clarity.",
              "createdAt": "2024-10-04T12:04:23Z",
              "updatedAt": "2024-10-04T12:04:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L8hlV",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:07:48Z",
          "updatedAt": "2024-10-04T12:07:48Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I would be more explicit here, because the \"without doing so\" is a bit vague.\r\nWhat is it exactly that we mean? Is it sufficient that the client checks the \"issuer\" attribute of the certificate?\r\nWhy is this sentence of looping just here? The loop attack could possibly also happen with other scenarios (like DNS without DNSSEC and the NAPTR just points back to the server)",
              "createdAt": "2024-10-04T12:07:48Z",
              "updatedAt": "2024-10-04T12:07:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L8iLS",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:09:03Z",
          "updatedAt": "2024-10-04T12:09:03Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n  * If configured by the administrator, the identity check MAY be omitted after a successful {{RFC5280}} trust chain check, e.g. if the client used dynamic lookup there is no configured client identity to verify. The clients authorization MUST then be validated using a certificate policy OID unless both peers are part of a trusted network.\r\n```\r\n(just two typos)",
              "createdAt": "2024-10-04T12:09:03Z",
              "updatedAt": "2024-10-04T12:09:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L-biJ",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T15:51:42Z",
          "updatedAt": "2024-10-04T15:51:42Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The intention here is that a client MUST identy the server by any element that clearly identifies it. I think this includes subject, subjectAltNames, issuer+certificate serial (but not the issuer by itself).\r\n\r\nThe loop attack refers to the same issue we discussed regarding TLS-PSK, that an attacker could loop the TLS packets (without decrypting them) back to the client and it would accept that connection (if it generally accepts incomming connections, i.e. proxies).",
              "createdAt": "2024-10-04T15:51:42Z",
              "updatedAt": "2024-10-04T15:51:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L-gzS",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T16:03:32Z",
          "updatedAt": "2024-10-04T16:03:32Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Thanks for the heads-up. I will try to incorporate Russ' feedback. Have to check RFC9525 again, maybe it already suggests the correct wording.",
              "createdAt": "2024-10-04T16:03:32Z",
              "updatedAt": "2024-10-04T16:03:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L_Xk8",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T17:18:24Z",
          "updatedAt": "2024-10-04T17:18:24Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I have two points here:\r\nFirst, the text should explicitly state something like \"Clients MUST NOT accept any certificate without validating at least something\" instead of the general \"without doing so\"\r\nSecond, the Loop attack is a general attack, so maybe it is worth to put it in security considerations, have a few words here about it and then reference the security considerations section for details?",
              "createdAt": "2024-10-04T17:18:24Z",
              "updatedAt": "2024-10-04T17:18:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MLBps",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T11:39:14Z",
          "updatedAt": "2024-10-07T11:39:14Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "agreed to both points. This was as a last minute addition anyway, after it got mentioned in the TLS-PSK context.",
              "createdAt": "2024-10-07T11:39:14Z",
              "updatedAt": "2024-10-07T11:39:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MYtRg",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T18:52:59Z",
          "updatedAt": "2024-10-08T18:52:59Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": ">  Second, the Loop attack is a general attack, so maybe it is worth to put it in security considerations, have a few words here about it and then reference the security considerations section for details?\r\n\r\nOne workaround would be to check that the client/server random (in OpenSSLese, `SSL_get_client_random` and `SSL_get_server_random`) do not match.",
              "createdAt": "2024-10-08T18:52:59Z",
              "updatedAt": "2024-10-08T18:52:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MsyYP",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-10T14:24:36Z",
          "updatedAt": "2024-10-10T14:24:36Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "don't know how exactly client/server random works, but even experimentally, I'm struggling to see how this would work.\r\n\r\nIf I call `get_client_random` and `get_server_random` both on the connecting and accepting side of a tls connection, I actually get 4 different values, even when both sides run in the same process and use the same ssl context.\r\n\r\nAm I missing something?",
              "createdAt": "2024-10-10T14:24:36Z",
              "updatedAt": "2024-10-10T14:24:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MtVDT",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-10T15:12:16Z",
          "updatedAt": "2024-10-10T15:12:16Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> don't know how exactly client/server random works, but even experimentally, I'm struggling to see how this would work.\r\n> \r\n> If I call `get_client_random` and `get_server_random` both on the connecting and accepting side of a tls connection, I actually get 4 different values, even when both sides run in the same process and use the same ssl context.\r\n> \r\n> Am I missing something?\r\n\r\nThe first four bytes is the `gmt_unix_time` (legacy, and I think now purely random) when shown in `openssl s_client ...`, so that may be it, otherwise Works for Me(tm).\r\n\r\nApply the ghetto patch to https://github.com/openssl/openssl/tree/master/demos/sslecho, compile and run `sslecho s`:\r\n```\r\ndiff --git a/demos/sslecho/main.c b/demos/sslecho/main.c\r\nindex eec8e13a47..b4fca946cd 100644\r\n--- a/demos/sslecho/main.c\r\n+++ b/demos/sslecho/main.c\r\n@@ -7,6 +7,7 @@\r\n  *  https://www.openssl.org/source/license.html\r\n  */\r\n \r\n+#include <assert.h>\r\n #include <stdio.h>\r\n #include <unistd.h>\r\n #include <string.h>\r\n@@ -213,6 +214,18 @@ int main(int argc, char **argv)\r\n \r\n                 printf(\"Client SSL connection accepted\\n\\n\");\r\n \r\n+                unsigned char random[32];\r\n+                assert(SSL_get_client_random(ssl, random, sizeof(random)) == sizeof(random));\r\n+                printf(\"client random: \");\r\n+                for (int i = 0; i < sizeof(random); i++)\r\n+                    printf(\"%02X\", random[i]);\r\n+                printf(\"\\n\");\r\n+                assert(SSL_get_server_random(ssl, random, sizeof(random)) == sizeof(random));\r\n+                printf(\"server random: \");\r\n+                for (int i = 0; i < sizeof(random); i++)\r\n+                    printf(\"%02X\", random[i]);\r\n+                printf(\"\\n\");\r\n+\r\n                 /* Echo loop */\r\n                 while (true) {\r\n                     /* Get message from client; will fail if client closes connection */\r\n```\r\n\r\nAs the client run `openssl s_client -trace -connect localhost:4433`:\r\n```\r\nCONNECTED(00000003)\r\nSent Record\r\nHeader:\r\n  Version = TLS 1.0 (0x301)\r\n  Content Type = Handshake (22)\r\n  Length = 292\r\n    ClientHello, Length=288\r\n      client_version=0x303 (TLS 1.2)\r\n      Random:\r\n        gmt_unix_time=0x919DE39C                                                                <----\r\n        random_bytes (len=28): 97E42A6040AD6B9FA248D29B5C2C153E3F92AD9E14412CB875F8BF78         <----\r\n      session_id (len=32): 1557C0A035FB2A3DF97F5067FC534FC9E71BC106FB929E823A998467C893C6A0\r\n      cipher_suites (len=62)\r\n\r\n[snipped]\r\n\r\nReceived Record\r\nHeader:\r\n  Version = TLS 1.2 (0x303)\r\n  Content Type = Handshake (22)\r\n  Length = 122\r\n    ServerHello, Length=118\r\n      server_version=0x303 (TLS 1.2)\r\n      Random:\r\n        gmt_unix_time=0x99B5F850                                                              <----\r\n        random_bytes (len=28): 30BCD49D1F53AFE61C5A63B16AD7FABE3B444EEE5D1093D78E878639       <----\r\n      session_id (len=32): 1557C0A035FB2A3DF97F5067FC534FC9E71BC106FB929E823A998467C893C6A0\r\n      cipher_suite {0x13, 0x02} TLS_AES_256_GCM_SHA384\r\n      compression_method: No Compression (0x00)\r\n\r\n[snipped]\r\n```\r\n\r\nThe output I got matched.\r\n\r\nI am assuming this works in during the pre-establish handshake phase? That I did not test...",
              "createdAt": "2024-10-10T15:12:16Z",
              "updatedAt": "2024-10-10T15:19:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6M_HE6",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T05:48:44Z",
          "updatedAt": "2024-10-14T05:48:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Thanks for the detailed explanation; looks like I goofed up my experiment.\r\n\r\nSo yes, one could compare client/server randoms, but upon opening (or accepting) a connection, you would have to compare its random to verey other TLS connection. I.e. the client and server random of a single conneciton are always different (I guess as they should be for security reasons)",
              "createdAt": "2024-10-14T05:48:44Z",
              "updatedAt": "2024-10-14T05:48:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6NAK4T",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T07:36:44Z",
          "updatedAt": "2024-10-14T07:36:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I think you only need to limit the check window to the pool of the systems own not-yet-established TLS connections, as those connections have to come from yourself and be pending for this attack to work, right?",
              "createdAt": "2024-10-14T07:36:44Z",
              "updatedAt": "2024-10-14T07:37:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N6xzG",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T06:00:21Z",
          "updatedAt": "2024-10-21T06:00:22Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yes, but still this might be tricky to implement for the exact timing and potential race-conditions. After all the client and server side code very intentionally run at the same time. ",
              "createdAt": "2024-10-21T06:00:21Z",
              "updatedAt": "2024-10-21T06:00:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N74e_",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T08:20:55Z",
          "updatedAt": "2024-10-21T08:20:55Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "During the client hello callback (`SSL_CTX_set_client_hello_cb`) the connection is not established and the server side is yet to fully process the request.\r\n\r\nMaybe I am missing something, I do not see a race. If there was, you would be unable to use this function to select a server certificate (ie. ALPN) which is one of the primary use cases for it.\r\n\r\nIt does become slightly more complicated if the 'server' is actually a pool of nodes, but all that would require is an RPC call out to the other nodes to see what connections are outstanding.\r\n\r\nMeanwhile the connection under inspection is frozen in time until the callback completes.\r\n\r\nCan you think of a situation where this fails?\r\n\r\nI am only lobbying for it, as if this is a good defence (which implementing aside we still do not know) it is trivial to implement. Helping us is the connection pool churn is low and so the length of the list of being established in flight TLS connections is low (ie. less than 1000).",
              "createdAt": "2024-10-21T08:20:55Z",
              "updatedAt": "2024-10-21T08:20:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N8xqj",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T09:53:47Z",
          "updatedAt": "2024-10-21T09:53:47Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Its two threads (or more, at least for me) and a network connection, which for me always puts on the warning light, be careful. There can always be events from the network (timeouts, a connecting being closed) and the race conditions may arise when two legitimate connections happen a the same time. In the end one thread has to access data from another, which requires careful coordination.\r\n\r\nI do agree that it's a good idea and definitely worth a shot, I just anticipate that its not going to be as trivial to implement as at first glance it might seem.\r\n\r\nBesides that, these are implementaiton details. I guess the question we should ask here is what we should recommend or even mandate in the RFC.",
              "createdAt": "2024-10-21T09:53:47Z",
              "updatedAt": "2024-10-21T09:53:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N-gtL",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T12:53:20Z",
          "updatedAt": "2024-10-21T12:53:21Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> Its two threads (or more, at least for me) and a network connection, which for me always puts on the warning light, be careful.\r\n\r\nSure, but you have described the effect of language and design decisions and the usual trade off and balances we all make. For others, sharing memory may not even be possible in their language (functional, actor model, etc) so this would simply not be a concern for them.\r\n\r\nAs such, definitely I would agree that mandating this would be unfair to implementers but it would be well placed as recommendations on one of several ways to avoid this problem.\r\n\r\nWe do need something though as related to this all is https://github.com/radext-wg/draft-ietf-radext-tls-psk/issues/4 where stated is a KDF should be used (and crucially 'context' populated) but the two major public implementations do not.\r\n\r\nIf the two-step KDF 'dance' is to be dropped, something would be needed and maybe checking handshake random numbers and provide the backwards compatible sticky tape.",
              "createdAt": "2024-10-21T12:53:20Z",
              "updatedAt": "2024-10-21T12:53:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6OCoN8",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T18:42:55Z",
          "updatedAt": "2024-10-21T18:42:55Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "One possible solution would be to compare the TLS keying material after the TLS session is established. If two connections have the same, something is fishy.\r\n\r\nBut that would either mean comparing it to all open connections (bad, if there are a lot) or checking only against the newest ones (also not really ideal, may be hard to implement, still have to check a lot of connections) or keeping track of the pending connections and once there are no pending connections, dropping all established connections from the comparison-pool, since they can't be similar any more (also requires a lot of implementation)\r\n\r\nI am slightly tempted to use a TLS extension to send a randomized number generated at startup of the software and comparing this number for each incoming connection.",
              "createdAt": "2024-10-21T18:42:55Z",
              "updatedAt": "2024-10-21T18:42:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOLrzygc52M_3H",
      "title": "unify idle-timeout between TLS and DTLS",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/5",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "TLS and DTLS specify idle timeout and session limits with different levels of detail. Those limits should apply to both equally.",
      "createdAt": "2024-07-23T11:31:57Z",
      "updatedAt": "2024-10-21T20:42:51Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-idle-timeout",
      "headRefOid": "7efae6bceb6ed11212a611d2e8da900d12e48870",
      "closedAt": "2024-10-21T20:42:50Z",
      "mergedAt": "2024-10-21T20:42:50Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "7efae6bceb6ed11212a611d2e8da900d12e48870"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6CydbS",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for your input. Highly appreciated. See the comments in the review",
          "createdAt": "2024-07-23T15:03:42Z",
          "updatedAt": "2024-07-23T15:23:05Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I can imagine that this can lead to problems.\r\n\r\nOne would be Reverse-CoA where you rely on sending the CoA packet \"backwards\" through RAIDUS/(D)TLS and that doesn't work if the client is behind a NAT, unless the connection stays open.\r\n\r\nThe second would be monitoring.\r\nIf you have a number of Service Providers, all behind a NAT, then the only good monitoring for Liveness of the SP is \"does the server have a (D)TLS session with this client\"\r\nIf the client would just close it, then this monitoring would not be possible anymore.\r\n\r\nI would suggest: Replace `SHOULD` with `MAY` and add some text like `[...], the configuration SHOULD allow to disable the idle timeout session shutdown`",
              "createdAt": "2024-07-23T15:03:42Z",
              "updatedAt": "2024-07-23T15:23:05Z"
            },
            {
              "originalPosition": 6,
              "body": "I don't understand this last sentence (and unfortunately I can't infer from context what word is missing)",
              "createdAt": "2024-07-23T15:19:46Z",
              "updatedAt": "2024-07-23T15:23:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6CzkYv",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-23T17:00:15Z",
          "updatedAt": "2024-07-23T17:00:15Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "maybe add a note about reverse CoA, and say also that systems SHOULD leave at least one connection open, to avoid delays opening new connections when traffic goes from zero to >0",
              "createdAt": "2024-07-23T17:00:15Z",
              "updatedAt": "2024-07-23T17:00:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DEgTC",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T11:05:23Z",
          "updatedAt": "2024-07-25T11:05:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Ah, mabye its just the type r/from/form/, but the point was to emphasize that current setups often use long-lived TLS connections.\r\n\r\nI will try to reword...",
              "createdAt": "2024-07-25T11:05:23Z",
              "updatedAt": "2024-07-25T11:05:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DElT9",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T11:16:07Z",
          "updatedAt": "2024-07-25T11:16:07Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Have to get a bit more into Reverse-CoA.\r\n\r\nI guess in the end this puts even more emphasis on the statement to which values to use:  'it very much depends...'. There is no one size fits all here.",
              "createdAt": "2024-07-25T11:16:07Z",
              "updatedAt": "2024-07-25T11:16:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DKax2",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T22:08:20Z",
          "updatedAt": "2024-07-25T22:08:20Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "ok, I think the from/form correction clarifies what is meant.\r\nLet's see what the WG says",
              "createdAt": "2024-07-25T22:08:20Z",
              "updatedAt": "2024-07-25T22:08:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DRqCa",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-26T18:04:55Z",
          "updatedAt": "2024-07-26T18:04:55Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think advising cilents to keep a connection open would be a bit misplaced in _this_ document (e.g. with dynamic discovery it might not be apropriate), but its very valid to acknowledge that some scenarios do require it.\r\n\r\nA quick cross-read of reverse-CoA, it might more clearly state that the client MUST keep at least one conneciton open (it's kind of implied, but not clearly stated).",
              "createdAt": "2024-07-26T18:04:55Z",
              "updatedAt": "2024-07-26T18:04:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOLrzygc52OTP7",
      "title": "move TLS response cache invalidation to common section",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/6",
      "state": "OPEN",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Invalidation of response cache applies to both TLS and DTLS since both are TLS session based. Move paragraph to the common section.",
      "createdAt": "2024-07-23T14:20:26Z",
      "updatedAt": "2024-07-24T16:29:31Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-response-cache",
      "headRefOid": "92ce41898e586c140a12050c9c68ffeebe760e3d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\nSince the client connection is closed, those responses from the home server to the proxy server SHOULD be silently discarded by the proxy\r\n```\r\n\r\nMaybe make this MUST?  If the home server replies, there's no way for the proxy to send the packet anywhere.",
          "createdAt": "2024-07-23T17:03:07Z",
          "updatedAt": "2024-07-23T17:03:07Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Maybe make this MUST? If the home server replies, there's no way for the proxy to send the packet anywhere.\r\n\r\nAgreed; updated.",
          "createdAt": "2024-07-24T16:29:30Z",
          "updatedAt": "2024-07-24T16:29:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOLrzygc52OyfL",
      "title": "unify session resumption",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/7",
      "state": "OPEN",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "TLS session resumption is currently a SHOULD requirement for DTLS and for TLS-PSK.\r\n\r\nUnify this recommendation for all use of (D)TLS and provide guidance for re-authorization as proposed by TLS-PSK.",
      "createdAt": "2024-07-23T15:22:02Z",
      "updatedAt": "2024-10-01T18:27:49Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-session-resumption",
      "headRefOid": "28da1b8ed627e6d410f89d907c9f0dc68fd5f7e9",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've be in favor of making it a MUST.  I don't see any benefit for an implementation to _not_ implement resumption.",
          "createdAt": "2024-07-23T17:01:57Z",
          "updatedAt": "2024-07-23T17:01:57Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I've be in favor of making it a MUST. I don't see any benefit for an implementation to _not_ implement resumption.\r\n\r\nI vote against a MUST. The benefit for implementos is saving time and effort (if a particular device or application is unlikely to gain much from it, thinking of Wifi APs rather just keep a connection open at all times). And _not_ implementing it doesn't break anything.",
          "createdAt": "2024-07-24T16:22:27Z",
          "updatedAt": "2024-07-24T16:22:27Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps a server MUST implement it.  I expect that all of them will do it anyways, so there's no harm here.\r\n\r\nClients which expect to implement many connections SHOULD implement it.  Clients which rarely open connections do not benefit as much from session resumption.",
          "createdAt": "2024-10-01T18:27:47Z",
          "updatedAt": "2024-10-01T18:27:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 8,
      "id": "PR_kwDOLrzygc52Xkvx",
      "title": "Edits to grammar/spelling.",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/8",
      "state": "MERGED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Grammatical edits as per my comments in the mailing list.",
      "createdAt": "2024-07-24T17:08:36Z",
      "updatedAt": "2024-10-04T13:54:34Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "ethompson-grammar-edits",
      "headRefOid": "4c4f7e86e4f0eed27e468a3f59741032c6a1e9a0",
      "closedAt": "2024-10-04T12:14:03Z",
      "mergedAt": "2024-10-04T12:14:03Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "35ae6a4ca2c9231c266cf008734673a1952814a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOLrzygc52Xohl",
      "title": "Update draft-ietf-radext-radiusdtls-bis.md flow",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/9",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I believe \"if no matches exist\" flows better in the text.",
      "createdAt": "2024-07-24T17:17:48Z",
      "updatedAt": "2024-10-05T15:45:27Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "Edits-to-text-flow",
      "headRefOid": "8bc754363c6fada03b5b62a2b7e1024aace4e35f",
      "closedAt": "2024-10-05T15:45:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These statements (matching CN) are obsoleted by RFC9525 anyway. PR #4 (should we accept it) removes them completely. ",
          "createdAt": "2024-07-25T09:55:48Z",
          "updatedAt": "2024-07-25T09:55:48Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> These statements (matching CN) are obsoleted by RFC9525 anyway. PR #4 (should we accept it) removes them completely.\r\n\r\n+1",
          "createdAt": "2024-10-01T18:24:46Z",
          "updatedAt": "2024-10-01T18:24:46Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I will close this in favor of #4 , keeping the changes made here in mind.",
          "createdAt": "2024-10-05T15:45:27Z",
          "updatedAt": "2024-10-05T15:45:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 10,
      "id": "PR_kwDOLrzygc52XqPe",
      "title": "Update draft-ietf-radext-radiusdtls-bis.md clarity",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/10",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarifying that a bad RADIUS secret could be caused by a misbehaving party OR a misconfigured one.",
      "createdAt": "2024-07-24T17:22:44Z",
      "updatedAt": "2024-10-05T15:46:27Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "misbehaving-or-misconfigured-party",
      "headRefOid": "2eec15be8d84d7a7dca662e858d100eac849854c",
      "closedAt": "2024-10-05T15:46:26Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll close this PR, if there are strong opinions in the interim about this, we can always include it, but I don't see the need.",
          "createdAt": "2024-10-05T15:46:26Z",
          "updatedAt": "2024-10-05T15:46:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L8mOZ",
          "commit": {
            "abbreviatedOid": "2eec15b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:18:12Z",
          "updatedAt": "2024-10-04T12:18:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"misconfigured\" would mean that it is acceptable to configure a shared secret. Since we mandate \"radsec\" resp. \"radius/dtls\" as shared secret, any deviation from that is (at least formally) not standard-compliant and thus misbehaving.\r\n\r\n(I know that most RADIUS/TLS implementations still allow to configure a custom shared secret)",
              "createdAt": "2024-10-04T12:18:12Z",
              "updatedAt": "2024-10-04T12:18:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L9ciw",
          "commit": {
            "abbreviatedOid": "2eec15b"
          },
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T13:56:33Z",
          "updatedAt": "2024-10-04T13:56:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I see your point, and I agree. I suppose I was getting caught up on the difference between \"behaving maliciously\" and being \"misconfigured\", though on another pass I think \"misbehaving\" does not necessarily imply malice. I am happy to drop this edit",
              "createdAt": "2024-10-04T13:56:33Z",
              "updatedAt": "2024-10-04T13:59:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOLrzygc56jx3x",
      "title": "Idle Timeout Configuration",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/11",
      "state": "OPEN",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": " Added two sentences about exposing the idle timeout configuration to the administrator (from RFC 7360 Section 5.1.1)",
      "createdAt": "2024-09-05T17:54:37Z",
      "updatedAt": "2024-10-08T18:56:44Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "idle-timeout",
      "headRefOid": "307e5491319600fdb21f027445a123ec0a7c8b18",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems good to me",
          "createdAt": "2024-10-01T18:26:13Z",
          "updatedAt": "2024-10-01T18:26:13Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is possibly unnecessary if we choose to accept #5 ",
          "createdAt": "2024-10-06T20:00:49Z",
          "updatedAt": "2024-10-06T20:00:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6MYvE0",
          "commit": {
            "abbreviatedOid": "307e549"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T18:56:44Z",
          "updatedAt": "2024-10-08T18:56:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Should be noted that for non-stream setup UDP sockets, Linux's Netfilter uses a timeout of 30 seconds, so might be worth lowering the bottom end to match?",
              "createdAt": "2024-10-08T18:56:44Z",
              "updatedAt": "2024-10-08T18:56:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOLrzygc56jySj",
      "title": "Parallel Connection Requests",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/12",
      "state": "OPEN",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added text regarding the parallel connection requests detailed in RFC 6614 Section 2.3",
      "createdAt": "2024-09-05T17:55:47Z",
      "updatedAt": "2024-10-04T13:04:02Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "parallel-connection-requests",
      "headRefOid": "d33d9a1c2667393a88415511aec80f0b287a7e83",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would suggest to move this specification maybe even in an own paragraph.\r\n\r\nThis is not linked to (D)TLS directly, more in the direction of handling the underlying connection, and I think we need to add a few sentences for this exponential back-off mechanism.",
          "createdAt": "2024-10-04T12:24:29Z",
          "updatedAt": "2024-10-04T12:24:29Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It may be useful to have a section on managing connections, and distributing packets across connections.",
          "createdAt": "2024-10-04T13:04:00Z",
          "updatedAt": "2024-10-04T13:04:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOLrzygc56jyhL",
      "title": "EAP Section",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/13",
      "state": "OPEN",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added EAP section to include details from RFC 6613",
      "createdAt": "2024-09-05T17:56:26Z",
      "updatedAt": "2024-10-08T16:49:52Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "section-EAP-sessions",
      "headRefOid": "e09d7ebb3ac8f26ff23fcad4616953c94788e506",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's worth noting that one has to be careful when proxying EAP requests.\r\nI agree with Fabian that if the RADIUS/(D)TLS client is the \"first in line\", they should know the EAP session and take care of the correct path themselves, so it is only relevant for proxies.\r\n\r\nI would include a bit more reasoning why EAP is different than other RADIUS traffic, so people reading this can understand why they should care.",
          "createdAt": "2024-10-04T12:45:54Z",
          "updatedAt": "2024-10-04T12:45:54Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the connection / load-balancing issues are similar for a client which originates traffic, and a proxy which forwards traffic.  So the text should be similar.\r\n\r\nThe connection issue isn't limited to EAP, it's \"all packets for one session\".  e.g., MFA challenge / response.\r\n\r\nIf an authentication step takes one packet, then it doesn't matter how the client does packet load-balancing.  The failure of any one connection will only affect authentications which go over that one connection.\r\n\r\nWhen authentication requires multiple packets, we have a choice for load-balancing:\r\n\r\n1. put all packets for the same session over the same connection\r\n2. distribute packets for the same session across multiple connections\r\n\r\nThe client does not know if the server is an IdP / home server, or a proxy.  The client does not even know if the connections are to multiple \"equivalent\" home servers.  As a result, when the client initiates an authentication session with a particular server, that authentication session MUST be tied to one connection.  Distributing packets for one session across multiple connections means that in some valid architectures, multiple home servers will see packets for one authentication session.\r\n\r\nWhile this situation may work in some limited scenarios, it guarantees that authentication cannot work in other scenarios which are in use today.\r\n\r\nThe situation isn't much different if the next hop is a proxy.\r\n\r\nWith (1), the failure of any one connection will affect only the sessions which use that connection.  i.e. for 5 active connections which then has one fail, 1/5 of authentication sessions will be affected.  It is likely that those authentication sessions will fail, especially if the connections are to separate home servers.  At the minimum, 1/5 authentication sessions will experience increased timeouts and instability as the client does fail-over.\r\n\r\nWith (2) the failure of any one connection will affect _all_ of the authentication sessions.  In the above scenario, any multi-round authentication session will have 1/5 of the packets sent across each connection.  So when a connection fails, _every_ ongoing session is affected.\r\n\r\nIn order to help with network robustness, clients MUST put all packets for one authentication session across the same connection.  If that connections fails, clients MAY distribute packets to a different connection, but this will work in only limited situations, and those authentication sessions are likely to fail.\r\n\r\nThe issue is different for accounting.  Each packet is stand-alone, and the packets are far enough apart in time that there is no benefit to putting them on the same connection.",
          "createdAt": "2024-10-04T13:25:23Z",
          "updatedAt": "2024-10-04T13:25:23Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "But then we have the problem of defining a \"session\".\r\nWe don't have any reliable easy-to-find indication which RADIUS packets belong to the same session.\r\nSo as far as I can see we have two options here:\r\n\r\nOption 1: mandate that load-balancing must only be done on the basis of the source of the RADIUS packet (i.e. if your proxy has two connected clients (A,B) and two servers (C,D), the proxy MAY load-balance so that all packets from A go to C and all packets from B go to D. If every RADIUS peer in the chain follows this procedure, we will always have a deterministic path through the RADIUS proxy fabric.\r\nThis is the safe option, but also ineffective.\r\n\r\nOption 2: Mandate nothing. Just say \"Proxying is hard. Beware, there be dragons\" and elaborate on what operators may have to consider if they want to enable load-balancing.\r\nIf the operators are running a RADIUS service that is strictly single request-response, then there is no harm in randomly throwing the packets to all the servers equally.\r\nIf the operators know that their RADIUS service has sessions and the sessions have to go to the same server, then they can disable load-balancing and instead move to a hot-standby configuration",
          "createdAt": "2024-10-04T13:35:27Z",
          "updatedAt": "2024-10-04T13:36:17Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 9:35 AM, Jan-Frederik Rieckers ***@***.***> wrote\n> But then we have the problem of defining a \"session\".\n> We don't have any reliable easy-to-find indication which RADIUS packets belong to the same session.\n\n  The State attribute connects multiple packets across one authentication session.\n\n  However, the State attribute is random, and can change between packets.  So we can't use that.\n\n  The practical solution as implemented by many sites is:\n\n* load-balance on hash of Calling-Station-Id if it exists\n* otherwise load-balance on hash of User-Name\n\n> So as far as I can see we have two options here:\n> \n> Option 1: mandate that load-balancing must only be done on the basis of the source of the RADIUS packet (i.e. if your proxy has two connected clients (A,B) and two servers (C,D), the proxy MAY load-balance so that all packets from A go to C and all packets from B go to D\n> This is the safe option, but also ineffective.\n\n  It doesn't work.\n\n> Option 2: Mandate nothing. Just say \"Proxying is hard. Beware, there be dragons\" and elaborate on what operators may have to consider if they want to enable load-balancing.\n\n  The RFCs contain near-zero discussion of load-balancing.  At the same time, implementors and administrators have converged on a common set of practices.  It would be good to at least document these practices as known working suggestions.\n\n> If the operators are running a RADIUS service that is strictly single request-response, then there is no harm in randomly throwing the packets to all the servers equally.\n\n  Yes.\n\n> If the operators know that their RADIUS service has sessions and the sessions have to go to the same server, then they can disable load-balancing and instead move to a hot-standby configuration\n\n  But if the load-balancing is done as described above, there's no need to do any of this.  Everything just works.  It doesn't matter if authentication sessions are one packet or many packets.  It doesn't matter if the next hop is an IdP / home server or proxy.  It doesn't matter what kind of architecture has been set up for load-balancing on the server side.\n\n  It all just works.",
          "createdAt": "2024-10-04T13:55:07Z",
          "updatedAt": "2024-10-04T13:55:07Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would opt for documenting some best practices, and suggest, but not mandate behavior.",
          "createdAt": "2024-10-04T14:00:50Z",
          "updatedAt": "2024-10-04T14:00:50Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 10:01 AM, Jan-Frederik Rieckers ***@***.***> wrote:\n> I would opt for documenting some best practices, and suggest, but not mandate behavior.\n\n  Sure.  With the caveat that if this practice isn't followed, then things are likely to go wrong, for the above-described reasons.\n\n",
          "createdAt": "2024-10-04T14:03:12Z",
          "updatedAt": "2024-10-04T14:03:12Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "NONE",
          "body": "Hashing with primarily `Calling-Station-Id` and `User-Name`; \ud83d\udc4d for that. We use the both by default and it works. I haven't ever seen them change during the EAP authentication exchange. MAC address randomisation may cause the C-S-I to change, but that would affect the subsequent (re)authentications only.\r\n\r\nA note about hashing: Let's say that there are 5 connections and hashing uses modulo 5 to choose the next hop. When a connection goes down, it would be good if the hashing is still done so that the existing EAP exchanges do not switch the next hop, for example, hashing being done with module 4.",
          "createdAt": "2024-10-08T16:49:50Z",
          "updatedAt": "2024-10-08T16:49:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6LgHgs",
          "commit": {
            "abbreviatedOid": "e09d7eb"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T13:57:58Z",
          "updatedAt": "2024-10-01T13:57:58Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'm a bit confused about this MUST requirement.\r\n\r\nJust for my own understanding: we are talking about actual clients (i.e. NAS), and not proxies?\r\n\r\nI'm not very familiar with EAP on a NAS. I would expect that a client is always aware of the EAP sessions - but its details area outside of this specification. To me this is a prerequieiste for this MUST statement. If we can't guarantee this for a client, then we can't put a MUST here.\r\n\r\nThe second paragraph is confusing me. Having to keep EAP sessions together based on a radius attribute is something a proxy might do - as stated above a client should already know the EAP sessions. If a client has to guess the EAP sessions from a radius attribute, we can't call this a MUST.\r\n\r\nI would propose to remove the second paragraph (if my initial assumption of clients having perfect knowledge about EAP sessions is true).",
              "createdAt": "2024-10-01T13:57:58Z",
              "updatedAt": "2024-10-01T13:57:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOLrzygc56jz8n",
      "title": "Implementation Guidelines / Connected Sockets",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/14",
      "state": "OPEN",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added section including the details from RFC 7360 Section 6. I didn't feel like this text would fit well in any of the existing sections, so I created a new one",
      "createdAt": "2024-09-05T17:59:30Z",
      "updatedAt": "2024-10-07T11:26:57Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "section-implementation-guidelines",
      "headRefOid": "7cf6645ec8727a844d8ab701f318ad13c6225982",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 7, 2024, at 5:46 AM, Jan-Frederik Rieckers ***@***.***> wrote:\n> ..\n> +RADIUS/(D)TLS clients should use a single source (IP + port) when sending packets to a particular RADIUS/(D)TLS server. Doing so minimizes the number of (D)TLS session setups. It also ensures that information about the home server state is discovered only once.\n> \n> This could be a problem if a single RADIUS/(D)TLS peer has so much packet throughput that a single connection would be clogged (due to the limited ID space), and in this case the client would have to open a second connection to the same server to increase the usable space for packets-in-flight.\n> \n> I think we don't have text for that in the document yet, maybe it should be included in #13\n\n  Perhaps instead of a \"single\" connection, they should use the \"minimal\" number of connections.",
          "createdAt": "2024-10-07T11:26:56Z",
          "updatedAt": "2024-10-07T11:26:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6IH8lB",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T18:18:57Z",
          "updatedAt": "2024-09-05T18:18:58Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Perhaps \"historic\" or \"legacy\" instead of \"traditional\"",
              "createdAt": "2024-09-05T18:18:58Z",
              "updatedAt": "2024-09-05T18:18:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6IH9Kl",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T18:20:21Z",
          "updatedAt": "2024-09-05T18:20:21Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "The use of unconnected sockets is only for UDP / DTLS.",
              "createdAt": "2024-09-05T18:20:21Z",
              "updatedAt": "2024-09-05T18:20:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LhOL6",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T15:32:45Z",
          "updatedAt": "2024-10-01T15:32:45Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I'm opposing this recommendation. \r\n\r\nTo my knowledge, the stated limitation not beeing able to accept packets from different clients on the same port is wrong.\r\n\r\nUsing connected UDP sockets works perfectly fine and simplifies DTLS implementation a lot. Having to manually manage DTLS sessions and hand over received DTLS frames to the correct TLS context would be extremely tedious. Using connected UDP sockets and letting the TLS library do the hard work is way easier. ",
              "createdAt": "2024-10-01T15:32:45Z",
              "updatedAt": "2024-10-01T15:32:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LijjY",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T18:18:37Z",
          "updatedAt": "2024-10-01T18:18:38Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Where the src/dst ip/port is known in advance, connected UDP sockets work fine.  Where there is instead a \"wildcard\" socket for receiving packets from known clients but unknown source ports, connected UDP sockets have unavoidable race conditions in the network stack.\r\n\r\nA RADIUS server would typically perform the following steps to get a connected socket:\r\n\r\n1. open wildcard socket \"*:1812\" for UDP\r\n2. accept packets for that socket\r\n3. see new client source IP and source port\r\n4. Open new UDP socket on the same source IP/port (SO_REUSEADDR / SO_REUSEPORT)\r\n5. call connect() to connect to the client source IP and port\r\n6. receive packets on the connected socket\r\n\r\nFor a TCP connection, steps (4) and (5) are handled by `accept()`, which is atomic.  It both opens a new socket, and ties that socket to a particular src/dst IP/port.\r\n\r\nIn contrast for UDP, steps (4) and (5) are done as separate system calls by the application.  There is no clear way to know what happens to packets during that window.\r\n\r\ni.e. if there are multiple packets in the receive queue, does the `connect()` pull all packets out of the wildcard socket, and move them to the new socket?  Or do some packets go to the new connected socket, while other packets go to the original wildcard socket?\r\n\r\nAll of this is OS dependent.\r\n\r\nIf will _usually_ work, for the simple reason that the inter-packet spacing is larger than the time between system calls in steps (4) and (5).  But there is no _guarantee_ that it works.\r\n\r\nIf we do suggest that connected sockets are fine, then these issues should be explained, so that implementors are aware of them and can address them. \r\n\r\nThis issue is address in more detail in a cloudflare article:  https://blog.cloudflare.com/everything-you-ever-wanted-to-know-about-udp-sockets-but-were-afraid-to-ask-part-1/",
              "createdAt": "2024-10-01T18:18:38Z",
              "updatedAt": "2024-10-01T18:18:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LwOrL",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-03T05:26:33Z",
          "updatedAt": "2024-10-03T05:26:34Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I think here steps 4-5 are a non-issue. It may be in a general case (depending on the protocol, like quic), but since we are dealing explicitly with DTLS, its not.\r\n\r\nYes, between steps 3 and 5 any packet that arrives in that time frame _on the same 5-tuple_ will unpredictably be received by either the wildcard socekt or the connected socket. However in DTLS, there is no legal packat that can arrive _on the same 5-tuple_ between the initial client hello and an apropriate response from the server - which it will only send after connecting the socket. \r\n\r\n(sidenote: the initial client hello MUST fit into a single UDP packet; I stumbled over this when it didn't and OpenSSL would immediatley error out telling me so)\r\n\r\nThe worst thing that can happen is if duplicate UDP packets (client hello) arrive. If the connected socket gets it, I'm not shure how OpenSSL handles it, probably silently discards. If the wildcard socket gets it, it will try to connect another socket to the same 5-tuple, which will then fail.",
              "createdAt": "2024-10-03T05:26:34Z",
              "updatedAt": "2024-10-03T05:26:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LzyKi",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-03T13:22:07Z",
          "updatedAt": "2024-10-03T13:22:07Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "> However in DTLS, there is no legal packat that can arrive on the same 5-tuple between the initial client hello and an apropriate response from the server - which it will only send after connecting the socket.\r\n\r\nGood point.  I agree then that DTLS connections SHOULD use connected sockets.\r\n\r\nThis issue should be described and explained in the spec.",
              "createdAt": "2024-10-03T13:22:07Z",
              "updatedAt": "2024-10-03T13:22:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MKCBu",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T09:43:11Z",
          "updatedAt": "2024-10-07T09:43:11Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe text above describes the protocol. In this section, we give additional implementation guidelines. These guidelines are not part of the protocol, but they may help implementors create simple, secure, and efficient implementations.\r\n```\r\nI would argue that the \"interoperable\" part is the responsibility of the protocol specification. So I would not put \"interoperable\" here, but a different word. I'm not sure if \"efficient\" is the right one, maybe something along \"predictable\" in the meaning that administrators of different RADIUS/(D)TLS servers by different vendors can rely on a somewhat similar behavior under the same circumstances.",
              "createdAt": "2024-10-07T09:43:11Z",
              "updatedAt": "2024-10-07T09:43:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MKDhY",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T09:45:47Z",
          "updatedAt": "2024-10-07T09:45:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This could be a problem if a single RADIUS/(D)TLS peer has so much packet throughput that a single connection would be clogged (due to the limited ID space), and in this case the client would have to open a second connection to the same server to increase the usable space for packets-in-flight.\r\n\r\nI think we don't have text for that in the document yet, maybe it should be included in #13",
              "createdAt": "2024-10-07T09:45:47Z",
              "updatedAt": "2024-10-07T09:45:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MKJyX",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T09:56:47Z",
          "updatedAt": "2024-10-07T09:56:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "We already have some of this text in the \"Client Subsystems\" section in the Security considerations. Would you suggest merging the \"Client Subsystems\" section in this section?\r\nOtherwise, this text should at least reference the security considerations.",
              "createdAt": "2024-10-07T09:56:47Z",
              "updatedAt": "2024-10-07T09:56:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOLrzygc56kd9E",
      "title": "CA Trust for RADIUS/(D)TLS Clients",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/15",
      "state": "OPEN",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added blurb on how CA trust for RADIUS/(D)TLS clients should be configured (from RFC 7360 Section 10.4)",
      "createdAt": "2024-09-05T19:57:29Z",
      "updatedAt": "2024-10-21T20:17:56Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "client-trusted-authorities",
      "headRefOid": "daba6298ee529e95e6bbc0f78766654d43d63652",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2024-09-06T14:01:17Z",
          "updatedAt": "2024-09-06T14:01:17Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 9:07 AM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> \u2b07\ufe0f Suggested change\r\n\r\n  Looks good.\r\n\r\n",
          "createdAt": "2024-10-04T14:22:36Z",
          "updatedAt": "2024-10-04T14:22:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L8_ON",
          "commit": {
            "abbreviatedOid": "8f7c295"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T13:06:58Z",
          "updatedAt": "2024-10-04T13:06:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "The idea is good, I completely agree.\r\n\r\nI'm just not really comfortable with the text, I've tried to re-word it a bit, maybe you see where my problems are.\r\nIf you have an alternative: I'm happy to throw my re-wording away ;)\r\n\r\n```suggestion\r\nIf this model is implemented, RADIUS/(D)TLS clients SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer. Instead, the clients SHOULD start off with an empty CA list. The addition of a CA SHOULD be done only when manually configured by an administrator.\r\n\r\nThe goal of RADIUS/(D)TLS is to securely communicate with only a small set of well-known peers.\r\nThese peers will use specific certificates, potentially even from a private purpose-specific CA.\r\nThis scenario is different from a common use case of PKIX where an entity wants to communicate securely with unknown remote entities (i.e. web browsing), that use the public CAs to establish a trust path to this unknown entity.\r\n```",
              "createdAt": "2024-10-04T13:06:59Z",
              "updatedAt": "2024-10-04T13:06:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L-ASL",
          "commit": {
            "abbreviatedOid": "8f7c295"
          },
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T14:57:19Z",
          "updatedAt": "2024-10-04T14:57:20Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I am happy with these changes",
              "createdAt": "2024-10-04T14:57:19Z",
              "updatedAt": "2024-10-04T14:57:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MYyzO",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T19:04:50Z",
          "updatedAt": "2024-10-08T19:04:50Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I would suggest amending this to reflect should not be pre-configured as *already* trusted for the client.\r\n\r\nI could perceive an onboarding process that assists the administrator to know which CA to add as a trust anchor for the given client; it would show the chain but the administrator would still be expected to approve it.",
              "createdAt": "2024-10-08T19:04:50Z",
              "updatedAt": "2024-10-08T19:05:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6NyyC-",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-18T20:13:50Z",
          "updatedAt": "2024-10-18T20:13:50Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nIf this model is implemented, RADIUS/(D)TLS peers SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer that are enabled by default. Instead, the peers SHOULD start off with an empty CA list. The addition of a CA SHOULD be done only when manually configured by an administrator.\r\nThis does not mean that vendors or manufactures cannot include trust lists in their products, but enabling these lists should always be a conscious decision of the administrator.\r\n\r\nThe goal of RADIUS/(D)TLS is to securely communicate with only a small set of well-known peers.\r\nThese peers will use specific certificates, potentially even from a private purpose-specific CA.\r\nThis scenario is different from a common use case of PKIX where an entity wants to communicate securely with unknown remote entities (i.e. web browsing), that use the public CAs to establish a trust path to this unknown entity.\r\n```",
              "createdAt": "2024-10-18T20:13:50Z",
              "updatedAt": "2024-10-18T20:13:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6Nyyky",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-18T20:15:26Z",
          "updatedAt": "2024-10-18T20:15:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This is a suggestion to include the feedback from the interim.\r\nWordsmithing welcome, I'm not completely satisfied with the wording.\r\nLeaving the second should in lowercase was intended. This sentence is just information and not normative.",
              "createdAt": "2024-10-18T20:15:26Z",
              "updatedAt": "2024-10-18T20:15:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N0oja",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-19T11:41:07Z",
          "updatedAt": "2024-10-19T11:41:07Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I like the second part as is, it is helpful in explaining why someone should not just blindly leap and lean pre-trusting the web forum certs (which I probably would have done myself as an implementer), so my bike shedding suggestion is really only for the first part:\r\n\r\n\"If this model is implemented, RADIUS/(D)TLS peers SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer that are enabled by default. Instead, the peers SHOULD begin untrusted (ie. an empty CA list) and the process of trusting a given CA SHOULD be a manually step performed by an administrator.\r\n\r\nThis does not preclude vendors or manufactures including trust lists in their products, but the enabling of those lists should be a conscious decision by an administrator.\"",
              "createdAt": "2024-10-19T11:41:07Z",
              "updatedAt": "2024-10-19T11:41:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N_zQ_",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T14:32:44Z",
          "updatedAt": "2024-10-21T14:32:44Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I don't like the \"should begin untrusted\". The peers themselves are not untrusted, they are just untrusting (so to speak).\r\nAnd shouldn't it be \"should be a manual step performed by ...\" or \"manually performed step\"?",
              "createdAt": "2024-10-21T14:32:44Z",
              "updatedAt": "2024-10-21T14:33:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6ODSbt",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T20:17:56Z",
          "updatedAt": "2024-10-21T20:17:56Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I think a hybrid of the two for the \"first chunk\" would be good:\r\n\r\n\"If this model is implemented, RADIUS/(D)TLS peers SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer that are enabled by default. Instead, the peers SHOULD start off with an empty CA list. The addition of a CA SHOULD be done only when manually configured by an administrator.\r\n\r\nThis does not preclude vendors or manufactures including trust lists in their products, but the enabling of those lists should be a conscious decision by an administrator.\"\r\n\r\nAs for the \"second chunk\", I would change the wording slightly to something like:\r\n\r\n\"The goal of RADIUS/(D)TLS is to communicate securely with only a small set of well-known peers.\r\n\r\nThese peers will use specific certificates, potentially from a private, purpose-specific CA.\r\n\r\nThis scenario is different from the common use case of PKIX, where the goal is to communicate securely with unknown remote entities (e.g., web browsing) that use public CAs to bootstrap trust.\"\r\n\r\nThough, I'm not in love with saying \"specific certificates\" since I think that could be a little vague or confusing.",
              "createdAt": "2024-10-21T20:17:56Z",
              "updatedAt": "2024-10-21T20:17:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOLrzygc56q4EP",
      "title": "Security Consideration: Network Address Translation",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/16",
      "state": "OPEN",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added subsection on Network Address Translation (from RFC 7360 Section 10.5)",
      "createdAt": "2024-09-06T13:49:12Z",
      "updatedAt": "2024-10-08T18:05:08Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "Network-Address-Translation",
      "headRefOid": "3b26c0292bf02130fefe81928dd882b4c82b3c1b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2024-09-06T14:02:59Z",
          "updatedAt": "2024-09-06T14:02:59Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 9:19 AM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> +## Network Address Translation\r\n> +\r\n> +Network Address Translation (NAT) is fundamentally incompatible with RADIUS/UDP. RADIUS/UDP uses the source IP address to determine the shared secret for the client, and NAT hides many clients behind one source IP address. As a result, RADIUS/UDP clients cannot be located behind a NAT gateway.\r\n> +\r\n> +In addition, port reuse on a NAT gateway means that packets from different clients may appear to come from the same source port on the NAT. That is, a RADIUS server may receive a RADIUS/DTLS packet from one source IP/port combination, followed by the reception of a RADIUS/UDP packet from that same source IP/port combination. If this behavior is allowed, then the server would have an inconsistent view of the client\u2019s security profile, allowing an attacker to choose the most insecure method.\r\n> \r\n> I'm not sure exactly what the problem here is and if the proposed solution is correct.\r\n> \r\n> I'll try to put it the way I understand the problem:\r\n> \r\n> A 10.0.0.1 (RADIUS/DTLS) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:2083\r\n> B 10.0.0.2 (RADIUS/UDP) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:1812\r\n> \r\n> So now the RADIUS server has two UDP connections to 192.0.2.1:12345, but since the port on the RADIUS server side is different, the NAT can translate the UDP packets from source port 2083 to A and the ones from 1812 to B.\r\n\r\n  Yes.  The issue is the network security model.\r\n\r\n> In my view, the problem here is that, if the server mixes those up, the server is at fault for allowing the client list for RADIUS/UDP to merge with the client list for RADIUS/DTLS.\r\n> Those two client lists should be separate (at least in terms of IP-Addr/Port).\r\n\r\n  We don't know what source port will be used by the client.  So we can't rely on that.\r\n\r\n  All we know is that one IP is sending us RADIUS/UDP, and RADIUS/TLS.  The question is not just what to do, but what we _can_ do in that situation.\r\n\r\n> We cannot force every client behind a NAT to behave this way, because the NAT may be responsible for a huge variety of customer nets, and we can't mandate them to speak to each other.\r\n> \r\n> Example: Carrier-Grade NAT (CGN), Company A has a Dual-Stack internet connection with CGN for v4 and uses legacy-RADIUS, Company B has the same, but uses RADIUS/(D)TLS for their connection. We can't define a standard where Company A would now be forced to migrate to RADIUS/(D)TLS. They have no way of knowing that Company B is using DTLS with the same server. And we shouldn't mandate that the CGN keeps track of all possible connections and makes sure that no source port gets re-used if RADIUS/(D)TLS and RAIDUS/UDP are used with the same server.\r\n\r\n  Agreed.\r\n\r\n  To a certain extent, there is no technical reason why a server can't accept both RADIUS/UDP and RADIUS/TLS from the same source IP.  The packets are clearly distinguishable.\r\n\r\n  The problem we're trying to solve is to stop down-bidding attacks.  The simplest approach then is to say that both UDP and TLS may be allowed for compatibility, but that this configuration is NOT RECOMMENDED.",
          "createdAt": "2024-10-04T14:21:48Z",
          "updatedAt": "2024-10-04T14:21:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L9F4L",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T13:18:51Z",
          "updatedAt": "2024-10-04T13:18:51Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'm not sure exactly what the problem here is and if the proposed solution is correct.\r\n\r\nI'll try to put it the way I understand the problem:\r\n\r\nA 10.0.0.1 (RADIUS/DTLS) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:2083\r\nB 10.0.0.2 (RADIUS/UDP) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:1812\r\n\r\nSo now the RADIUS server has two UDP connections to 192.0.2.1:12345, but since the port on the RADIUS server side is different, the NAT can translate the UDP packets from source port 2083 to A and the ones from 1812 to B.\r\n\r\nIn my view, the problem here is that, if the server mixes those up, the server is at fault for allowing the client list for RADIUS/UDP to merge with the client list for RADIUS/DTLS.\r\nThose two client lists should be separate (at least in terms of IP-Addr/Port).\r\n\r\nWe cannot force every client behind a NAT to behave this way, because the NAT may be responsible for a huge variety of customer nets, and we can't mandate them to speak to each other.\r\n\r\nExample: Carrier-Grade NAT (CGN), Company A has a Dual-Stack internet connection with CGN for v4 and uses legacy-RADIUS, Company B has the same, but uses RADIUS/(D)TLS for their connection. We can't define a standard where Company A would now be forced to migrate to RADIUS/(D)TLS. They have no way of knowing that Company B is using DTLS with the same server. And we shouldn't mandate that the CGN keeps track of all possible connections and makes sure that no source port gets re-used if RADIUS/(D)TLS and RAIDUS/UDP are used with the same server.",
              "createdAt": "2024-10-04T13:18:51Z",
              "updatedAt": "2024-10-04T13:18:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MYUsP",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T18:05:08Z",
          "updatedAt": "2024-10-08T18:05:08Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Fortunately any kind of NAT is not going to blend this to the same source IP and port (to the same destination IP and port) as it would have no way to figure out what to do with the responses from the server (ie. which client gets them); ignoring the case of the idle timeout ending a flow and starting the new one.\r\n\r\nOtherwise I can only see this attack working if a server ignored the destination IP/port. Maybe I am missing something...",
              "createdAt": "2024-10-08T18:05:08Z",
              "updatedAt": "2024-10-08T19:29:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOLrzygc56q4c1",
      "title": "Security Consideration: Wildcard Clients",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/17",
      "state": "OPEN",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added subsection for Wildcard Clients (from RFC 7360 Section 10.6)",
      "createdAt": "2024-09-06T13:50:05Z",
      "updatedAt": "2024-10-04T17:22:08Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "wildcard-clients",
      "headRefOid": "1c0759df6ab4a748b1ae3b37557166d63dbbdf3c",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2024-09-06T14:01:36Z",
          "updatedAt": "2024-09-06T14:01:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good, though I'm not convinced it warrants opening a whole new section. Maybe we could include this specification somewhere else?\r\nWe have a bit of discussion on IP ranges already in the \"Connecting Client Identity\" section (currently 4.3)\r\n\r\nEdit: Sorry, didn't see that this was in the security considerations section.\r\nMy point still somewhat stands, but with one addition: For security considerations, I would suggest to add a bit more text why this is not an issue with RADIUS/(D)TLS, what we gain from identifying the client, etc.",
          "createdAt": "2024-10-04T13:22:09Z",
          "updatedAt": "2024-10-04T13:24:47Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "NONE",
          "body": "Could we change 'wildcard' to something else? One reason is that because this document relates to TLS, it's easy to get confused between wildcard clients and wildcard certificates. The second reason is that it gives the possibility to use 'wildcard' only when discussing about wildcard certificate.\r\n\r\nI see that there's nothing about wildcard certificates currently in the draft or RFCs. There probably should be? Ban them altogether (easy) or define how they are to be used (more work). Edit: pull request #4 adds a note about wildcard certificates.",
          "createdAt": "2024-10-04T17:03:18Z",
          "updatedAt": "2024-10-04T17:07:13Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 for not using \"wildcard\" when talking about clients.",
          "createdAt": "2024-10-04T17:22:07Z",
          "updatedAt": "2024-10-04T17:22:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOLrzygc56rxFz",
      "title": "Security Consideration: Crypto-Agility",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/18",
      "state": "OPEN",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added some basic text to reference the Deprecating Insecure Practices in RADIUS document (to address RFC 7360 Section 10.1)",
      "createdAt": "2024-09-06T16:02:52Z",
      "updatedAt": "2024-10-04T13:37:34Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "security-considerations-crypto-agility",
      "headRefOid": "75f3d6d19314e14940458386c31434a16f23572d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps\r\n\r\n\r\n# Crypto-Agility\r\n\r\nCrypto-agility requirements were discussed extensively in {{RFC6421}}.  {{RFC6614, Appendix C}} described how these requirements were met for RADIUS/TLS.  {{RFC7360, Section 10.1}} described how these requirements were met for RADIUS/DTLS.   The final outcome of the {{RFC6421}} crypto-agility requirements are discussed in {{?I-D.ietf-radext-deprecating-radius, Section 6.3}}.\r\n\r\nThis specification defers to {{?I-D.ietf-radext-deprecating-radius}} for all discussion of crypto-agility in RADIUS.  In short, TLS satisfies the requirements of {{?I-D.ietf-radext-deprecating-radius}}, and there is no need to define RADIUS-specific cryptographic primitives.\r\n\r\n\r\n",
          "createdAt": "2024-09-06T20:24:16Z",
          "updatedAt": "2024-09-06T20:24:33Z"
        },
        {
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I like your suggestion much better",
          "createdAt": "2024-09-09T14:08:24Z",
          "updatedAt": "2024-09-09T14:08:24Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I also like the suggestion from Alan.\r\nI'd reference the deprecating radius draft as normative and have them published as cluster. (But that's editorial. The content looks good to me)",
          "createdAt": "2024-10-04T13:27:49Z",
          "updatedAt": "2024-10-04T13:27:49Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd prefer to publish the deprecating document first.  It's essentially done.  Given issues like the BlastRADIUS vulnerability, I think it's preferable to have an official RFC describing what to do.  Otherwise as we've seen, implementors may do \"inventive\" things.\r\n\r\nThe TLSbis document is likely to take a while to settle.",
          "createdAt": "2024-10-04T13:34:47Z",
          "updatedAt": "2024-10-04T13:34:47Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fine by me, in this case it's even easier to reference it as normative.",
          "createdAt": "2024-10-04T13:37:32Z",
          "updatedAt": "2024-10-04T13:37:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOLrzygc5_XSYB",
      "title": "Update to RFC9525 Guidance",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/19",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've added this pull request as documentation for further discussions.\r\n\r\nThis is mainly the discussion from #4 with the things removed/added we discussed in the interim.",
      "createdAt": "2024-10-21T18:58:43Z",
      "updatedAt": "2024-10-21T19:04:57Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c458813a6d507981a69298ce6c3716b492b0aee0",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-rfc9525-guidance",
      "headRefOid": "5ef77e7823114e7d57b6bec750c006af3cce812e",
      "closedAt": "2024-10-21T19:04:57Z",
      "mergedAt": "2024-10-21T19:04:57Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "4f6bcde1ac3354dd4cc057e88d89a02297b6f962"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 20,
      "id": "PR_kwDOLrzygc6AuVgx",
      "title": "Add some text for agility",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/20",
      "state": "OPEN",
      "author": "jimdigriz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Moved the text from draft-ietf-radext-deprecate-radius and rejig it to work here.\r\n\r\nAs draft-ietf-radext-deprecate-radius does not deliver the agility it-self on these points whilst draft-ietf-radext-radiusdtls-bis (and RFC6614 and RFC7360) do, the references I feel should belong here.\r\n\r\nAddresses https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/18",
      "createdAt": "2024-11-03T12:54:41Z",
      "updatedAt": "2024-11-03T12:54:41Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "6f6500732cf450eeee8d2363d4c5a986266f6173",
      "headRepository": "jimdigriz/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "agility",
      "headRefOid": "5f2d1afb7c9e2b1beb1800a33ef9f5764d947251",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 21,
      "id": "PR_kwDOLrzygc6LdgeP",
      "title": "Propose Loopback-Attack text",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/21",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Propose Loopback-Attack text and move to subsection of Proxy",
      "createdAt": "2025-02-17T13:27:37Z",
      "updatedAt": "2025-03-03T22:10:55Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "96e64c166fece6d27cf5dc6912990feedb9ded1d",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-security-loopback-attack",
      "headRefOid": "36937ce0849a0ea499f393da398936526926bed9",
      "closedAt": "2025-03-03T22:10:55Z",
      "mergedAt": "2025-03-03T22:10:55Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "d57d9a112ea3755738996987c40e6f92ec3b30c1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6c82uJ",
          "commit": {
            "abbreviatedOid": "9411b45"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T14:27:31Z",
          "updatedAt": "2025-02-21T14:34:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nRADIUS/(D)TLS nodes that are configured to act both as client and server, typically in a proxy configuration, may be vulnerable to attacks where an attacker mirrors back all traffic to the node.\r\nTherefore, nodes that are capable of acting as both client and server SHOULD implement mitigations to avoid accepting connections from itself.\r\nOne example of a potentially vulnerable configuration is a setup where the RADIUS/(D)TLS server is accepting incoming connections from any address (or a wide address range).\r\nSince the server may not be able to verify the certificate subject or subject alternate names, the trust is based on the certificate issuer or certificate OID.\r\nHowever, in this case, the client certificate which the RADIUS/(D)TLS node uses for outgoing connections on the client side might also satisfy the trust check of the server side.\r\nOther scenarios where the identification of an outgoing connection satisfies the trust check of an incoming one are possible, but are not enumerated here.\r\n```",
              "createdAt": "2025-02-21T14:27:31Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nEither through misconfiguration, erroneous or spoofed dynamic discovery, or an attacker rerouting TLS packets, a proxy might thus open a connection to itself, creating a loop.\r\nSuch attacks have been described for TLS-PSK [selfie], dubbed a selfie-attack, but are much broader in the Radius/(D)TLS case. In particular, as described above, they also apply to certificate based authentication.\r\n```\r\n\r\nThe link to `[selfie]` has not been provided. This should be included in the references.",
              "createdAt": "2025-02-21T14:29:41Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nImplementations SHOULD therefore detect connections from itself, and reject them.\r\nThere is currently no detection method that works universally for all use-cases and TLS implementations.\r\nSome possible detection methods are listed below:\r\n\r\n```\r\n\r\n(always add an empty line between text and item lists. the markdown parser does not recognize the itemized list as such otherwise.",
              "createdAt": "2025-02-21T14:30:55Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nThe application layer RADIUS protocol also offers some loop detection, e.g. using a Proxy-State attribute.\r\nHowever, these methods are not capable of reliably detecting and suppressing these attacks in every case and are outside the scope of this document. \r\n```",
              "createdAt": "2025-02-21T14:34:12Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6c_MrL",
          "commit": {
            "abbreviatedOid": "a1adfb9"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T17:43:53Z",
          "updatedAt": "2025-02-21T17:43:57Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nSuch attacks have been described for TLS-PSK {{?RFC9257}}, dubbed a selfie-attack, but are much broader in the RADIUS/(D)TLS case. In particular, as described above, they also apply to certificate based authentication.\r\n```",
              "createdAt": "2025-02-21T17:43:54Z",
              "updatedAt": "2025-02-21T17:43:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6c_OdK",
          "commit": {
            "abbreviatedOid": "a1adfb9"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T17:47:26Z",
          "updatedAt": "2025-02-21T17:47:27Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nHowever, these methods are not capable of reliably detecting and suppressing these attacks in every case and are outside the scope of this document.\r\n```\r\n\r\n(the automatic build complains about trailing whitespaces)",
              "createdAt": "2025-02-21T17:47:26Z",
              "updatedAt": "2025-02-21T17:47:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6eNjtg",
          "commit": {
            "abbreviatedOid": "a040d73"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-03T14:49:02Z",
          "updatedAt": "2025-03-03T15:00:40Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n- Comparing client or server random used in the TLS handshake. While this is a very effective method, it requires access to values which are normally private to the TLS implementation.\r\n```",
              "createdAt": "2025-03-03T14:49:02Z",
              "updatedAt": "2025-03-03T15:00:40Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n- Sending a custom random number in an extension in the TLS client hello. Again, this is verify effective, but requires extension of the TLS implementation.\r\n```",
              "createdAt": "2025-03-03T14:49:27Z",
              "updatedAt": "2025-03-03T15:00:40Z"
            },
            {
              "originalPosition": 22,
              "body": "I don't really understand what this means.\r\nThe scenario I had in mind here was the following (can be either from the client or the server side, I'll make an example for the client side):\r\n* Client connects\r\n* Server sends server certificate\r\n* Client checks if the server certificate is equal to any server certificate that it would send itself\r\n\r\nThere should be no mixing of client and server certificates, because a scenario where the same cert is used as client and server cert is possible, but not what we are trying to solve here.\r\nIt is perfectly fine to have two separate certificates (one client, one server) and with the text above, as I read it, this check would say \"everything's fine\" because the client cert does not match any configured server certs.\r\n\r\n```suggestion\r\n- Comparing the incoming server certificate to all server certificates configured on the proxy. While in some scenarios this can be a valid detection method, using the same server certificate on multiple servers would keep these servers from connecting with each other, even when this connection is legitimate.\r\n```",
              "createdAt": "2025-03-03T15:00:32Z",
              "updatedAt": "2025-03-03T22:07:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOLrzygc6MDSzT",
      "title": "Malformed packets apply to both TLS and DTLS",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/22",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Statement about malformed packets apply to both TLS and DTLS. Reword slighlty and move to section 4.",
      "createdAt": "2025-02-21T13:41:22Z",
      "updatedAt": "2025-02-21T14:53:34Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "96e64c166fece6d27cf5dc6912990feedb9ded1d",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-malformed-packets",
      "headRefOid": "3edeec56cca17142207fe6cd01846239496a20b8",
      "closedAt": "2025-02-21T14:53:34Z",
      "mergedAt": "2025-02-21T14:53:34Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "8801686b7f1a9805600e52c809228f11b1f8b0d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6c8nuq",
          "commit": {
            "abbreviatedOid": "cd7e338"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T14:05:36Z",
          "updatedAt": "2025-02-21T14:14:25Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nAs a result the behavior with respect to discarded packets has to change, since a malformed RADIUS packet could impact the decoding of succeeding packets.\r\n\r\nWith DTLS, the \"next\" packet does not depend on proper decoding of the previous packet, since the RADIUS packets are sent in independent DTLS records.\r\nHowever, since both TLS and DTLS provide integrity protection and ensure that the packet was sent by the peer, a protocol violation at this stage implies that the peer is misbehaving.\r\n```",
              "createdAt": "2025-02-21T14:05:36Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nImplementations of this specification SHOULD read the \"silently discard\" texts in the RADIUS specification referenced above as \"silently discard and close the connection\".\r\n```\r\n\r\nor\r\n\r\n```suggestion\r\nImplementations of this specification SHOULD treat the \"silently discard\" texts in the RADIUS specification referenced above as \"silently discard and close the connection\".\r\n```",
              "createdAt": "2025-02-21T14:07:33Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            },
            {
              "originalPosition": 13,
              "body": "(Error was the same in the previous version, but now I noticed it.)",
              "createdAt": "2025-02-21T14:08:03Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThat is, the implementation SHOULD send a TLS close notification and, in the case of RADIUS/TLS, the underlying TCP connection MUST be closed if any of the following circumstances are seen:\r\n```\r\n\r\nThe original text was specific for RADIUS/TLS, and RADIUS/DTLS does not have a \"connection\", and closing the UDP socket is an implementation detail.\r\nI don't have a strong opinion about it, but that's what just came to my mind.",
              "createdAt": "2025-02-21T14:13:11Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOLrzygc6MDrUs",
      "title": "update DTLS packet legnths",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/23",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "DTLS handles application data based on DTLS records, so length and padding statements should apply to those records and not the the whole packet.",
      "createdAt": "2025-02-21T14:26:12Z",
      "updatedAt": "2025-02-21T14:37:09Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "dc4229e4cfa2237b231a4261b6f127a28ac2d362",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-dtls-packet-length",
      "headRefOid": "91ad0c7b53bded178b0c81507e9d2bae114c2eea",
      "closedAt": "2025-02-21T14:37:09Z",
      "mergedAt": "2025-02-21T14:37:09Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "e165b488000948c597a70e86b986fd3b93ff1b49"
      },
      "comments": [],
      "reviews": []
    }
  ]
}