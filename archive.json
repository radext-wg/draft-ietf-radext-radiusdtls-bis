{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2026-01-18T01:05:35.023409+00:00",
  "repo": "radext-wg/draft-ietf-radext-radiusdtls-bis",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "PR exists",
      "description": "",
      "color": "0E8A16"
    },
    {
      "name": "needs discussion",
      "description": "",
      "color": "e99695"
    },
    {
      "name": "WGLC Comment",
      "description": "",
      "color": "79be9f"
    },
    {
      "name": "Shepherd Comment",
      "description": "",
      "color": "5ee476"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOLrzygc6HDCk-",
      "title": "Add / update text on UDP -> TCP and TCP -> UDP proxying issues",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/2",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "6613 etc. discuss UDP to TCP, but not TCP to UDP.\r\n\r\nPlus, there's the whole issue of Accounting-Request and Acct-Delay-Time being updated on retransmits.  Which contributes to congestive collapse when doing UDP to TCP proxying.\r\n\r\nFor TCP to UDP, it may be rarer, but it's possible.  Should the proxy then take care of retransmitting packets over UDP?\r\n\r\nI need to suggest some text.",
      "createdAt": "2024-04-26T12:50:13Z",
      "updatedAt": "2025-04-14T21:35:14Z",
      "closedAt": "2025-04-14T21:35:13Z",
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC 2866 says:\r\n\r\n```\r\n A forwarding server may either perform its forwarding function in a\r\n   pass through manner, where it sends retransmissions on as soon as it\r\n   gets them, or it may take responsibility for retransmissions, for\r\n   example in cases where the network link between forwarding and remote\r\n   server has very different characteristics than the link between NAS\r\n   and forwarding server.\r\n```\r\n\r\nAlex Clouter also mentioned we have the same issue on TCP -> TCP proxying, if the two connections have different throughputs",
          "createdAt": "2024-04-26T15:51:03Z",
          "updatedAt": "2024-04-26T15:51:03Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this can be closed, since proxying issues are out-of-scope for this document.",
          "createdAt": "2025-04-14T21:35:13Z",
          "updatedAt": "2025-04-14T21:35:13Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOLrzygc6st84w",
      "title": "clarity on (D)TLS record padding",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/24",
      "state": "CLOSED",
      "author": "jimdigriz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "PR exists"
      ],
      "body": "From[1]:\n```\nFor the receiving RADIUS/DTLS node, the length checks defined in [[RFC2865](https://www.rfc-editor.org/rfc/rfc2865)], [Section 3](https://rfc-editor.org/rfc/rfc2865#section-3) still apply, but MUST use the length of the decrypted DTLS record instead of the UDP packet length.\n```\n\nThis is confusing to me as I am aware UDP is (typically) being used in the mix here so I could unintentionally read this as if I need to figure out the size of the UDP packet the record came in which would be obviously unlikely to be even possible :)\n\nMaybe a rewording to be explicit that as the UDP packet length is no longer available nor meaningful the application is to use the TLS record length to determine the end of the RADIUS packet, so maybe wording along the lines of:\n\n\"... still apply, but the TLS record length is used in place of the now no longer available nor meaningful UDP packet length.\"\n\nFrom[2]\n```\nExaclty one RADIUS packet is encapsulated in a DTLS record, ...\n```\n\nTypo of `Exaclty` which should be `Exactly`.\n\nFrom[3]:\n```\nFor UDP packets containing multiple DTLS records, each DTLS record MUST be parsed individually and padding at the end of each DTLS record MUST be ignored, instead of treating it as the beginning of a new packet, as it would be treated with RADIUS/TLS.\n```\n\nIt is unclear if you mean here:\n\n * [(D)TLS record padding](https://datatracker.ietf.org/doc/html/rfc8446#section-5.4)\n * [RADIUS (plaintext) data padding](https://datatracker.ietf.org/doc/html/rfc2865#section-3)\n\nMaybe this is because when I think of the return from `SSL_read()` I do not think \"I have a TLS record\" but 'plaintext data'. The OpenSSL manpage does talk in terms of records though so not doubt the problem is more with me.\n\nI would suggest dropping the mentioning of padding altogether here as your first sentence[1] covers what to do and leave it as:\n\n\"For UDP packets containing multiple DTLS records, each DTLS record MUST be parsed individually.\"\n\n[1] https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/blob/d57d9a112ea3755738996987c40e6f92ec3b30c1/draft-ietf-radext-radiusdtls-bis.md?plain=1#L508\n[1] https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/blob/d57d9a112ea3755738996987c40e6f92ec3b30c1/draft-ietf-radext-radiusdtls-bis.md?plain=1#L509\n[2] https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/blob/d57d9a112ea3755738996987c40e6f92ec3b30c1/draft-ietf-radext-radiusdtls-bis.md?plain=1#L510\n\n",
      "createdAt": "2025-03-05T15:54:38Z",
      "updatedAt": "2025-05-27T08:54:26Z",
      "closedAt": "2025-05-27T08:54:25Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with #32 ",
          "createdAt": "2025-05-27T08:54:25Z",
          "updatedAt": "2025-05-27T08:54:25Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOLrzygc6ywMKh",
      "title": "Updating \"Connecting Client Identity\"",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/26",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per Fabians [comments on the mailing list](https://mailarchive.ietf.org/arch/msg/radext/pY_NTCPXAMb6Bgs018THc33rOEs):\n\nWe have the section \"Connecting Client Identity\"\nWhat do we need it for?\nIn practice, the identity of the client is not done with the identifiers listed in the text, but instead different identifies such as subjectAltName or similar certificate attributes",
      "createdAt": "2025-04-16T09:04:58Z",
      "updatedAt": "2025-07-20T12:58:46Z",
      "closedAt": "2025-07-20T12:58:46Z",
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's likely best to just wave your hands vigorously and state \"the client is uniquely identified by some TLS magic.  Client certs, PSK Identity, or other things\".\n\nWhile RFC 9525 defines Service Identity in TLS, there is no similar document for Client Identity.  Perhaps we'll add another item to the \"todo\" list for UTA.",
          "createdAt": "2025-04-16T11:42:56Z",
          "updatedAt": "2025-04-16T11:42:56Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "We'll just leave it as is, maybe it's good to have a description of an actual identity, even if we don't do anything in our document, but other (later) documents may use it.",
          "createdAt": "2025-07-20T12:58:46Z",
          "updatedAt": "2025-07-20T12:58:46Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOLrzygc6ywP1B",
      "title": "Discussion around PMTU discovery",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/27",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "PR exists"
      ],
      "body": "As per Fabians [comments on the mailing list](https://mailarchive.ietf.org/arch/msg/radext/pY_NTCPXAMb6Bgs018THc33rOEs):\n\nIn the section for client session management for DTLS, we recommend using PMTU discovery.\nWhy do we do this? Do we need it? What can the client do about it?",
      "createdAt": "2025-04-16T09:10:49Z",
      "updatedAt": "2025-05-27T08:54:52Z",
      "closedAt": "2025-05-27T08:54:51Z",
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, that caused me to go down a rabbit hole.\n\nFreeRADIUS has disabled MTU discovery since 2009.  The commit messages don't explain why, but a little more checking shows a message to the FreeRADIUS mailing list from Stefan Winter:\n\nhttps://lists.freeradius.org/pipermail/freeradius-devel/2009-August/004868.html\n\n> now this is unpleasant: Apparently, many OSes set the DF bit on every\n> datagram they send, if Path MTU discovery is turned on. Even on UDP packets.\n> This breaks your RADIUS communication if datagram > MTU. I have reason\n> to believe that this has led to numerous problems with EAP-TLS in\n> eduroam, for example.\n>\n> It is of course not in principle a FreeRADIUS problem, but an OS one\n> (speaking here of Linux in particular), but other software like BIND\n> takes precautions against that and I think it might be good to do the\n> same in FreeRADIUS as well (i.e. explicitly disable IP_DONTFRAG socket\n> option).\n\nThe Linux documentation pages describes some related behavior:\n\nhttps://man7.org/linux/man-pages/man7/ip.7.html\n\n> While MTU discovery is in progress, initial packets from\n> datagram sockets may be dropped.  Applications using UDP\n> should be aware of this and not take it into account for\n> their packet retransmit strategy.\n\nI would suspect this really means _\"Before MTU discover has occurred. packets which are larger than the path MTU may be silently dropped somewhere in the network.  Once MTU has been discovered, packets larger than path MTU will result in an EMSGSIZE error\"_\n\nSo what do we do about it?\n\nIf we have large EAP packets and a small local MTU, there isn't much we can do for UDP.  Doing PTMU discovery doesn't help the client, because it can't control the size of the RADIUS packets.  The client (or proxy) just sends the packet, and hopes for the best.\n\nIf the local network can handle fragmented UDP packets, everything works.  If the packets go across the wider Internet, then fragmented UDP packets will likely get dropped.\n\n\nFurther discussion of fragmentation issues is available at https://www.freeradius.org/documentation/freeradius-server/4.0.0/trouble-shooting/connect_nas.html#_identifying_broken_path_mtu_discovery\n\nSo the issues are:\n\n* If you're using UDP, you may be affected by packet fragmentation. \n  *  It's more likely when EAP is being used, but it can happen in other situations, such as when the Access-Accept contains a long list of filter rules (RFC7499 can help here)\n* PMTU discovery doesn't help, as the RADIUS client often doesn't control the contents / size of the packet.\n* RADIUS offers no way to fragment Access-Request data across multiple packets.\n  * So even if the client does PMTU discovery, there's little that it can do with that information\n* most local networks will support fragmented UDP packets, so the client can just send the packet and hope for the best\n* PMTU discovery only really helps when you're sending packets across the Internet where fragmented UDP packets are discarded\n  * i.e. PTMU discovery means that when a proxy sends a large UDP packet, it gets an immediate `EMSGSIZE` error.\n  * the proxy can then take action.\n    *  send the packet over another connection\n    * signal the client via Protocol-Error\n  * this explicit signal is much better than waiting for a reply which will never arrive\n\nThis is all a bit much for the TLSbis document.  Perhaps it's best to just say \"UDP fragments might work on local networks, and are likely to not work across the wider Internet.  PMTU discovery doesn't necessarily help.  If you're not sure, just use TCP\".",
          "createdAt": "2025-04-16T11:38:30Z",
          "updatedAt": "2025-04-16T11:38:30Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with #27",
          "createdAt": "2025-05-27T08:54:51Z",
          "updatedAt": "2025-05-27T08:54:51Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOLrzygc6ywrMH",
      "title": "TLS Record count limitation",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/28",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "PR exists"
      ],
      "body": "In (D)TLS, we can only encrypt a limited number of records until the security degrades.\nFor RADIUS/(D)TLS we have long-lived TLS sessions where we might reach this limit.\n\nWe need to decide whether or not we put some normative/informational text in the document.\nInstead we could leave this to the uta or tls WG and say nothing about this.",
      "createdAt": "2025-04-16T09:52:49Z",
      "updatedAt": "2025-05-27T08:58:05Z",
      "closedAt": "2025-05-27T08:58:04Z",
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there a TLS/DTLS RFC which mentions this issue?  If so, we can just reference that.  We don't need to mention this issue specifically.\n\nIf not, we could put it on the list of things to do for UTA.",
          "createdAt": "2025-04-16T11:02:56Z",
          "updatedAt": "2025-04-16T11:02:56Z"
        },
        {
          "author": "smyslov",
          "authorAssociation": "NONE",
          "body": "Section 5.5 of RFC 8446 for TLS 1.3 sets the limits for AES-GCM and ChaCha20-Poly1305. There is also more generic document for AEAD limits: https://datatracker.ietf.org/doc/draft-irtf-cfrg-aead-limits/",
          "createdAt": "2025-05-07T05:58:47Z",
          "updatedAt": "2025-05-07T05:59:05Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with #31 ",
          "createdAt": "2025-05-27T08:58:04Z",
          "updatedAt": "2025-05-27T08:58:04Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOLrzygc61asnx",
      "title": "Client Connection Attempts",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/29",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs discussion"
      ],
      "body": "OpenRoaming implementers have seen issues where RADIUS/TLS clients repeatedly try to connect to servers, despite their connections not being accepted\n\nThat is, the TCP port is open, but after exchanging TLS data, the server decides that the client should not be allowed access, and closes the connection.  This usually happens when the client is misconfigured:\n\n* client is using the wrong credentials (invalid PSK or client certificate from unknown or wrong CA)\n  * Section 4.3 discusses client identity, and states that depending on the presented credentials,\n\n```\nthe server may decline to perform RADIUS transactions with this client`\n``` \n* the client is coming from an untrusted network.\n  *  Section 7.3 of this document discusses filtering\n\n```\nIf every RADIUS/(D)TLS client is configured with an IP range, then the server does not even have to perform a partial TLS handshake if the connection attempt comes from outside every allowed range, but can instead immediately drop the connection.\n```\n\nThe observed behavior is that some clients are attempting to reconnect multiple times a second, which is unfriendly.\n\nThe current Section 4 has no text on reconnection attempts.  Perhaps we could add a section to discuss this, using timers similar to [RFC 5080 Section 2.2.1](https://www.rfc-editor.org/rfc/rfc5080.html#section-2.2.1)\n\n---\n\n4.8 Client Connection Attempts\n\nWhen a client fails to open a connection, it SHOULD wait for a\nperiod of time, and then try the connection attempt again.\n\nSome existing RADIUS clients implement excessively aggressive\nreconnection behavior, utilizing default reconnection timeouts of\none second or less without support for congestive backoff.  When\ndeployed at a large scale, these implementations are susceptible to\ncongestive collapse. \n\nRADIUS client connection timers are based on the model used RFC 5080\nSection 2.2.1.  Variables used here are also borrowed from this\nspecification.  The connection attempts terminate when the client\nsuccessfully connects to the server, or the connection attempts are\nconsidered to have failed according to the reconnection\nmechanism described below.  Other reconnection mechanisms are\npossible, as long as they satisfy the requirements on jitter and\ncongestive backoff.\n\nThe following algorithms MUST be implemented by any client that originates RADIUS/TLS\nconnections.\n\nThe reconnection behavior is controlled and described by the\nfollowing variables:\n\n      RT     Reconnection timeout\n\n      IRT    Initial reconnection time  (default 2 seconds)\n\n      MRC    Maximum reconnection count (default 15 attempts)\n\n      MRT    Maximum reconnection time (default 300 seconds)\n\n      MRD    Maximum reconnection duration (default 3600 seconds)\n\n      RAND   Randomization factor\n\nWith each connection attempt, the sender sets RT according to the\nrules given below.  If RT expires before the connection is successful,\nthe sender re-computes RT and makes another connection attempt.\n\nEach of the computations of a new RT include a randomization factor\n(RAND), which is a random number chosen with a uniform distribution\nbetween -0.1 and +0.1.  The randomization factor is included to\nminimize the synchronization of messages.\n\nThe algorithm for choosing a random number does not need to be\ncryptographically sound.  The algorithm SHOULD produce a different\nsequence of random numbers from each invocation.\n\nRT for the first connection attempt is based on IRT:\n\n      RT = IRT + RAND*IRT\n\nRT for each subsequent connection attempt is based on the\nprevious value of RT:\n\n      RT = 2*RTprev + RAND*RTprev\n\nMRT specifies an upper bound on the value of RT (disregarding the\nrandomization added by the use of RAND).  If MRT has a value of 0,\nthere is no upper limit on the value of RT.  Otherwise:\n\n      if (RT > MRT)\n         RT = MRT + RAND*MRT\n\nMRD specifies an upper bound on the length of time that a\nclient may try to connect to a server.  The client stops its'\nconnection attempts when MRD seconds have elapsed since it first\nattempted to connect .  MRD MUST be set, MUST NOT have a value higher\nthan 86400 seconds.  MRD SHOULD have a value between 300 and 86400\nseconds.\n\nMRC specifies an upper bound on the number of times a client may try\nto reconnect to a server.  If MRC is zero, The client stops its'\nconnection attempts once MRD seconds have elapsed since the client\nfirst attempted to connect.  If MRC is non-zero, The client stops its'\nconnection attempts when either it as tried MRC connection attempts,\nor when MRD seconds have elapsed since the client first attempted to\nconnect.\n\nThe recommended values for these variables are a balance between\nenabling fast reconnection when there are transient network outages,\nand acknowledging that infinite retries are not desired.  That is, if\na RADIUS server cannot be reached within a day, then the problem is\nlikely due to client misconfiguration, and is not due to a transient network\noutage.  Once a client stops its reconnection attempts due to reaching\nMRC or MRD, it SHOULD log a descriptive error indicating that the\nserver is unreachable.  This error serves as an indication that\nadministrator intervention is needed.\n\nThe client then MUST NOT make any more connection attempts until an\nadministrator has intervened.  This administrator intervention could take any form,\nsuch as setting a \"reconnect now\" flag.  Other forms of this\nintervention are implementation defined, and are outside of the scope\nof this specification.\n",
      "createdAt": "2025-05-06T18:31:05Z",
      "updatedAt": "2025-07-07T16:22:36Z",
      "closedAt": "2025-07-07T16:22:36Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "The question here is: Is this relevant for RADIUS/(D)TLS or is this a general RADIUS (Proxying) issue and therefore out of scope?\n\nI would be reluctant to add so much text at this point.\n\nMy suggestion would be to add a small paragraph about this as a heads-up for implementers, but keep the exact algorithm out of this document and put it in a RADIUS best practices document.",
          "createdAt": "2025-05-12T14:41:02Z",
          "updatedAt": "2025-05-12T14:41:02Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue is only for RADIUS/(D)TLS and RADIUS/TCP.  Those transports have connections between the client and server.\n\nRADIUS/UDP doesn't have connections.  Even connected UDP sockets are pretty bad, and don't always work the way you would think.  RADIUS/UDP historically has just done per-packet retransmissions, and completely ignored the idea of a \"connection\".\n\nSo since this is an issue for RADIUS/(D)TLS, and not so much for RADIUS/UDP, I think it's OK to add here.\n\nIf we don't add it here, then this text will have to wait for a new standards-track document.  Which is likely to be a long time coming.",
          "createdAt": "2025-05-12T14:48:24Z",
          "updatedAt": "2025-05-12T14:48:24Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, clients retrying to connect too fast can be an issue. So putting in some limits might be good. As Janfred suggested, I'm in favor of keeping it short and not overspecify it. I don't think we need to compel implemetors do it in exactly this way - as long as a somewhat reasonable back-off is implemented.\n\nI see two important points to mandate:\n- a lower bound: don't retry a connection earlier than, say, 2 seconds\n- an exponential back-off (double the reconnect timer every time it fails - with an upper limit. Currently I limit the back-off to 60s; see below)\n- mabye add jitter (not sure if mandating it is required, but implementations may do it)\n\nNo strong feelings about the exact numbers to recommend or mandate - I've chosen mine arbitrarily.\n\nApplying the RFC5080 algorithm directly, I see one particular issue: giving up the connection attempts completely. Might be wishful for misconfigured clients, but it creates issues in certain situations: e.g. when a radius server (idp or proxy) is down for maintenance or otherwise unreachable for some time. If that time is too long, the clients would have given up and never recover without admin intervention. As an infrastructure/service operator, this is a no-go for me. For this, I also limit the back-off timer, to ensure a reasonable recovery time after a server is back alive.\n",
          "createdAt": "2025-05-23T18:40:51Z",
          "updatedAt": "2025-05-23T18:40:51Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Clients already have to (or should) implement the retransmission requirements of RFC 5080.  Using the same algorithm here should make it easier to implement.  Plus, there is no real reason to have a different algorithm.\n\nThe suggestion to stop connection attempts came from Eduroam US.  There, they see clients who have _never_ been able to connect, but who are still trying days to months later.\n\nI think it's OK either way (stop trying on error, or keep trying on error).  We just need a back-off time which is small enough that it allows systems to recover from temporary failures, but large enough that the connection attempts aren't problematic.\n\nI would also be concerned about systems which are affected by the original proposal.  For me. if the RADIUS server is down for days, then this signifies a fairly catastrophic error.  In that case, the RADIUS clients should arguably stop their connection attempts, because it likely _doesn't_ mean that the RADIUS server is down, it means that the client was misconfigured.",
          "createdAt": "2025-05-25T13:30:59Z",
          "updatedAt": "2025-05-25T13:30:59Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "> I would also be concerned about systems which are affected by the original proposal. For me. if the RADIUS server is down for days, then this signifies a fairly catastrophic error. In that case, the RADIUS clients should arguably stop their connection attempts, because it likely doesn't mean that the RADIUS server is down, it means that the client was misconfigured.\n\nI would be careful with such an assumption. While this might be the case for you, the internet is not monolithic and by restricting the standards beyond reasonable limits, we can have one of two outcomes: Either the standard doesn't get accepted/implemented/used/..., because it causes too much problems or the implementations simply ignore the annoying restrictions.\nNeither outcome is good and what we want.\nI would argue that especially the second case is highly problematic, because implementers may start ignoring requirements that are security relevant and introduce vulnerabilities. (We can't stop them from ignoring requirements, but if we add arbitrary requirements, I suspect the willingness to ignore other requirements would go way up.)\n\nOne use case from the top of my head: An organization has 3 redundant RADIUS servers. For bigger maintenance, one of the servers is taken offline for a longer period of time.\nEverything still works and is redundant, but if the goal is, for example, to perform the maintenance on each of the three servers with, let's say, one week in between, then clients would loose the connection to all three servers, because they would mark the server as dead and not retry.\n\n> Clients already have to (or should) implement the retransmission requirements of RFC 5080. Using the same algorithm here should make it easier to implement. Plus, there is no real reason to have a different algorithm.\n\nNot if the nodes are RADIUS/TLS (or RADIUS/TCP) only, since RADIUS/TLS doesn't have any retransmissions.\nI also gather that the \"retransmission of packets\" code may not translate 1:1 to \"re-opening of sessions\", so it is a non-negligible implementation effort.",
          "createdAt": "2025-05-26T08:25:43Z",
          "updatedAt": "2025-05-26T08:25:43Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On May 26, 2025, at 4:26\u202fAM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> I would be careful with such an assumption. While this might be the case for you, the internet is not monolithic and by restricting the standards beyond reasonable limits, we can have one of two outcomes: Either the standard doesn't get accepted/implemented/used/..., because it causes too much problems or the implementations simply ignore the annoying restrictions.\r\n> Neither outcome is good and what we want.\r\n\r\n  Implementations already ignore many of the requirements of the RFCs.  For me, the standard should define best practices.  That way when implementations do ridiculous things, we can point to the standard and say \"you were told not to do that\".\r\n\r\n  I am very much opposed to watering down the standards, based on a worry that a \"too strong\" standard will be ignored by implementations.  For me, that path gives implementations the ability to do whatever they want, and then to claim standards compliance.\r\n\r\n> I would argue that especially the second case is highly problematic, because implementers may start ignoring requirements that are security relevant and introduce vulnerabilities. (We can't stop them from ignoring requirements, but if we add arbitrary requirements, I suspect the willingness to ignore other requirements would go way up.)\r\n\r\n  That hasn't been my experience.\r\n\r\n> One use case from the top of my head: An organization has 3 redundant RADIUS servers. For bigger maintenance, one of the servers is taken offline for a longer period of time.\r\n> Everything still works and is redundant, but if the goal is, for example, to perform the maintenance on each of the three servers with, let's say, one week in between, then clients would loose the connection to all three servers, because they would mark the server as dead and not retry.\r\n\r\n   I'm OK with allowing the retries to continue forever.  What I don't want is for those retries to occur at a high rate, forever.\r\n\r\n> > Clients already have to (or should) implement the retransmission requirements of RFC 5080. Using the same algorithm here should make it easier to implement. Plus, there is no real reason to > have a different algorithm.\r\n> Not if the nodes are RADIUS/TLS (or RADIUS/TCP) only, since RADIUS/TLS doesn't have any retransmissions.\r\n\r\n  I doubt very much that there will be nodes without RADIUS/UDP.  This isn't a convincing argument.\r\n\r\n> I also gather that the \"retransmission of packets\" code may not translate 1:1 to \"re-opening of sessions\", so it is a non-negligible implementation effort.\r\n\r\n  The re-opening of sessions has to be done on some kind of timer.  The other choices are retry immediately, or never retry.\r\n\r\n  The code to implement any retry timer is negligible, compared to the code required to implement RADIUS/TLS.  So I'm not at all convinced that there's any issue in mandating a retry algorithm.\r\n\r\n  If we don't recommend a sane retry algorithm, then as we've seen, some implementations will retry aggressively.  This pattern has high cost for servers, because they're effectively getting a DoS attack from poor implementations.\r\n\r\n  i.e. implementations which do ridiculous things are passing their costs off to other people.  They're \"saving\" time and money by taking short-cuts, or by doing stupid and anti-social things.  They're costing other people time, effort, and money.\r\n\r\n  There is simply no reason to allow anti-social behavior, based on a worry that mandating \"good behaviour\" would have a cost for the anti-social people.  My opinion here is \"too bad\".",
          "createdAt": "2025-05-26T10:50:01Z",
          "updatedAt": "2025-05-26T10:50:01Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "But there is a difference between\n\"Don't do immediate retries, you MUST implement a backoff algorithm that will do retries at most each 60 seconds after 5 minutes\"\nand\n\"Here is a very specific mandatory-to-implement algorithm for backoff that might not fit what you need and you may already have a different algorithm that matches the goal, but ours it's MTI, so now you have to rewrite\"\n\nI'm not saying that we should ignore this.\nI'm saying that we should specify the minimum requirements for the backoff, such as \n\"There must be a minimum wait time of one second after a failed connection attempt, the interval of retries MUST increase latest after 5 consecutive failed connection attempts, and MUST increase to a minimum of 60 seconds. The maximum interval of retries SHOULD be configurable by the admin\"\n\nThis ensures that we don't have RFC-compliant RADIUS/(D)TLS clients hammering our server, but how exactly it is implemented is still in the discretion of the implementers.\n\nIt doesn't keep us from adding a reference such as \"We RECOMMEND implementing the retry behavior similar to the RADIUS retransmission algorithm in RFC 5080, Section 2.2.1\"",
          "createdAt": "2025-05-26T11:17:52Z",
          "updatedAt": "2025-05-26T11:17:52Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On May 26, 2025, at 7:18\u202fAM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> I'm saying that we should specify the minimum requirements for the backoff, such as\r\n> \"There must be a minimum wait time of one second after a failed connection attempt, the interval of retries MUST increase latest after 5 consecutive failed connection attempts, and MUST increase to a minimum of 60 seconds. The maximum interval of retries SHOULD be configurable by the admin\"\r\n> This ensures that we don't have RFC-compliant RADIUS/(D)TLS clients hammering our server, but how exactly it is implemented is still in the discretion of the implementers.\r\n> It doesn't keep us from adding a reference such as \"We RECOMMEND implementing the retry behavior similar to the RADIUS retransmission algorithm in RFC 5080, Section 2.2.1\"\r\n\r\n  I think that's fine:\r\n\r\n  Implementations MUST do something sane.  They SHOULD implement the following retry behavior.\r\n\r\n",
          "createdAt": "2025-05-26T11:49:06Z",
          "updatedAt": "2025-05-26T11:49:06Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A quick thought about a more nuanced provision whether to give up or not:\n\nIf the connection is configured static and keep permanently up (i.e. no idle timeout), of if there are active radius requests to be sent, don't give up.\nIf there are no more requests to be sent (radius requests have timed out or already sent to another server), (i.e. idle timeout with no outstanding requests), give up trying. Of course, a new attempt may start with a new radius request, but overall retry limitations MUST still apply.",
          "createdAt": "2025-05-29T19:52:36Z",
          "updatedAt": "2025-05-29T19:52:36Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOLrzygc65We8T",
      "title": "Text on Acct-Delay-Time",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/36",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Perhaps move the text on Acct-Delay-Time from Section 4.5.1, which talking about proxies.  Then add a new 4.6:\n\n4.6 Acct-Delay-Time\n\nIn order to avoid congestive collapse, is is RECOMMENDED that RADIUS/\n(D)TLS clients which originate Accounting-Request packets (i.e. not\nproxies) do not include Acct-Delay-Time in those packets. Instead,\nthose clients SHOULD include Event-Timestamp, which is the time at\nwhich the original event occurred. The Event-Timestamp MUST NOT be\nupdated on any retransmissions, as that would both negate the meaning\nof Event-Timestamp, and also create the same problem as with Acct-\nDelay-Time.\n\nNot using Acct-Delay-Time allows for RADIUS/DTLS packets to be retransmitted without change.  In contrast, updating Acct-Delay-Time would require that the client create and send a brand new packet, without signalling the server that the previous packet is no longer active.  This process can occur repeatedly, which leads to multiple different packets containing effectively the same information (except for Acct-Delay-Time).  This duplication contributes to congestive collapse of the network.\n\nNot using Acct-Delay-Time also removes an unambiguity around retransmitted packets for RADIUS/TLS.  Since there is no change to the packet contents when a retransmission timer expires, no new packet ID is allocated, and therefore no new packet is created.\n\nWhere systems do include Acct-Delay-Time in RADIUS/TLS packets, they SHOULD use timers to detect packet loss, as suggested in RFC5080 Section 2.2.1.  However, those timers MUST NOT result in transmission of any packet.  Instead, the timers could be used to log messages indicating that the client is still waiting for a reply, and to determine that packet loss has, in fact, occurred.\n\nAs TLS is a reliable transport, RADIUS/TLS clients can only retransmit a packet if a connection closes without that packet receiving a reply.  See Section 5.1, below, for more discussion of this topic.\n\n",
      "createdAt": "2025-06-02T11:01:25Z",
      "updatedAt": "2025-07-07T15:40:22Z",
      "closedAt": "2025-07-07T15:40:22Z",
      "comments": []
    },
    {
      "number": 37,
      "id": "I_kwDOLrzygc65Wo3t",
      "title": "Packet Expiry timers",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/37",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Not much in the existing text discusses the retransmission timers in RFC 5080 Section 2.2.1.  Perhaps we could add a new section, before the Acct-Delay-Time text mentioned in #36 \n\n4.x Client Timers\n\nRADIUS/(D)TLS clients MUST implement retransmission timers such as the ones which are defined in RFC 5080 Section 2.2.1.  Other methods are possible, but any timer implementation MUST have similar properties of including jitter and exponential backoff.\n\nAs TLS is a reliable transport, RADIUS/TLS clients can only retransmit a packet if a connection closes without that packet receiving a reply. \n Similarly, RADIUS/DTLS can only retransmit packets when it runs over an unreliable transport such as UDP. \n\nWhere RADIUS/(D)TLS runs over a reliable transport, these timers MUST NOT result in transmission of any packet. Instead, the timers could be used to log messages indicating that the client is still waiting for a reply, and to determine that packet loss has, in fact, occurred when RFC 5080 Section 2.2.1 MRD or MRC has been reached.\n\nSee Section 5.1, below, for more discussion of retransmission behavior.\n\n",
      "createdAt": "2025-06-02T11:14:27Z",
      "updatedAt": "2025-07-07T15:41:22Z",
      "closedAt": "2025-07-07T15:41:22Z",
      "comments": []
    },
    {
      "number": 40,
      "id": "I_kwDOLrzygc7BDH2b",
      "title": "DTLS session tracking",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/40",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per the comments on the mailing list, maybe the session tracking for DTLS can be reworded to allow different session tracking mechanisms.\n\nCurrently, the draft contains this in section 6.4:\n> Implementations may choose to use the method described here, or another, equivalent method.\n\nMaybe with this, the concerns are already met, maybe we should capitalize the \"may\", so it is a proper BCP14 \"MAY\"",
      "createdAt": "2025-07-17T09:23:19Z",
      "updatedAt": "2025-07-22T10:20:16Z",
      "closedAt": "2025-07-22T10:20:16Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Should be fixed in 8d566da",
          "createdAt": "2025-07-20T12:57:21Z",
          "updatedAt": "2025-07-20T12:57:21Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "As per the discussion in the WG session at IETF 123, I'm closing this. Feel free to re-open if the text is not sufficient.",
          "createdAt": "2025-07-22T10:20:16Z",
          "updatedAt": "2025-07-22T10:20:16Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOLrzygc7BF4x4",
      "title": "DTLS retransmissions",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/42",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When reading through the document, I noticed that in Section 6.4 we mandate a behavior for retransmissions on the server side.\nIf the server received a retransmission of a RADIUS request and already has an answer cached, it MUST re-process that cached answer through DTLS instead of just caching the DTLS record and re-sending that one.\n\nThis opens up two questions:\n\n* Why are we mandating this behavior only for servers and not for clients and their retransmissions?\n* Is this even right?\n\nRFC 9147 (DTLS 1.3), section 4.2.1 (DTLS Record Layer -> Seq Nr and Epoch -> Processing Guidelines) states:\n> Implementations MUST send retransmissions of lost messages using the same epoch and keying material as the original transmission.\n\nWe need to find out, whether or not RADIUS packet retransmissions are also included in the DTLS's definition of a retransmission.",
      "createdAt": "2025-07-17T13:10:15Z",
      "updatedAt": "2025-08-21T23:25:02Z",
      "closedAt": "2025-08-21T23:25:02Z",
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IIRC, the text for servers was the result of discussions with people familiar with DTLS.  But we should double-check this, and use a consistent approach.\n\ni.e. either DTLS sends exactly the same packet for retransmissions of application data (both client and server).  Or, DTLS sends new packets for retransmissions of application data (both client and server).\n\nChecking the DTLS RFCs, they discuss retransmissions during the handshake phase.  But they have no discussion about the application layer protocol.  The entire contents of RFC9147 related to the application data protocol is [Section 10](https://datatracker.ietf.org/doc/html/rfc9147#name-application-data-protocol), which I reproduce here in its entirety:\n\n```\nApplication data messages are carried by the record layer and are split into records and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.\n```",
          "createdAt": "2025-07-17T13:34:10Z",
          "updatedAt": "2025-07-17T13:34:10Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And commenting in 4.2.1:\n\n> Implementations MUST send retransmissions of lost messages using the same epoch and keying material as the original transmission.\n\nThe implication would be that the retransmitting a lost application message would mean sending a new DTLS message.  We will have to clarify this with the TLS people",
          "createdAt": "2025-07-17T13:36:01Z",
          "updatedAt": "2025-07-17T13:36:01Z"
        },
        {
          "author": "TheEnbyperor",
          "authorAssociation": "NONE",
          "body": "To copy from the discussion in the 123 WG:\n\nRetransmission in DTLS is retransmission for DTLS' own purposes, i.e. to maintain a lock-step handshake. Retransmission of application layer data is of no concern to DTLS. Thus, the current behaviour should be mandated for both clients and servers, and is the correct behaviour. ",
          "createdAt": "2025-07-22T08:12:36Z",
          "updatedAt": "2025-07-22T08:12:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Should be fixed with #49 ",
          "createdAt": "2025-08-21T23:25:02Z",
          "updatedAt": "2025-08-21T23:25:02Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOLrzygc7Cg-cf",
      "title": "Certificate Lifetimes",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/46",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "PR exists",
        "WGLC Comment"
      ],
      "body": "The text should probably say that connections MUST respect certificate expiry times.  If the certificate is no longer valid, then the connection needs to be torn down.",
      "createdAt": "2025-07-25T14:28:50Z",
      "updatedAt": "2025-09-11T09:42:58Z",
      "closedAt": "2025-09-11T09:42:58Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "The current draft has a SHOULD for reassessing the trust on trust base changes (such as CRL updates), so I would recommend also making this a SHOULD.\n\nThere could be reasons why one would use a short-lived certificate (e.g. 90 days Let'sEncrypt), but may still be fine with long-standing connections beyond the certificate's life span.\nFor renegotiation, the rules would then require a certificate update, since the old certificate would then fail the check.",
          "createdAt": "2025-08-15T12:48:36Z",
          "updatedAt": "2025-08-15T12:48:36Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we're OK with a `SHOULD`.  Some other applications allow connections to remain open, even after the certificate has expired.  ",
          "createdAt": "2025-08-15T14:22:30Z",
          "updatedAt": "2025-08-15T14:22:30Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #48 is merged, so I'm closing this issue.",
          "createdAt": "2025-09-11T09:42:58Z",
          "updatedAt": "2025-09-11T09:42:58Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOLrzygc7IOoho",
      "title": "Missing text on allowed packets (needed for Reverse CoA)",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/51",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "question",
        "PR exists",
        "WGLC Comment"
      ],
      "body": "The document is missing text on which packets are allowed to be processed on what port.  Likely we can just copy everything from 6614:\n\nhttps://datatracker.ietf.org/doc/html/rfc6614#section-2.5\n\nThe reverse CoA document needs this section, to replace an existing reference to RFC6614, Section 2.5.  The IESG review is that the reverse CoA document should reference this one, and not 6614 / 7360.",
      "createdAt": "2025-08-27T13:00:37Z",
      "updatedAt": "2025-09-30T14:06:22Z",
      "closedAt": "2025-09-30T14:06:22Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I deliberately left out the list of packet types, because it didn't add any value (esp. since the list was not exhaustive).\nBut we can add the CoA part.",
          "createdAt": "2025-09-11T09:37:02Z",
          "updatedAt": "2025-09-11T09:37:02Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "After looking at it again: We have text in https://radext-wg.github.io/draft-ietf-radext-radiusdtls-bis/draft-ietf-radext-radiusdtls-bis.html#name-radius-datagrams\n\nWhat exactly is needed from 6614 Section 2.5 for the Reverse CoA Document?",
          "createdAt": "2025-09-11T09:50:54Z",
          "updatedAt": "2025-09-11T09:50:54Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Hopefully fixed with merging of #55 \n\nIf not, please re-open.",
          "createdAt": "2025-09-30T14:06:22Z",
          "updatedAt": "2025-09-30T14:06:22Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOLrzygc7IOthM",
      "title": "Event-Timestamp",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/52",
      "state": "CLOSED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs discussion",
        "WGLC Comment"
      ],
      "body": "Minor typo in https://datatracker.ietf.org/doc/html/draft-ietf-radext-radiusdtls-bis-08#name-acct-delay-time-and-event-t  `Timestap`\n\nThe text in that section doesn't say what a server / proxy should do if it receives a packet which is missing both Event-Timestamp, and Acct-Delay-Time.  Perhaps:\n\nA server receiving an Accounting-Request packet which is missing both Event-Timestamp and Acct-Delay-Time MUST assume that the time of the referenced event is the time when the packet was received.  A proxy SHOULD add an Event-Timestamp to the packet with that value before proxying it.  Adding this value ensures that delays due to transport problems or retransmissions do not affect subsequent servers which receive this packet.  A proxy MAY also add Event-Timestamp, even if the packet contains Acct-Delay-Time.",
      "createdAt": "2025-08-27T13:07:27Z",
      "updatedAt": "2025-09-11T10:27:35Z",
      "closedAt": "2025-09-11T10:27:35Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Typo is fixed, thanks.\n\nFor the other part: I would argue that this definitely isn't something that's DTLS/TLS specific, so it shouldn't be part of this document but instead of the proxy BCP document.",
          "createdAt": "2025-09-11T09:40:02Z",
          "updatedAt": "2025-09-11T09:40:02Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that's fine.  In the interest of moving this document forward, I'll close this issue.\n\nAlso another typo `In conctrast ...`",
          "createdAt": "2025-09-11T10:27:35Z",
          "updatedAt": "2025-09-11T10:27:35Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOLrzygc7VRJPU",
      "title": "Remove Appendices",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/63",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "The appendices may not be suitable for a standards-track document.\nMaybe we could remove them, shorten them, ...\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/KkYANOs3hdGn0TIDCmEyTkPwZwY/)\n\nesp. eduroam is already documented in RFC 7593",
      "createdAt": "2025-11-01T14:04:21Z",
      "updatedAt": "2025-11-05T20:02:04Z",
      "closedAt": "2025-11-05T20:02:04Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Removed with #83 ",
          "createdAt": "2025-11-05T20:02:00Z",
          "updatedAt": "2025-11-05T20:02:00Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "I_kwDOLrzygc7VRLhb",
      "title": "Move Section \"Detecting Live Servers\"",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/64",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "The section \"Detecting Live Servers\" should be moved somewhere else.\n\nAdditionally, the section should be more clear on whether it only applies to proxies or also to simple one-hop client-server setups.\n\nSuggestion was to add a \"Proxy Considerations\" section.\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/uOv_eU_Zo1m0D96UP4TkfRAIaak/)",
      "createdAt": "2025-11-01T14:12:32Z",
      "updatedAt": "2025-11-01T14:12:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 65,
      "id": "I_kwDOLrzygc7VROKq",
      "title": "RFC 2119 language in Security Considerations sections",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/65",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "Section 7.6 \"Migrating from RADIUS/UDP to RADIUS/(D)TLS\" contains some RFC 2119 language. We need to check if some of this should be moved to other sections, to not have normative specifications in the Security Considerations section.\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/g5fCq-_3yXRW2gHfnsdgkJWk3ME/)",
      "createdAt": "2025-11-01T14:21:27Z",
      "updatedAt": "2025-11-01T14:21:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 66,
      "id": "I_kwDOLrzygc7VRPeO",
      "title": "Move or remove section \"Changes from RFC6614/7360\"",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/66",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "Section 1.2 \"Changes from RFC6614 (RADIUS/TLS) and RFC7360 (RADIUS/DTLS)\" should mabye be moved from the introduction section to somewhere else, since this doc is supposed to be a standalone spec without any ties to the previous one.\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/VVMzZXdELn1k0qbkwexLrRvhRfM/)\n\nMy opinion: The section should still be included in the document, but maybe as Appendix or later in the document to help people already implementing 6614/7360 to update their implementations to the new doc.",
      "createdAt": "2025-11-01T14:27:53Z",
      "updatedAt": "2025-12-22T15:56:49Z",
      "closedAt": "2025-12-22T15:56:48Z",
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "the section was moved to an appendix, so I'm closing this issue.",
          "createdAt": "2025-12-22T15:56:48Z",
          "updatedAt": "2025-12-22T15:56:48Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOLrzygc7VRP8j",
      "title": "Change section title \"Changes to RADIUS\"",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/67",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "Section 3 has the title \"Changes to RADIUS\"\nThis title might be misleading, since we don't change RADIUS/UDP.\n\nSuggestion from Margaret: \"RADIUS differences between RADIUS/TLS and RADIUS/UDP\"\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/VVMzZXdELn1k0qbkwexLrRvhRfM/)",
      "createdAt": "2025-11-01T14:30:20Z",
      "updatedAt": "2025-11-01T14:30:20Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOLrzygc7VRR78",
      "title": "Clarify section \"Duplicates and Retransmissions\"",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/68",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "The last paragraph of section 5.2 \"Duplicates and Retransmissions\" is not clear enough.\nWe need to revise it to make it more clear what we mean.\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/yERxr_ZmkCeTMxBBpt-R4p5Q-TY/)",
      "createdAt": "2025-11-01T14:40:53Z",
      "updatedAt": "2025-11-01T14:40:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 69,
      "id": "I_kwDOLrzygc7VRS_M",
      "title": "Clarify Head of Line Blocking and TCP delays",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/69",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "In Section 5.3 \"TCP Applications Are Not UDP Applications\", we talk about Head-of-Line blocking and possible transmission delays in TCP.\nThis text should maybe be reworded to make it more clear what we mean.\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/t6wnjMLE2uKGjSR3dlglstzx9ts/)",
      "createdAt": "2025-11-01T14:46:31Z",
      "updatedAt": "2025-11-01T14:46:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 70,
      "id": "I_kwDOLrzygc7VRTVE",
      "title": "New section \"Implementation Considerations\" ?",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/70",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "The document has some text that talks about implementation details.\nMaybe it is worth consolidating all these texts in a new \"Implementation Considerations\" section.\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/2FBd89X0-eI0BFm8OJi4_FgL2Vs/)",
      "createdAt": "2025-11-01T14:48:25Z",
      "updatedAt": "2025-11-01T14:48:25Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 71,
      "id": "I_kwDOLrzygc7VRTo2",
      "title": "Revisit Path-MTU Discovery",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/71",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "Section 6.4.2 \"Client Session Management\" in the DTLS-specific section talks about PMTU discovery.\nThere may be some issues with this, we should revisit it.\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/DeaIod0aX4FSlP1lIDGoPIgiUeA/)",
      "createdAt": "2025-11-01T14:50:11Z",
      "updatedAt": "2025-11-01T14:50:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 72,
      "id": "I_kwDOLrzygc7VRT6q",
      "title": "Mention of RFC 8900",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/72",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "PR exists",
        "Shepherd Comment"
      ],
      "body": "Since we deal with UDP and UDP fragmentation, we might want to mention [RFC 8900](https://www.rfc-editor.org/rfc/rfc8900.html) (\"IP Fragmentation Considered Fragile\").\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/wgGA7vwQOhanfak2WBWJoX8EUYA)",
      "createdAt": "2025-11-01T14:51:50Z",
      "updatedAt": "2025-11-02T16:53:33Z",
      "closedAt": "2025-11-02T16:53:33Z",
      "comments": []
    },
    {
      "number": 73,
      "id": "I_kwDOLrzygc7VRUJ-",
      "title": "Mandatory exponential back-off",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/73",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "PR exists",
        "Shepherd Comment"
      ],
      "body": "Should we require an exponential back-off for reconnection attempts?\n\n[Post on radext ML](https://mailarchive.ietf.org/arch/msg/radext/O_KfVjexiWZpdkXYcGDpNg3eRS4/)",
      "createdAt": "2025-11-01T14:53:11Z",
      "updatedAt": "2025-11-02T17:07:52Z",
      "closedAt": "2025-11-02T17:07:52Z",
      "comments": []
    },
    {
      "number": 76,
      "id": "I_kwDOLrzygc7VXPq5",
      "title": "Clarify that the TCP and UDP are the only transport protocols this draft discusses",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/76",
      "state": "OPEN",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This draft could be a more specific to say that:\n\n- RADIUS/TLS is RADIUS/TLS/TCP; and\n- RADIUS/DTLS is RADIUS/DTLS/UDP\n\nThis is to clarify that SCTP, QUIC and other transports are not implicitly included just because TLS or DTLS can run on top, or within, them.\n\nAn example: Quoting DTLS 1.3 RFC, section [4.4](https://www.rfc-editor.org/rfc/rfc9147.html#section-4.4-4)\n\n> For DTLS over UDP, the upper layer protocol SHOULD be allowed to obtain the PMTU estimate maintained in the IP layer.\nFor DTLS over **DCCP**, the upper layer protocol SHOULD be allowed to obtain the current estimate of the PMTU.\nFor DTLS over **TCP** or **SCTP**, which automatically fragment and reassemble datagrams, there is no PMTU limitation. However, the upper layer protocol MUST NOT write any record that exceeds the maximum record size of 2^14 bytes.\n\n",
      "createdAt": "2025-11-02T15:15:44Z",
      "updatedAt": "2025-11-03T17:36:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "It's already included in the abstract, but maybe worth keeping in mind when reading through the document again, to see if we can add this at another point in the document as well to be absolutely clear.",
          "createdAt": "2025-11-02T16:44:41Z",
          "updatedAt": "2025-11-02T16:44:41Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOLrzygc7VnCaq",
      "title": "Immediately closing a resumed session",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/85",
      "state": "OPEN",
      "author": "meadmaker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft says:\n\n> If a resumed session is closed immediately after being established, the RADIUS/(D)TLS client MUST NOT re-attempt session resumption but perform a full TLS handshake instead.\n\nWhat does it mean to be \"closed immediately\"?  Is that counted by a certain amount of time?  Is that counted by the number of messages exchanged after the session establishment?",
      "createdAt": "2025-11-03T21:14:23Z",
      "updatedAt": "2025-11-03T21:14:23Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 87,
      "id": "I_kwDOLrzygc7Vz7C7",
      "title": "Absolute lower and upper bounds for reconnection backoff?",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/87",
      "state": "OPEN",
      "author": "meadmaker",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 4.7.1 holds:\n\n> If a different algorithm is used, it SHOULD include a configurable lower and upper bound for the time between retries, a configurable timeout after which the client gives up reconnecting and a jitter.\n\nWould it be good to specify an absolute lower and upper bound for the delay?",
      "createdAt": "2025-11-04T15:46:48Z",
      "updatedAt": "2025-11-04T15:46:48Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 99,
      "id": "I_kwDOLrzygc7Wonyw",
      "title": "Remove TLS-X509-FINGERPRINT trust model",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/99",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "No one implements this (to our knowledge) and this is copied from 6614.\nI think it's safe to throw it out.",
      "createdAt": "2025-11-07T16:01:26Z",
      "updatedAt": "2025-11-08T21:33:24Z",
      "closedAt": "2025-11-08T21:33:24Z",
      "comments": [
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With OpenSSL you can do it with [X509_digest](https://docs.openssl.org/master/man3/X509_digest/) which Radiator supports for additional checks of TLS connections in general. That is, they can be used from OpenSSL verify callback that runs after the basic CA chain and other checks. I am not aware of anyone using it with RadSec as a replacement of certificate chain check and the text describing it is very general in any case.",
          "createdAt": "2025-11-07T19:33:12Z",
          "updatedAt": "2025-11-07T19:54:48Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "I_kwDOLrzygc7Wo4Ak",
      "title": "Cleanup after Protocol-Error change to MAY",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/issues/100",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the \"Differences from 6614 handling\" there should maybe be a paragraph explaining why the 6614 behavior is not breaking stuff and why we make protocol error optional.\n\nTo summarize quickly:\n* 6614 behavior bad, synthesize responses when not authoritative\n* Protocol-Error still in development as of time writing, we expect this to change\n* Doing nothing for now is better than reverting to 6614 behavior",
      "createdAt": "2025-11-07T16:19:21Z",
      "updatedAt": "2025-11-07T16:19:21Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOLrzygc5sWeGl",
      "title": "Add text around Server Name Indication",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/1",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "SNI was not part of RFC6614 or RFC7360.\r\n\r\nThis is possibly breaking backwards compatibility, so I don't want to change this without a discussion within the WG.\r\n\r\nThis Pull Request can be used to comment on aspects of the text.",
      "createdAt": "2024-04-11T11:54:05Z",
      "updatedAt": "2025-08-15T16:37:01Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "97c3d68c2250b7970014b23aa2793f1de3d88ea5",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_server_name_indication",
      "headRefOid": "7d83c0346f5b7c8cbe4f49fa2280f16c872d11fd",
      "closedAt": "2025-04-10T15:11:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "With the changes in the document and the consensus that all proxy and load balancing related topics are out of scope for this document, I'm closing this pull request.",
          "createdAt": "2025-04-10T15:11:25Z",
          "updatedAt": "2025-04-10T15:11:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc523DiS",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:07:24Z",
          "updatedAt": "2024-04-11T13:07:24Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "TLS servers _may_ be hidden behind a load balancer.",
              "createdAt": "2024-04-11T13:07:24Z",
              "updatedAt": "2024-04-11T13:07:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523E9V",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:10:09Z",
          "updatedAt": "2024-04-11T13:10:10Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "What about 7585, where the destination IP isn't known in advance?\r\n\r\nI think it's preferable to base server identity on the presented server credentials.  i.e. the certificate, and not any IP/port information.\r\n\r\nThat is, we have multiple connections to the same server certificate (or similar certificate identification fields), then the client should treat all of those connections as being similar.",
              "createdAt": "2024-04-11T13:10:09Z",
              "updatedAt": "2024-04-11T13:10:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523FKx",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:10:32Z",
          "updatedAt": "2024-04-11T13:10:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This seems backwards to me?  Is this a typo, or am I missing something?",
              "createdAt": "2024-04-11T13:10:33Z",
              "updatedAt": "2024-04-11T13:10:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523GPL",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:12:34Z",
          "updatedAt": "2024-04-11T13:12:34Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It's less about SNI than presented certificate, I think.  The distinction is important.\r\n\r\nOnce a client verifies the server identity (and that it matches the SNI), then it's possible to put all similar connections into a connection pool.  And it's OK to key that off of the SNI string, but I think it should be clear that it's being based off of the _identity_ , and not the SNI.",
              "createdAt": "2024-04-11T13:12:34Z",
              "updatedAt": "2024-04-11T13:12:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc523G8C",
          "commit": {
            "abbreviatedOid": "7d83c03"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T13:13:52Z",
          "updatedAt": "2024-04-11T13:13:52Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I'm not clear how a server can \"distinguish clients\" by SNI.  Perhaps instead just \"present different identities to clients based on SNI\". ",
              "createdAt": "2024-04-11T13:13:52Z",
              "updatedAt": "2024-04-11T13:13:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc52_KIR",
          "commit": {
            "abbreviatedOid": "7d83c03"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-12T09:00:49Z",
          "updatedAt": "2024-04-12T09:00:49Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "How about this:\r\n\r\n```suggestion\r\nBy adding Server Name Indication, a RAIDUS/(D)TLS server can now provide different services (i.e. access to different roaming consortia) under the same destination IP address and port, or could present different certificates to clients or apply specific policies depending the server name the clients use in the SNI extension of the TLS Client Hello.\r\n```",
              "createdAt": "2024-04-12T09:00:49Z",
              "updatedAt": "2024-04-12T09:00:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc52_Mli",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-12T09:04:45Z",
          "updatedAt": "2024-04-12T09:04:45Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "See discussion on the ML on that one:\r\nhttps://mailarchive.ietf.org/arch/msg/radext/pX1cn_RnaRnqeu5MBXc-sohK_SQ",
              "createdAt": "2024-04-12T09:04:45Z",
              "updatedAt": "2024-04-12T09:04:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc52_NCK",
          "commit": {
            "abbreviatedOid": "d7a8074"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-12T09:05:44Z",
          "updatedAt": "2024-04-12T09:05:45Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nFor RADIUS/(D)TLS, this distinction is not that simple, i.e. because different RADIUS servers may be hidden behind a load balancer with one public IP address, and the load balancer dispatches the connections based on the Server Name Indication in the first TLS handshake record.\r\n```",
              "createdAt": "2024-04-12T09:05:44Z",
              "updatedAt": "2024-04-12T09:05:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc53B5ys",
          "commit": {
            "abbreviatedOid": "7d83c03"
          },
          "author": "mcr",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-12T13:18:09Z",
          "updatedAt": "2024-04-12T13:18:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOLrzygc5v_-MV",
      "title": "try to address proxying issues.  Helps with #2",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/3",
      "state": "MERGED",
      "author": "alandekok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "My initial stab at addressing the proxying issues.",
      "createdAt": "2024-05-20T20:26:01Z",
      "updatedAt": "2025-07-17T12:13:19Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "0e3b595bd851c9e1fcf4e0bd227f269f8609754e",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "issue2",
      "headRefOid": "5d64d5f3f674c55f0e4f9293f3388898d3566bbc",
      "closedAt": "2024-07-08T17:49:21Z",
      "mergedAt": "2024-07-08T17:49:21Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "36cab8101d92b069730f390e8251f3f2a44d5ea1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "PR_kwDOLrzygc52L816",
      "title": "apply RFC9525 guidance for validating certificate identities",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/4",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "RFC9525 provides guidance on what/how to specify certificate identity validation. This PR applies those rules and references RFC9525 explicitly. \r\n\r\nIn addition the NAIrealm identity is generalized as it might be applied outside dynamic discovery.",
      "createdAt": "2024-07-23T09:00:17Z",
      "updatedAt": "2024-10-21T19:08:57Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-rfc9525-guidance",
      "headRefOid": "503d39d9a9e9b1ea9b6d604f5c3fcb2cfc9c5252",
      "closedAt": "2024-10-21T19:04:59Z",
      "mergedAt": "2024-10-21T19:04:59Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "b99af9528e8a20cbc246789eedb9e09ba502350a"
      },
      "comments": [
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the 'Selfie attack' discussion on the radext mailing list, this prposal might need an update too, related to omitting the identity check... ",
          "createdAt": "2024-07-25T11:20:15Z",
          "updatedAt": "2024-07-25T11:20:15Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "NONE",
          "body": "In regards to wildcard certificates, [RFC 9525](https://www.rfc-editor.org/rfc/rfc9525.html#name-matching-the-dns-domain-nam) talks about clients matching server wildcard certificate. How clear do we need to be about wildcard certificate use? For example, if software uses a wildcard certificate for accepting (D)TLS connections it must use a different non-wildcard certificate when it initiates a (D)TLS connections.",
          "createdAt": "2024-10-04T17:16:33Z",
          "updatedAt": "2024-10-04T17:16:33Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I will leave this PR open until we have finished the discussion on the selfie/loopback/... attack, to keep it visible.\r\n\r\nThe other text is merged with #19 ",
          "createdAt": "2024-10-21T19:02:21Z",
          "updatedAt": "2024-10-21T19:02:21Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "apparently github thinks that once a commit is merged in a different pull request, this one should be closed too. I'm sorry. I don't think that I can re-open it, so it still appears in the open PR list.\r\nI'll keep this PR in mind for further discussions.",
          "createdAt": "2024-10-21T19:08:56Z",
          "updatedAt": "2024-10-21T19:08:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L8fUz",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:02:38Z",
          "updatedAt": "2024-10-04T12:02:38Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "As per Russ' comments in his [secdir early review](https://mailarchive.ietf.org/arch/msg/radext/LMeW527YwDyovkhP-_2VwmAT_Fk) this needs to be adjusted.\r\n\r\nI've tried to change the wording here as one example, I'm not sure if this is correct.\r\nWe should probably get confirmation from folks that this is in fact correct to say.\r\n\r\n```suggestion\r\n  - If the expected RADIUS/(D)TLS server is associated with a specific NAI realm, e.g. by dynamic discovery {{!RFC7585}} or static configuration, that realm is matched against any naiRealm label contained in the subjectAltName extension.\r\n```",
              "createdAt": "2024-10-04T12:02:38Z",
              "updatedAt": "2024-10-04T12:02:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L8gGw",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:04:23Z",
          "updatedAt": "2024-10-04T12:04:23Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n  - If the expected RADIUS/(D)TLS server was configured as a hostname, or the hostname was yielded by a dynamic discovery procedure, the configured name is matched against the presented names from the subjectAltName:DNS extension. Since a dynamic discovery might by itself not be secured, implementations MAY require the use of DNSSEC {{!RFC4033}} to ensure the authenticity of the DNS result before considering this identity as valid. \r\n```\r\n\r\nJust for clarity.",
              "createdAt": "2024-10-04T12:04:23Z",
              "updatedAt": "2024-10-04T12:04:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L8hlV",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:07:48Z",
          "updatedAt": "2024-10-04T12:07:48Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I would be more explicit here, because the \"without doing so\" is a bit vague.\r\nWhat is it exactly that we mean? Is it sufficient that the client checks the \"issuer\" attribute of the certificate?\r\nWhy is this sentence of looping just here? The loop attack could possibly also happen with other scenarios (like DNS without DNSSEC and the NAPTR just points back to the server)",
              "createdAt": "2024-10-04T12:07:48Z",
              "updatedAt": "2024-10-04T12:07:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L8iLS",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:09:03Z",
          "updatedAt": "2024-10-04T12:09:03Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n  * If configured by the administrator, the identity check MAY be omitted after a successful {{RFC5280}} trust chain check, e.g. if the client used dynamic lookup there is no configured client identity to verify. The clients authorization MUST then be validated using a certificate policy OID unless both peers are part of a trusted network.\r\n```\r\n(just two typos)",
              "createdAt": "2024-10-04T12:09:03Z",
              "updatedAt": "2024-10-04T12:09:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L-biJ",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T15:51:42Z",
          "updatedAt": "2024-10-04T15:51:42Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The intention here is that a client MUST identy the server by any element that clearly identifies it. I think this includes subject, subjectAltNames, issuer+certificate serial (but not the issuer by itself).\r\n\r\nThe loop attack refers to the same issue we discussed regarding TLS-PSK, that an attacker could loop the TLS packets (without decrypting them) back to the client and it would accept that connection (if it generally accepts incomming connections, i.e. proxies).",
              "createdAt": "2024-10-04T15:51:42Z",
              "updatedAt": "2024-10-04T15:51:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L-gzS",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T16:03:32Z",
          "updatedAt": "2024-10-04T16:03:32Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Thanks for the heads-up. I will try to incorporate Russ' feedback. Have to check RFC9525 again, maybe it already suggests the correct wording.",
              "createdAt": "2024-10-04T16:03:32Z",
              "updatedAt": "2024-10-04T16:03:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L_Xk8",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T17:18:24Z",
          "updatedAt": "2024-10-04T17:18:24Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I have two points here:\r\nFirst, the text should explicitly state something like \"Clients MUST NOT accept any certificate without validating at least something\" instead of the general \"without doing so\"\r\nSecond, the Loop attack is a general attack, so maybe it is worth to put it in security considerations, have a few words here about it and then reference the security considerations section for details?",
              "createdAt": "2024-10-04T17:18:24Z",
              "updatedAt": "2024-10-04T17:18:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MLBps",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T11:39:14Z",
          "updatedAt": "2024-10-07T11:39:14Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "agreed to both points. This was as a last minute addition anyway, after it got mentioned in the TLS-PSK context.",
              "createdAt": "2024-10-07T11:39:14Z",
              "updatedAt": "2024-10-07T11:39:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MYtRg",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T18:52:59Z",
          "updatedAt": "2024-10-08T18:52:59Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": ">  Second, the Loop attack is a general attack, so maybe it is worth to put it in security considerations, have a few words here about it and then reference the security considerations section for details?\r\n\r\nOne workaround would be to check that the client/server random (in OpenSSLese, `SSL_get_client_random` and `SSL_get_server_random`) do not match.",
              "createdAt": "2024-10-08T18:52:59Z",
              "updatedAt": "2024-10-08T18:52:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MsyYP",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-10T14:24:36Z",
          "updatedAt": "2024-10-10T14:24:36Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "don't know how exactly client/server random works, but even experimentally, I'm struggling to see how this would work.\r\n\r\nIf I call `get_client_random` and `get_server_random` both on the connecting and accepting side of a tls connection, I actually get 4 different values, even when both sides run in the same process and use the same ssl context.\r\n\r\nAm I missing something?",
              "createdAt": "2024-10-10T14:24:36Z",
              "updatedAt": "2024-10-10T14:24:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MtVDT",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-10T15:12:16Z",
          "updatedAt": "2024-10-10T15:12:16Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> don't know how exactly client/server random works, but even experimentally, I'm struggling to see how this would work.\r\n> \r\n> If I call `get_client_random` and `get_server_random` both on the connecting and accepting side of a tls connection, I actually get 4 different values, even when both sides run in the same process and use the same ssl context.\r\n> \r\n> Am I missing something?\r\n\r\nThe first four bytes is the `gmt_unix_time` (legacy, and I think now purely random) when shown in `openssl s_client ...`, so that may be it, otherwise Works for Me(tm).\r\n\r\nApply the ghetto patch to https://github.com/openssl/openssl/tree/master/demos/sslecho, compile and run `sslecho s`:\r\n```\r\ndiff --git a/demos/sslecho/main.c b/demos/sslecho/main.c\r\nindex eec8e13a47..b4fca946cd 100644\r\n--- a/demos/sslecho/main.c\r\n+++ b/demos/sslecho/main.c\r\n@@ -7,6 +7,7 @@\r\n  *  https://www.openssl.org/source/license.html\r\n  */\r\n \r\n+#include <assert.h>\r\n #include <stdio.h>\r\n #include <unistd.h>\r\n #include <string.h>\r\n@@ -213,6 +214,18 @@ int main(int argc, char **argv)\r\n \r\n                 printf(\"Client SSL connection accepted\\n\\n\");\r\n \r\n+                unsigned char random[32];\r\n+                assert(SSL_get_client_random(ssl, random, sizeof(random)) == sizeof(random));\r\n+                printf(\"client random: \");\r\n+                for (int i = 0; i < sizeof(random); i++)\r\n+                    printf(\"%02X\", random[i]);\r\n+                printf(\"\\n\");\r\n+                assert(SSL_get_server_random(ssl, random, sizeof(random)) == sizeof(random));\r\n+                printf(\"server random: \");\r\n+                for (int i = 0; i < sizeof(random); i++)\r\n+                    printf(\"%02X\", random[i]);\r\n+                printf(\"\\n\");\r\n+\r\n                 /* Echo loop */\r\n                 while (true) {\r\n                     /* Get message from client; will fail if client closes connection */\r\n```\r\n\r\nAs the client run `openssl s_client -trace -connect localhost:4433`:\r\n```\r\nCONNECTED(00000003)\r\nSent Record\r\nHeader:\r\n  Version = TLS 1.0 (0x301)\r\n  Content Type = Handshake (22)\r\n  Length = 292\r\n    ClientHello, Length=288\r\n      client_version=0x303 (TLS 1.2)\r\n      Random:\r\n        gmt_unix_time=0x919DE39C                                                                <----\r\n        random_bytes (len=28): 97E42A6040AD6B9FA248D29B5C2C153E3F92AD9E14412CB875F8BF78         <----\r\n      session_id (len=32): 1557C0A035FB2A3DF97F5067FC534FC9E71BC106FB929E823A998467C893C6A0\r\n      cipher_suites (len=62)\r\n\r\n[snipped]\r\n\r\nReceived Record\r\nHeader:\r\n  Version = TLS 1.2 (0x303)\r\n  Content Type = Handshake (22)\r\n  Length = 122\r\n    ServerHello, Length=118\r\n      server_version=0x303 (TLS 1.2)\r\n      Random:\r\n        gmt_unix_time=0x99B5F850                                                              <----\r\n        random_bytes (len=28): 30BCD49D1F53AFE61C5A63B16AD7FABE3B444EEE5D1093D78E878639       <----\r\n      session_id (len=32): 1557C0A035FB2A3DF97F5067FC534FC9E71BC106FB929E823A998467C893C6A0\r\n      cipher_suite {0x13, 0x02} TLS_AES_256_GCM_SHA384\r\n      compression_method: No Compression (0x00)\r\n\r\n[snipped]\r\n```\r\n\r\nThe output I got matched.\r\n\r\nI am assuming this works in during the pre-establish handshake phase? That I did not test...",
              "createdAt": "2024-10-10T15:12:16Z",
              "updatedAt": "2024-10-10T15:19:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6M_HE6",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T05:48:44Z",
          "updatedAt": "2024-10-14T05:48:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Thanks for the detailed explanation; looks like I goofed up my experiment.\r\n\r\nSo yes, one could compare client/server randoms, but upon opening (or accepting) a connection, you would have to compare its random to verey other TLS connection. I.e. the client and server random of a single conneciton are always different (I guess as they should be for security reasons)",
              "createdAt": "2024-10-14T05:48:44Z",
              "updatedAt": "2024-10-14T05:48:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6NAK4T",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T07:36:44Z",
          "updatedAt": "2024-10-14T07:36:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I think you only need to limit the check window to the pool of the systems own not-yet-established TLS connections, as those connections have to come from yourself and be pending for this attack to work, right?",
              "createdAt": "2024-10-14T07:36:44Z",
              "updatedAt": "2024-10-14T07:37:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N6xzG",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T06:00:21Z",
          "updatedAt": "2024-10-21T06:00:22Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yes, but still this might be tricky to implement for the exact timing and potential race-conditions. After all the client and server side code very intentionally run at the same time. ",
              "createdAt": "2024-10-21T06:00:21Z",
              "updatedAt": "2024-10-21T06:00:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N74e_",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T08:20:55Z",
          "updatedAt": "2024-10-21T08:20:55Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "During the client hello callback (`SSL_CTX_set_client_hello_cb`) the connection is not established and the server side is yet to fully process the request.\r\n\r\nMaybe I am missing something, I do not see a race. If there was, you would be unable to use this function to select a server certificate (ie. ALPN) which is one of the primary use cases for it.\r\n\r\nIt does become slightly more complicated if the 'server' is actually a pool of nodes, but all that would require is an RPC call out to the other nodes to see what connections are outstanding.\r\n\r\nMeanwhile the connection under inspection is frozen in time until the callback completes.\r\n\r\nCan you think of a situation where this fails?\r\n\r\nI am only lobbying for it, as if this is a good defence (which implementing aside we still do not know) it is trivial to implement. Helping us is the connection pool churn is low and so the length of the list of being established in flight TLS connections is low (ie. less than 1000).",
              "createdAt": "2024-10-21T08:20:55Z",
              "updatedAt": "2024-10-21T08:20:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N8xqj",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T09:53:47Z",
          "updatedAt": "2024-10-21T09:53:47Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Its two threads (or more, at least for me) and a network connection, which for me always puts on the warning light, be careful. There can always be events from the network (timeouts, a connecting being closed) and the race conditions may arise when two legitimate connections happen a the same time. In the end one thread has to access data from another, which requires careful coordination.\r\n\r\nI do agree that it's a good idea and definitely worth a shot, I just anticipate that its not going to be as trivial to implement as at first glance it might seem.\r\n\r\nBesides that, these are implementaiton details. I guess the question we should ask here is what we should recommend or even mandate in the RFC.",
              "createdAt": "2024-10-21T09:53:47Z",
              "updatedAt": "2024-10-21T09:53:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N-gtL",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T12:53:20Z",
          "updatedAt": "2024-10-21T12:53:21Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> Its two threads (or more, at least for me) and a network connection, which for me always puts on the warning light, be careful.\r\n\r\nSure, but you have described the effect of language and design decisions and the usual trade off and balances we all make. For others, sharing memory may not even be possible in their language (functional, actor model, etc) so this would simply not be a concern for them.\r\n\r\nAs such, definitely I would agree that mandating this would be unfair to implementers but it would be well placed as recommendations on one of several ways to avoid this problem.\r\n\r\nWe do need something though as related to this all is https://github.com/radext-wg/draft-ietf-radext-tls-psk/issues/4 where stated is a KDF should be used (and crucially 'context' populated) but the two major public implementations do not.\r\n\r\nIf the two-step KDF 'dance' is to be dropped, something would be needed and maybe checking handshake random numbers and provide the backwards compatible sticky tape.",
              "createdAt": "2024-10-21T12:53:20Z",
              "updatedAt": "2024-10-21T12:53:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6OCoN8",
          "commit": {
            "abbreviatedOid": "ba9b92b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T18:42:55Z",
          "updatedAt": "2024-10-21T18:42:55Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "One possible solution would be to compare the TLS keying material after the TLS session is established. If two connections have the same, something is fishy.\r\n\r\nBut that would either mean comparing it to all open connections (bad, if there are a lot) or checking only against the newest ones (also not really ideal, may be hard to implement, still have to check a lot of connections) or keeping track of the pending connections and once there are no pending connections, dropping all established connections from the comparison-pool, since they can't be similar any more (also requires a lot of implementation)\r\n\r\nI am slightly tempted to use a TLS extension to send a randomized number generated at startup of the software and comparing this number for each incoming connection.",
              "createdAt": "2024-10-21T18:42:55Z",
              "updatedAt": "2024-10-21T18:42:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOLrzygc52M_3H",
      "title": "unify idle-timeout between TLS and DTLS",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/5",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "TLS and DTLS specify idle timeout and session limits with different levels of detail. Those limits should apply to both equally.",
      "createdAt": "2024-07-23T11:31:57Z",
      "updatedAt": "2024-10-21T20:42:51Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-idle-timeout",
      "headRefOid": "7efae6bceb6ed11212a611d2e8da900d12e48870",
      "closedAt": "2024-10-21T20:42:50Z",
      "mergedAt": "2024-10-21T20:42:50Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "7efae6bceb6ed11212a611d2e8da900d12e48870"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6CydbS",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for your input. Highly appreciated. See the comments in the review",
          "createdAt": "2024-07-23T15:03:42Z",
          "updatedAt": "2024-07-23T15:23:05Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I can imagine that this can lead to problems.\r\n\r\nOne would be Reverse-CoA where you rely on sending the CoA packet \"backwards\" through RAIDUS/(D)TLS and that doesn't work if the client is behind a NAT, unless the connection stays open.\r\n\r\nThe second would be monitoring.\r\nIf you have a number of Service Providers, all behind a NAT, then the only good monitoring for Liveness of the SP is \"does the server have a (D)TLS session with this client\"\r\nIf the client would just close it, then this monitoring would not be possible anymore.\r\n\r\nI would suggest: Replace `SHOULD` with `MAY` and add some text like `[...], the configuration SHOULD allow to disable the idle timeout session shutdown`",
              "createdAt": "2024-07-23T15:03:42Z",
              "updatedAt": "2024-07-23T15:23:05Z"
            },
            {
              "originalPosition": 6,
              "body": "I don't understand this last sentence (and unfortunately I can't infer from context what word is missing)",
              "createdAt": "2024-07-23T15:19:46Z",
              "updatedAt": "2024-07-23T15:23:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6CzkYv",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-23T17:00:15Z",
          "updatedAt": "2024-07-23T17:00:15Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "maybe add a note about reverse CoA, and say also that systems SHOULD leave at least one connection open, to avoid delays opening new connections when traffic goes from zero to >0",
              "createdAt": "2024-07-23T17:00:15Z",
              "updatedAt": "2024-07-23T17:00:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DEgTC",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T11:05:23Z",
          "updatedAt": "2024-07-25T11:05:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Ah, mabye its just the type r/from/form/, but the point was to emphasize that current setups often use long-lived TLS connections.\r\n\r\nI will try to reword...",
              "createdAt": "2024-07-25T11:05:23Z",
              "updatedAt": "2024-07-25T11:05:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DElT9",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T11:16:07Z",
          "updatedAt": "2024-07-25T11:16:07Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Have to get a bit more into Reverse-CoA.\r\n\r\nI guess in the end this puts even more emphasis on the statement to which values to use:  'it very much depends...'. There is no one size fits all here.",
              "createdAt": "2024-07-25T11:16:07Z",
              "updatedAt": "2024-07-25T11:16:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DKax2",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T22:08:20Z",
          "updatedAt": "2024-07-25T22:08:20Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "ok, I think the from/form correction clarifies what is meant.\r\nLet's see what the WG says",
              "createdAt": "2024-07-25T22:08:20Z",
              "updatedAt": "2024-07-25T22:08:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6DRqCa",
          "commit": {
            "abbreviatedOid": "3948044"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-26T18:04:55Z",
          "updatedAt": "2024-07-26T18:04:55Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think advising cilents to keep a connection open would be a bit misplaced in _this_ document (e.g. with dynamic discovery it might not be apropriate), but its very valid to acknowledge that some scenarios do require it.\r\n\r\nA quick cross-read of reverse-CoA, it might more clearly state that the client MUST keep at least one conneciton open (it's kind of implied, but not clearly stated).",
              "createdAt": "2024-07-26T18:04:55Z",
              "updatedAt": "2024-07-26T18:04:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOLrzygc52OTP7",
      "title": "move TLS response cache invalidation to common section",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/6",
      "state": "CLOSED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "wontfix"
      ],
      "body": "Invalidation of response cache applies to both TLS and DTLS since both are TLS session based. Move paragraph to the common section.",
      "createdAt": "2024-07-23T14:20:26Z",
      "updatedAt": "2025-07-07T17:38:30Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-response-cache",
      "headRefOid": "3de1750bff196d9c05782019bc455da166b26058",
      "closedAt": "2025-07-07T17:38:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\nSince the client connection is closed, those responses from the home server to the proxy server SHOULD be silently discarded by the proxy\r\n```\r\n\r\nMaybe make this MUST?  If the home server replies, there's no way for the proxy to send the packet anywhere.",
          "createdAt": "2024-07-23T17:03:07Z",
          "updatedAt": "2024-07-23T17:03:07Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Maybe make this MUST? If the home server replies, there's no way for the proxy to send the packet anywhere.\r\n\r\nAgreed; updated.",
          "createdAt": "2024-07-24T16:29:30Z",
          "updatedAt": "2024-07-24T16:29:30Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would change the title of this section.\r\nIt's not limited to cached response packets, it's also outstanding requests and all the other stuff that can happen if a connection gets torn down.\r\nI'll try to suggest a different title for this soon.\r\n\r\nOn another note: This again is something that is not necessarily specific to RADIUS/(D)TLS, it only comes up since we now have the concept of \"sessions\", where in RADIUS/UDP the proxy would just forward the response to the original client, despite it being down (since UDP does not have the concept of sessions, so how would the proxy know that the client is gone?)",
          "createdAt": "2025-04-14T16:38:55Z",
          "updatedAt": "2025-04-14T16:38:55Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1.  It's _all_ responses.  I'll also note the text in https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/6/commits/6c10a64b51930fd027cff1bf1405aeb1ac30ed2b doesn't make it clear that this is for _incoming_ connections\r\n\r\ni.e.\r\n* in an incoming connection is closed, then there is no way to send responses to anu requests which were received on that connection.  As a result, all requests MUST be discarded / stopped processing.  etc.\r\n* if an outgoing connection is closed, the proxy or client SHOULD try to send the packet over another outgoing connection.  Further details are outside of the scope of this specification.\r\n\r\nWe have this issue with TCP, too.  But that can be ignored.\r\n\r\nFor UDP, we have no way of knowing if the client is gone, so the server just always replies.",
          "createdAt": "2025-04-14T17:27:23Z",
          "updatedAt": "2025-04-14T17:27:23Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Very good point. I will try to come up with an updated text.",
          "createdAt": "2025-04-15T17:19:32Z",
          "updatedAt": "2025-04-15T17:19:32Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated proposed text.\r\n\r\nI've also added a sentence that associated EAP MAY continue with a RAIDUS request on a new connection. @alandekok please correct me if this is not true. The underlying EAP session will (or at least can) also do retransmissions, sent in a completely new RADIUS request?",
          "createdAt": "2025-04-16T05:11:55Z",
          "updatedAt": "2025-04-16T05:11:55Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking some more, there are more corner cases.  Perhaps:\r\n\r\nIf an incoming (D)TLS session or the underlying connection is closed or broken, then there is no way to send any response to the client.  The server behavior then depends on the types of packets being processed, and on the behavior of the server.\r\n\r\nA proxy which forwards packet MUST discard all requests associated with the closed connection.  As no response can be sent over the (D)TLS connection, and any further processing of requests is pointless.  A discarded request may have a cached RADIUS response packet ({{!RFC5080, Section 2.2.2}}), in which case the cached response is also discarded.  If there is no cached response packet, then the request is still being processed.  The server SHOULD immediately stop processing all such requests for this incoming connection.\r\n\r\nA home server which receives Access-Request packets MUST behave as defined above for a proxy.  Where a RADIUS packet is part of a multi-packet authentication session (e.g. EAP), the underlying authentication session could be continued, or the underlying authentication session data could be discarded.  The server may be able to receive and process another packet for that session via a different incoming connection.  It is difficult to make more recommendations for managing partially processed authentication sessions, as such recommendations depend strongly on the authentication method being used.  As a result, further behavior is implementation defined.\r\n\r\nA home server which receives other kinds of packets (Accounting-Request, CoA-Request, Disconnect-Request) MAY finish processing outstanding requests, and then discard any response.  This behavior ensures that the desired action is still taken, even if the home server cannot inform the client of the results of that action.",
          "createdAt": "2025-04-16T12:27:54Z",
          "updatedAt": "2025-04-16T12:27:54Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I've moved the text to a new pull request ( #33 )\r\n\r\nI'll mark this one as \"wontfix\", further discussion should happen in the new pull request",
          "createdAt": "2025-05-13T12:32:51Z",
          "updatedAt": "2025-05-13T12:32:51Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with #33 ",
          "createdAt": "2025-07-07T17:38:29Z",
          "updatedAt": "2025-07-07T17:38:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOLrzygc52OyfL",
      "title": "unify session resumption",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/7",
      "state": "CLOSED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "wontfix"
      ],
      "body": "TLS session resumption is currently a SHOULD requirement for DTLS and for TLS-PSK.\r\n\r\nUnify this recommendation for all use of (D)TLS and provide guidance for re-authorization as proposed by TLS-PSK.",
      "createdAt": "2024-07-23T15:22:02Z",
      "updatedAt": "2025-07-07T17:38:02Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-session-resumption",
      "headRefOid": "28da1b8ed627e6d410f89d907c9f0dc68fd5f7e9",
      "closedAt": "2025-07-07T17:38:02Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've be in favor of making it a MUST.  I don't see any benefit for an implementation to _not_ implement resumption.",
          "createdAt": "2024-07-23T17:01:57Z",
          "updatedAt": "2024-07-23T17:01:57Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I've be in favor of making it a MUST. I don't see any benefit for an implementation to _not_ implement resumption.\r\n\r\nI vote against a MUST. The benefit for implementos is saving time and effort (if a particular device or application is unlikely to gain much from it, thinking of Wifi APs rather just keep a connection open at all times). And _not_ implementing it doesn't break anything.",
          "createdAt": "2024-07-24T16:22:27Z",
          "updatedAt": "2024-07-24T16:22:27Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps a server MUST implement it.  I expect that all of them will do it anyways, so there's no harm here.\r\n\r\nClients which expect to implement many connections SHOULD implement it.  Clients which rarely open connections do not benefit as much from session resumption.",
          "createdAt": "2024-10-01T18:27:47Z",
          "updatedAt": "2024-10-01T18:27:47Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Done with #34 ",
          "createdAt": "2025-07-07T17:38:02Z",
          "updatedAt": "2025-07-07T17:38:02Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 8,
      "id": "PR_kwDOLrzygc52Xkvx",
      "title": "Edits to grammar/spelling.",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/8",
      "state": "MERGED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Grammatical edits as per my comments in the mailing list.",
      "createdAt": "2024-07-24T17:08:36Z",
      "updatedAt": "2024-10-04T13:54:34Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "ethompson-grammar-edits",
      "headRefOid": "4c4f7e86e4f0eed27e468a3f59741032c6a1e9a0",
      "closedAt": "2024-10-04T12:14:03Z",
      "mergedAt": "2024-10-04T12:14:03Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "35ae6a4ca2c9231c266cf008734673a1952814a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOLrzygc52Xohl",
      "title": "Update draft-ietf-radext-radiusdtls-bis.md flow",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/9",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I believe \"if no matches exist\" flows better in the text.",
      "createdAt": "2024-07-24T17:17:48Z",
      "updatedAt": "2024-10-05T15:45:27Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "Edits-to-text-flow",
      "headRefOid": "8bc754363c6fada03b5b62a2b7e1024aace4e35f",
      "closedAt": "2024-10-05T15:45:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These statements (matching CN) are obsoleted by RFC9525 anyway. PR #4 (should we accept it) removes them completely. ",
          "createdAt": "2024-07-25T09:55:48Z",
          "updatedAt": "2024-07-25T09:55:48Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> These statements (matching CN) are obsoleted by RFC9525 anyway. PR #4 (should we accept it) removes them completely.\r\n\r\n+1",
          "createdAt": "2024-10-01T18:24:46Z",
          "updatedAt": "2024-10-01T18:24:46Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I will close this in favor of #4 , keeping the changes made here in mind.",
          "createdAt": "2024-10-05T15:45:27Z",
          "updatedAt": "2024-10-05T15:45:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 10,
      "id": "PR_kwDOLrzygc52XqPe",
      "title": "Update draft-ietf-radext-radiusdtls-bis.md clarity",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/10",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarifying that a bad RADIUS secret could be caused by a misbehaving party OR a misconfigured one.",
      "createdAt": "2024-07-24T17:22:44Z",
      "updatedAt": "2024-10-05T15:46:27Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "misbehaving-or-misconfigured-party",
      "headRefOid": "2eec15be8d84d7a7dca662e858d100eac849854c",
      "closedAt": "2024-10-05T15:46:26Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll close this PR, if there are strong opinions in the interim about this, we can always include it, but I don't see the need.",
          "createdAt": "2024-10-05T15:46:26Z",
          "updatedAt": "2024-10-05T15:46:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L8mOZ",
          "commit": {
            "abbreviatedOid": "2eec15b"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T12:18:12Z",
          "updatedAt": "2024-10-04T12:18:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"misconfigured\" would mean that it is acceptable to configure a shared secret. Since we mandate \"radsec\" resp. \"radius/dtls\" as shared secret, any deviation from that is (at least formally) not standard-compliant and thus misbehaving.\r\n\r\n(I know that most RADIUS/TLS implementations still allow to configure a custom shared secret)",
              "createdAt": "2024-10-04T12:18:12Z",
              "updatedAt": "2024-10-04T12:18:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L9ciw",
          "commit": {
            "abbreviatedOid": "2eec15b"
          },
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T13:56:33Z",
          "updatedAt": "2024-10-04T13:56:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I see your point, and I agree. I suppose I was getting caught up on the difference between \"behaving maliciously\" and being \"misconfigured\", though on another pass I think \"misbehaving\" does not necessarily imply malice. I am happy to drop this edit",
              "createdAt": "2024-10-04T13:56:33Z",
              "updatedAt": "2024-10-04T13:59:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOLrzygc56jx3x",
      "title": "Idle Timeout Configuration",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/11",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": " Added two sentences about exposing the idle timeout configuration to the administrator (from RFC 7360 Section 5.1.1)",
      "createdAt": "2024-09-05T17:54:37Z",
      "updatedAt": "2025-04-14T21:36:09Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "idle-timeout",
      "headRefOid": "307e5491319600fdb21f027445a123ec0a7c8b18",
      "closedAt": "2025-04-14T21:36:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems good to me",
          "createdAt": "2024-10-01T18:26:13Z",
          "updatedAt": "2024-10-01T18:26:13Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is possibly unnecessary if we choose to accept #5 ",
          "createdAt": "2024-10-06T20:00:49Z",
          "updatedAt": "2024-10-06T20:00:49Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "With #5 merged I think this is obsolete now.\r\nI'm closing it.",
          "createdAt": "2025-04-14T21:36:09Z",
          "updatedAt": "2025-04-14T21:36:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6MYvE0",
          "commit": {
            "abbreviatedOid": "307e549"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T18:56:44Z",
          "updatedAt": "2024-10-08T18:56:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Should be noted that for non-stream setup UDP sockets, Linux's Netfilter uses a timeout of 30 seconds, so might be worth lowering the bottom end to match?",
              "createdAt": "2024-10-08T18:56:44Z",
              "updatedAt": "2024-10-08T18:56:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOLrzygc56jySj",
      "title": "Parallel Connection Requests",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/12",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added text regarding the parallel connection requests detailed in RFC 6614 Section 2.3",
      "createdAt": "2024-09-05T17:55:47Z",
      "updatedAt": "2025-05-14T18:09:00Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "parallel-connection-requests",
      "headRefOid": "d33d9a1c2667393a88415511aec80f0b287a7e83",
      "closedAt": "2025-05-14T18:09:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would suggest to move this specification maybe even in an own paragraph.\r\n\r\nThis is not linked to (D)TLS directly, more in the direction of handling the underlying connection, and I think we need to add a few sentences for this exponential back-off mechanism.",
          "createdAt": "2024-10-04T12:24:29Z",
          "updatedAt": "2024-10-04T12:24:29Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It may be useful to have a section on managing connections, and distributing packets across connections.",
          "createdAt": "2024-10-04T13:04:00Z",
          "updatedAt": "2024-10-04T13:04:00Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a general RADIUS proxying issue and not limited to RADIUS/(D)TLS, so it is out-of-scope for this document.",
          "createdAt": "2025-05-14T18:08:58Z",
          "updatedAt": "2025-05-14T18:08:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOLrzygc56jyhL",
      "title": "EAP Section",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/13",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added EAP section to include details from RFC 6613",
      "createdAt": "2024-09-05T17:56:26Z",
      "updatedAt": "2025-04-14T16:22:12Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "section-EAP-sessions",
      "headRefOid": "e09d7ebb3ac8f26ff23fcad4616953c94788e506",
      "closedAt": "2025-04-14T16:22:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's worth noting that one has to be careful when proxying EAP requests.\r\nI agree with Fabian that if the RADIUS/(D)TLS client is the \"first in line\", they should know the EAP session and take care of the correct path themselves, so it is only relevant for proxies.\r\n\r\nI would include a bit more reasoning why EAP is different than other RADIUS traffic, so people reading this can understand why they should care.",
          "createdAt": "2024-10-04T12:45:54Z",
          "updatedAt": "2024-10-04T12:45:54Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the connection / load-balancing issues are similar for a client which originates traffic, and a proxy which forwards traffic.  So the text should be similar.\r\n\r\nThe connection issue isn't limited to EAP, it's \"all packets for one session\".  e.g., MFA challenge / response.\r\n\r\nIf an authentication step takes one packet, then it doesn't matter how the client does packet load-balancing.  The failure of any one connection will only affect authentications which go over that one connection.\r\n\r\nWhen authentication requires multiple packets, we have a choice for load-balancing:\r\n\r\n1. put all packets for the same session over the same connection\r\n2. distribute packets for the same session across multiple connections\r\n\r\nThe client does not know if the server is an IdP / home server, or a proxy.  The client does not even know if the connections are to multiple \"equivalent\" home servers.  As a result, when the client initiates an authentication session with a particular server, that authentication session MUST be tied to one connection.  Distributing packets for one session across multiple connections means that in some valid architectures, multiple home servers will see packets for one authentication session.\r\n\r\nWhile this situation may work in some limited scenarios, it guarantees that authentication cannot work in other scenarios which are in use today.\r\n\r\nThe situation isn't much different if the next hop is a proxy.\r\n\r\nWith (1), the failure of any one connection will affect only the sessions which use that connection.  i.e. for 5 active connections which then has one fail, 1/5 of authentication sessions will be affected.  It is likely that those authentication sessions will fail, especially if the connections are to separate home servers.  At the minimum, 1/5 authentication sessions will experience increased timeouts and instability as the client does fail-over.\r\n\r\nWith (2) the failure of any one connection will affect _all_ of the authentication sessions.  In the above scenario, any multi-round authentication session will have 1/5 of the packets sent across each connection.  So when a connection fails, _every_ ongoing session is affected.\r\n\r\nIn order to help with network robustness, clients MUST put all packets for one authentication session across the same connection.  If that connections fails, clients MAY distribute packets to a different connection, but this will work in only limited situations, and those authentication sessions are likely to fail.\r\n\r\nThe issue is different for accounting.  Each packet is stand-alone, and the packets are far enough apart in time that there is no benefit to putting them on the same connection.",
          "createdAt": "2024-10-04T13:25:23Z",
          "updatedAt": "2024-10-04T13:25:23Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "But then we have the problem of defining a \"session\".\r\nWe don't have any reliable easy-to-find indication which RADIUS packets belong to the same session.\r\nSo as far as I can see we have two options here:\r\n\r\nOption 1: mandate that load-balancing must only be done on the basis of the source of the RADIUS packet (i.e. if your proxy has two connected clients (A,B) and two servers (C,D), the proxy MAY load-balance so that all packets from A go to C and all packets from B go to D. If every RADIUS peer in the chain follows this procedure, we will always have a deterministic path through the RADIUS proxy fabric.\r\nThis is the safe option, but also ineffective.\r\n\r\nOption 2: Mandate nothing. Just say \"Proxying is hard. Beware, there be dragons\" and elaborate on what operators may have to consider if they want to enable load-balancing.\r\nIf the operators are running a RADIUS service that is strictly single request-response, then there is no harm in randomly throwing the packets to all the servers equally.\r\nIf the operators know that their RADIUS service has sessions and the sessions have to go to the same server, then they can disable load-balancing and instead move to a hot-standby configuration",
          "createdAt": "2024-10-04T13:35:27Z",
          "updatedAt": "2024-10-04T13:36:17Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 9:35 AM, Jan-Frederik Rieckers ***@***.***> wrote\n> But then we have the problem of defining a \"session\".\n> We don't have any reliable easy-to-find indication which RADIUS packets belong to the same session.\n\n  The State attribute connects multiple packets across one authentication session.\n\n  However, the State attribute is random, and can change between packets.  So we can't use that.\n\n  The practical solution as implemented by many sites is:\n\n* load-balance on hash of Calling-Station-Id if it exists\n* otherwise load-balance on hash of User-Name\n\n> So as far as I can see we have two options here:\n> \n> Option 1: mandate that load-balancing must only be done on the basis of the source of the RADIUS packet (i.e. if your proxy has two connected clients (A,B) and two servers (C,D), the proxy MAY load-balance so that all packets from A go to C and all packets from B go to D\n> This is the safe option, but also ineffective.\n\n  It doesn't work.\n\n> Option 2: Mandate nothing. Just say \"Proxying is hard. Beware, there be dragons\" and elaborate on what operators may have to consider if they want to enable load-balancing.\n\n  The RFCs contain near-zero discussion of load-balancing.  At the same time, implementors and administrators have converged on a common set of practices.  It would be good to at least document these practices as known working suggestions.\n\n> If the operators are running a RADIUS service that is strictly single request-response, then there is no harm in randomly throwing the packets to all the servers equally.\n\n  Yes.\n\n> If the operators know that their RADIUS service has sessions and the sessions have to go to the same server, then they can disable load-balancing and instead move to a hot-standby configuration\n\n  But if the load-balancing is done as described above, there's no need to do any of this.  Everything just works.  It doesn't matter if authentication sessions are one packet or many packets.  It doesn't matter if the next hop is an IdP / home server or proxy.  It doesn't matter what kind of architecture has been set up for load-balancing on the server side.\n\n  It all just works.",
          "createdAt": "2024-10-04T13:55:07Z",
          "updatedAt": "2024-10-04T13:55:07Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would opt for documenting some best practices, and suggest, but not mandate behavior.",
          "createdAt": "2024-10-04T14:00:50Z",
          "updatedAt": "2024-10-04T14:00:50Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 10:01 AM, Jan-Frederik Rieckers ***@***.***> wrote:\n> I would opt for documenting some best practices, and suggest, but not mandate behavior.\n\n  Sure.  With the caveat that if this practice isn't followed, then things are likely to go wrong, for the above-described reasons.\n\n",
          "createdAt": "2024-10-04T14:03:12Z",
          "updatedAt": "2024-10-04T14:03:12Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "NONE",
          "body": "Hashing with primarily `Calling-Station-Id` and `User-Name`; \ud83d\udc4d for that. We use the both by default and it works. I haven't ever seen them change during the EAP authentication exchange. MAC address randomisation may cause the C-S-I to change, but that would affect the subsequent (re)authentications only.\r\n\r\nA note about hashing: Let's say that there are 5 connections and hashing uses modulo 5 to choose the next hop. When a connection goes down, it would be good if the hashing is still done so that the existing EAP exchanges do not switch the next hop, for example, hashing being done with module 4.",
          "createdAt": "2024-10-08T16:49:50Z",
          "updatedAt": "2024-10-08T16:49:50Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Since this is not specific to RADIUS/(D)TLS, but a general RADIUS proxying issue, I think this is out-of-scope for this document.\r\nI'm therefore closing this PR without merging.",
          "createdAt": "2025-04-14T16:22:11Z",
          "updatedAt": "2025-04-14T16:22:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6LgHgs",
          "commit": {
            "abbreviatedOid": "e09d7eb"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T13:57:58Z",
          "updatedAt": "2024-10-01T13:57:58Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'm a bit confused about this MUST requirement.\r\n\r\nJust for my own understanding: we are talking about actual clients (i.e. NAS), and not proxies?\r\n\r\nI'm not very familiar with EAP on a NAS. I would expect that a client is always aware of the EAP sessions - but its details area outside of this specification. To me this is a prerequieiste for this MUST statement. If we can't guarantee this for a client, then we can't put a MUST here.\r\n\r\nThe second paragraph is confusing me. Having to keep EAP sessions together based on a radius attribute is something a proxy might do - as stated above a client should already know the EAP sessions. If a client has to guess the EAP sessions from a radius attribute, we can't call this a MUST.\r\n\r\nI would propose to remove the second paragraph (if my initial assumption of clients having perfect knowledge about EAP sessions is true).",
              "createdAt": "2024-10-01T13:57:58Z",
              "updatedAt": "2024-10-01T13:57:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOLrzygc56jz8n",
      "title": "Implementation Guidelines / Connected Sockets",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/14",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs discussion"
      ],
      "body": "Added section including the details from RFC 7360 Section 6. I didn't feel like this text would fit well in any of the existing sections, so I created a new one",
      "createdAt": "2024-09-05T17:59:30Z",
      "updatedAt": "2025-07-20T12:00:47Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "section-implementation-guidelines",
      "headRefOid": "7cf6645ec8727a844d8ab701f318ad13c6225982",
      "closedAt": "2025-07-20T12:00:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 7, 2024, at 5:46 AM, Jan-Frederik Rieckers ***@***.***> wrote:\n> ..\n> +RADIUS/(D)TLS clients should use a single source (IP + port) when sending packets to a particular RADIUS/(D)TLS server. Doing so minimizes the number of (D)TLS session setups. It also ensures that information about the home server state is discovered only once.\n> \n> This could be a problem if a single RADIUS/(D)TLS peer has so much packet throughput that a single connection would be clogged (due to the limited ID space), and in this case the client would have to open a second connection to the same server to increase the usable space for packets-in-flight.\n> \n> I think we don't have text for that in the document yet, maybe it should be included in #13\n\n  Perhaps instead of a \"single\" connection, they should use the \"minimal\" number of connections.",
          "createdAt": "2024-10-07T11:26:56Z",
          "updatedAt": "2024-10-07T11:26:56Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I am closing this PR since most of it is out-of-scope. (Feel free to re-open if it should still be included)",
          "createdAt": "2025-05-14T18:12:49Z",
          "updatedAt": "2025-05-14T18:12:49Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure why it is out of scope?  DTLS implementations issues are not covered in any of the underlying DTLS RFCs.  This text gives implementers specific and actionable guidelines for how to create servers that work.\r\n\r\nOne of my pet peeves over the years is RFCs which describe how to encode / decode packets, and then leave absolutely everything else unspecified.  The result is endless interoperability issues, bugs, etc.\r\n\r\nI'd like a larger discussion on the RADEXT list about scope, so I'll re-open this issue.",
          "createdAt": "2025-05-14T18:34:14Z",
          "updatedAt": "2025-05-14T18:34:14Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "  Hmm. Double checking osx and FreeBSD, they all have the same text about connected udp sockets. I missed that, and had  found other references which said something else. \n\n  Ok, my objections are withdrawn, and I'll go over the text for any needed updates. \n",
          "createdAt": "2025-05-23T17:00:53Z",
          "updatedAt": "2025-05-23T17:00:53Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed at the hackathon, this is mostly already in the document, so we can close this.",
          "createdAt": "2025-07-20T12:00:47Z",
          "updatedAt": "2025-07-20T12:00:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6IH8lB",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T18:18:57Z",
          "updatedAt": "2024-09-05T18:18:58Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Perhaps \"historic\" or \"legacy\" instead of \"traditional\"",
              "createdAt": "2024-09-05T18:18:58Z",
              "updatedAt": "2024-09-05T18:18:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6IH9Kl",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T18:20:21Z",
          "updatedAt": "2024-09-05T18:20:21Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "The use of unconnected sockets is only for UDP / DTLS.",
              "createdAt": "2024-09-05T18:20:21Z",
              "updatedAt": "2024-09-05T18:20:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LhOL6",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T15:32:45Z",
          "updatedAt": "2024-10-01T15:32:45Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I'm opposing this recommendation. \r\n\r\nTo my knowledge, the stated limitation not beeing able to accept packets from different clients on the same port is wrong.\r\n\r\nUsing connected UDP sockets works perfectly fine and simplifies DTLS implementation a lot. Having to manually manage DTLS sessions and hand over received DTLS frames to the correct TLS context would be extremely tedious. Using connected UDP sockets and letting the TLS library do the hard work is way easier. ",
              "createdAt": "2024-10-01T15:32:45Z",
              "updatedAt": "2024-10-01T15:32:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LijjY",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T18:18:37Z",
          "updatedAt": "2024-10-01T18:18:38Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Where the src/dst ip/port is known in advance, connected UDP sockets work fine.  Where there is instead a \"wildcard\" socket for receiving packets from known clients but unknown source ports, connected UDP sockets have unavoidable race conditions in the network stack.\r\n\r\nA RADIUS server would typically perform the following steps to get a connected socket:\r\n\r\n1. open wildcard socket \"*:1812\" for UDP\r\n2. accept packets for that socket\r\n3. see new client source IP and source port\r\n4. Open new UDP socket on the same source IP/port (SO_REUSEADDR / SO_REUSEPORT)\r\n5. call connect() to connect to the client source IP and port\r\n6. receive packets on the connected socket\r\n\r\nFor a TCP connection, steps (4) and (5) are handled by `accept()`, which is atomic.  It both opens a new socket, and ties that socket to a particular src/dst IP/port.\r\n\r\nIn contrast for UDP, steps (4) and (5) are done as separate system calls by the application.  There is no clear way to know what happens to packets during that window.\r\n\r\ni.e. if there are multiple packets in the receive queue, does the `connect()` pull all packets out of the wildcard socket, and move them to the new socket?  Or do some packets go to the new connected socket, while other packets go to the original wildcard socket?\r\n\r\nAll of this is OS dependent.\r\n\r\nIf will _usually_ work, for the simple reason that the inter-packet spacing is larger than the time between system calls in steps (4) and (5).  But there is no _guarantee_ that it works.\r\n\r\nIf we do suggest that connected sockets are fine, then these issues should be explained, so that implementors are aware of them and can address them. \r\n\r\nThis issue is address in more detail in a cloudflare article:  https://blog.cloudflare.com/everything-you-ever-wanted-to-know-about-udp-sockets-but-were-afraid-to-ask-part-1/",
              "createdAt": "2024-10-01T18:18:38Z",
              "updatedAt": "2024-10-01T18:18:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LwOrL",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-03T05:26:33Z",
          "updatedAt": "2024-10-03T05:26:34Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I think here steps 4-5 are a non-issue. It may be in a general case (depending on the protocol, like quic), but since we are dealing explicitly with DTLS, its not.\r\n\r\nYes, between steps 3 and 5 any packet that arrives in that time frame _on the same 5-tuple_ will unpredictably be received by either the wildcard socekt or the connected socket. However in DTLS, there is no legal packat that can arrive _on the same 5-tuple_ between the initial client hello and an apropriate response from the server - which it will only send after connecting the socket. \r\n\r\n(sidenote: the initial client hello MUST fit into a single UDP packet; I stumbled over this when it didn't and OpenSSL would immediatley error out telling me so)\r\n\r\nThe worst thing that can happen is if duplicate UDP packets (client hello) arrive. If the connected socket gets it, I'm not shure how OpenSSL handles it, probably silently discards. If the wildcard socket gets it, it will try to connect another socket to the same 5-tuple, which will then fail.",
              "createdAt": "2024-10-03T05:26:34Z",
              "updatedAt": "2024-10-03T05:26:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6LzyKi",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-03T13:22:07Z",
          "updatedAt": "2024-10-03T13:22:07Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "> However in DTLS, there is no legal packat that can arrive on the same 5-tuple between the initial client hello and an apropriate response from the server - which it will only send after connecting the socket.\r\n\r\nGood point.  I agree then that DTLS connections SHOULD use connected sockets.\r\n\r\nThis issue should be described and explained in the spec.",
              "createdAt": "2024-10-03T13:22:07Z",
              "updatedAt": "2024-10-03T13:22:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MKCBu",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T09:43:11Z",
          "updatedAt": "2024-10-07T09:43:11Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe text above describes the protocol. In this section, we give additional implementation guidelines. These guidelines are not part of the protocol, but they may help implementors create simple, secure, and efficient implementations.\r\n```\r\nI would argue that the \"interoperable\" part is the responsibility of the protocol specification. So I would not put \"interoperable\" here, but a different word. I'm not sure if \"efficient\" is the right one, maybe something along \"predictable\" in the meaning that administrators of different RADIUS/(D)TLS servers by different vendors can rely on a somewhat similar behavior under the same circumstances.",
              "createdAt": "2024-10-07T09:43:11Z",
              "updatedAt": "2024-10-07T09:43:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MKDhY",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T09:45:47Z",
          "updatedAt": "2024-10-07T09:45:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This could be a problem if a single RADIUS/(D)TLS peer has so much packet throughput that a single connection would be clogged (due to the limited ID space), and in this case the client would have to open a second connection to the same server to increase the usable space for packets-in-flight.\r\n\r\nI think we don't have text for that in the document yet, maybe it should be included in #13",
              "createdAt": "2024-10-07T09:45:47Z",
              "updatedAt": "2024-10-07T09:45:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MKJyX",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T09:56:47Z",
          "updatedAt": "2024-10-07T09:56:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "We already have some of this text in the \"Client Subsystems\" section in the Security considerations. Would you suggest merging the \"Client Subsystems\" section in this section?\r\nOtherwise, this text should at least reference the security considerations.",
              "createdAt": "2024-10-07T09:56:47Z",
              "updatedAt": "2024-10-07T09:56:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qvosQ",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-23T14:23:06Z",
          "updatedAt": "2025-05-23T14:23:06Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think\r\n> use a single source (IP + port) when sending packets to a particular RADIUS/(D)TLS server\r\n\r\nwould be wrong. We can only associate packets to a TLS session using the 5-tuple. For TCP this is implicit, for UDP, we can tell the kernel to do it by using connected sockets, or do it manually - but there is no more information besides the 5-tuple to do it.\r\nWithout RADIUS/1.1, we need the possibility of multiple TLS sessions to mitigate ID-exhaustion.\r\nIf any, the client shoud minimize the number of TLS sessions.",
              "createdAt": "2025-05-23T14:23:06Z",
              "updatedAt": "2025-05-23T14:23:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qwSdI",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-23T15:12:57Z",
          "updatedAt": "2025-05-23T15:12:57Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I agree that clients should minimize the number of TLS sessions.\r\n\r\nIn most cases, the 5-tuple will be enough to track a UDP \"connection\".   However, this is not guaranteed to work when NATs are used.  It will generally be OK, but the NAT RFCs allow NATs to re-use a source port after 30 seconds.\r\n\r\nPlus, UDP connected sockets do not work like TCP connected sockets.  I spent some time looking into this over the past few months.\r\n\r\nUDP connected sockets do what you expect _only_ for sending packets.  They allow an application to call `write()` instead of `sendto()` for UDP data.\r\n\r\nFor receiving packets, the OS will deliver UDP packets to the destination IP / port _no matter what the source IP is_.  As a result, a system receiving packets always has to use `recvfrom()`, and then check the source IP.  This is needed even for connected UDP sockets.\r\n\r\nThis usually isn't an issue in practice, because not many people are spamming UDP packets to RADIUS IP/ports.  But if a DTLS server is publicly available, this will happen.\r\n\r\nIn general, this means that servers can't use connected UDP sockets to track a \"UDP session\".",
              "createdAt": "2025-05-23T15:12:57Z",
              "updatedAt": "2025-05-23T15:12:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qxLbk",
          "commit": {
            "abbreviatedOid": "7cf6645"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-23T16:30:20Z",
          "updatedAt": "2025-05-23T16:30:20Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "We have to use exatley the 5-tuple, there is no other information to associate an incoming packet with a TLS session. If the NAT descides to reuse a port after not seeing a packet for 30 seconds, it will stomp on that connection and break it. The TLS layer will take care of it and not accept any TLS messages not belonging to the old session. Same could happen if the client restarts (wihtout closing the DTLS conection) and reuses the port. \r\n\r\nConnected UDP sockets are perfectly fine for DTLS - I have a working implementation. In terms of steering incoming packets to the correct socket, it works exactly like TCP - you just have to implement the `accept()` logic yourself (i.e. getting the first packet with `recvfrom()` and then creating a new socket and `bind()` plus `connect()` it to the incoming 5-tuple). The linux manpage about `connect()` explicitly states: \r\n>If the socket sockfd is of type SOCK_DGRAM, then addr is the\r\n       address to which datagrams are sent by default, and the only\r\n       address from which datagrams are received.\r\n\r\nBut in the end its irrelevant wether you use connected sockets or not, the provisions of associating a 5-tuple with a tls session remain the same.\r\n",
              "createdAt": "2025-05-23T16:30:20Z",
              "updatedAt": "2025-05-23T16:30:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOLrzygc56kd9E",
      "title": "CA Trust for RADIUS/(D)TLS Clients",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/15",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "wontfix"
      ],
      "body": "Added blurb on how CA trust for RADIUS/(D)TLS clients should be configured (from RFC 7360 Section 10.4)",
      "createdAt": "2024-09-05T19:57:29Z",
      "updatedAt": "2025-05-27T08:54:01Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "client-trusted-authorities",
      "headRefOid": "daba6298ee529e95e6bbc0f78766654d43d63652",
      "closedAt": "2025-05-27T08:54:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2024-09-06T14:01:17Z",
          "updatedAt": "2024-09-06T14:01:17Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 9:07 AM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> \u2b07\ufe0f Suggested change\r\n\r\n  Looks good.\r\n\r\n",
          "createdAt": "2024-10-04T14:22:36Z",
          "updatedAt": "2024-10-04T14:22:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "With the general rewrite of the document, I'm not sure if this PR is still applicable, and I would appreciate feedback from the WG participants on whether or not this text is needed.",
          "createdAt": "2025-04-14T16:31:45Z",
          "updatedAt": "2025-04-14T16:31:45Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's necessary to have some text which says \"clients MUST NOT come with a pre-configured list of trusted CAs\".",
          "createdAt": "2025-04-14T17:29:32Z",
          "updatedAt": "2025-04-14T17:29:32Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #35 ",
          "createdAt": "2025-05-27T08:54:01Z",
          "updatedAt": "2025-05-27T08:54:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L8_ON",
          "commit": {
            "abbreviatedOid": "8f7c295"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T13:06:58Z",
          "updatedAt": "2024-10-04T13:06:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "The idea is good, I completely agree.\r\n\r\nI'm just not really comfortable with the text, I've tried to re-word it a bit, maybe you see where my problems are.\r\nIf you have an alternative: I'm happy to throw my re-wording away ;)\r\n\r\n```suggestion\r\nIf this model is implemented, RADIUS/(D)TLS clients SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer. Instead, the clients SHOULD start off with an empty CA list. The addition of a CA SHOULD be done only when manually configured by an administrator.\r\n\r\nThe goal of RADIUS/(D)TLS is to securely communicate with only a small set of well-known peers.\r\nThese peers will use specific certificates, potentially even from a private purpose-specific CA.\r\nThis scenario is different from a common use case of PKIX where an entity wants to communicate securely with unknown remote entities (i.e. web browsing), that use the public CAs to establish a trust path to this unknown entity.\r\n```",
              "createdAt": "2024-10-04T13:06:59Z",
              "updatedAt": "2024-10-04T13:06:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6L-ASL",
          "commit": {
            "abbreviatedOid": "8f7c295"
          },
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T14:57:19Z",
          "updatedAt": "2024-10-04T14:57:20Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I am happy with these changes",
              "createdAt": "2024-10-04T14:57:19Z",
              "updatedAt": "2024-10-04T14:57:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MYyzO",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T19:04:50Z",
          "updatedAt": "2024-10-08T19:04:50Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I would suggest amending this to reflect should not be pre-configured as *already* trusted for the client.\r\n\r\nI could perceive an onboarding process that assists the administrator to know which CA to add as a trust anchor for the given client; it would show the chain but the administrator would still be expected to approve it.",
              "createdAt": "2024-10-08T19:04:50Z",
              "updatedAt": "2024-10-08T19:05:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6NyyC-",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-18T20:13:50Z",
          "updatedAt": "2024-10-18T20:13:50Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nIf this model is implemented, RADIUS/(D)TLS peers SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer that are enabled by default. Instead, the peers SHOULD start off with an empty CA list. The addition of a CA SHOULD be done only when manually configured by an administrator.\r\nThis does not mean that vendors or manufactures cannot include trust lists in their products, but enabling these lists should always be a conscious decision of the administrator.\r\n\r\nThe goal of RADIUS/(D)TLS is to securely communicate with only a small set of well-known peers.\r\nThese peers will use specific certificates, potentially even from a private purpose-specific CA.\r\nThis scenario is different from a common use case of PKIX where an entity wants to communicate securely with unknown remote entities (i.e. web browsing), that use the public CAs to establish a trust path to this unknown entity.\r\n```",
              "createdAt": "2024-10-18T20:13:50Z",
              "updatedAt": "2024-10-18T20:13:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6Nyyky",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-18T20:15:26Z",
          "updatedAt": "2024-10-18T20:15:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This is a suggestion to include the feedback from the interim.\r\nWordsmithing welcome, I'm not completely satisfied with the wording.\r\nLeaving the second should in lowercase was intended. This sentence is just information and not normative.",
              "createdAt": "2024-10-18T20:15:26Z",
              "updatedAt": "2024-10-18T20:15:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N0oja",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-19T11:41:07Z",
          "updatedAt": "2024-10-19T11:41:07Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I like the second part as is, it is helpful in explaining why someone should not just blindly leap and lean pre-trusting the web forum certs (which I probably would have done myself as an implementer), so my bike shedding suggestion is really only for the first part:\r\n\r\n\"If this model is implemented, RADIUS/(D)TLS peers SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer that are enabled by default. Instead, the peers SHOULD begin untrusted (ie. an empty CA list) and the process of trusting a given CA SHOULD be a manually step performed by an administrator.\r\n\r\nThis does not preclude vendors or manufactures including trust lists in their products, but the enabling of those lists should be a conscious decision by an administrator.\"",
              "createdAt": "2024-10-19T11:41:07Z",
              "updatedAt": "2024-10-19T11:41:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6N_zQ_",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T14:32:44Z",
          "updatedAt": "2024-10-21T14:32:44Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I don't like the \"should begin untrusted\". The peers themselves are not untrusted, they are just untrusting (so to speak).\r\nAnd shouldn't it be \"should be a manual step performed by ...\" or \"manually performed step\"?",
              "createdAt": "2024-10-21T14:32:44Z",
              "updatedAt": "2024-10-21T14:33:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6ODSbt",
          "commit": {
            "abbreviatedOid": "daba629"
          },
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T20:17:56Z",
          "updatedAt": "2024-10-21T20:17:56Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I think a hybrid of the two for the \"first chunk\" would be good:\r\n\r\n\"If this model is implemented, RADIUS/(D)TLS peers SHOULD NOT be pre-configured with a list of known public CAs by the vendor or manufacturer that are enabled by default. Instead, the peers SHOULD start off with an empty CA list. The addition of a CA SHOULD be done only when manually configured by an administrator.\r\n\r\nThis does not preclude vendors or manufactures including trust lists in their products, but the enabling of those lists should be a conscious decision by an administrator.\"\r\n\r\nAs for the \"second chunk\", I would change the wording slightly to something like:\r\n\r\n\"The goal of RADIUS/(D)TLS is to communicate securely with only a small set of well-known peers.\r\n\r\nThese peers will use specific certificates, potentially from a private, purpose-specific CA.\r\n\r\nThis scenario is different from the common use case of PKIX, where the goal is to communicate securely with unknown remote entities (e.g., web browsing) that use public CAs to bootstrap trust.\"\r\n\r\nThough, I'm not in love with saying \"specific certificates\" since I think that could be a little vague or confusing.",
              "createdAt": "2024-10-21T20:17:56Z",
              "updatedAt": "2024-10-21T20:17:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOLrzygc56q4EP",
      "title": "Security Consideration: Network Address Translation",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/16",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs discussion"
      ],
      "body": "Added subsection on Network Address Translation (from RFC 7360 Section 10.5)",
      "createdAt": "2024-09-06T13:49:12Z",
      "updatedAt": "2025-07-20T12:05:51Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "Network-Address-Translation",
      "headRefOid": "3b26c0292bf02130fefe81928dd882b4c82b3c1b",
      "closedAt": "2025-07-20T12:05:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2024-09-06T14:02:59Z",
          "updatedAt": "2024-09-06T14:02:59Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 4, 2024, at 9:19 AM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> +## Network Address Translation\r\n> +\r\n> +Network Address Translation (NAT) is fundamentally incompatible with RADIUS/UDP. RADIUS/UDP uses the source IP address to determine the shared secret for the client, and NAT hides many clients behind one source IP address. As a result, RADIUS/UDP clients cannot be located behind a NAT gateway.\r\n> +\r\n> +In addition, port reuse on a NAT gateway means that packets from different clients may appear to come from the same source port on the NAT. That is, a RADIUS server may receive a RADIUS/DTLS packet from one source IP/port combination, followed by the reception of a RADIUS/UDP packet from that same source IP/port combination. If this behavior is allowed, then the server would have an inconsistent view of the client\u2019s security profile, allowing an attacker to choose the most insecure method.\r\n> \r\n> I'm not sure exactly what the problem here is and if the proposed solution is correct.\r\n> \r\n> I'll try to put it the way I understand the problem:\r\n> \r\n> A 10.0.0.1 (RADIUS/DTLS) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:2083\r\n> B 10.0.0.2 (RADIUS/UDP) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:1812\r\n> \r\n> So now the RADIUS server has two UDP connections to 192.0.2.1:12345, but since the port on the RADIUS server side is different, the NAT can translate the UDP packets from source port 2083 to A and the ones from 1812 to B.\r\n\r\n  Yes.  The issue is the network security model.\r\n\r\n> In my view, the problem here is that, if the server mixes those up, the server is at fault for allowing the client list for RADIUS/UDP to merge with the client list for RADIUS/DTLS.\r\n> Those two client lists should be separate (at least in terms of IP-Addr/Port).\r\n\r\n  We don't know what source port will be used by the client.  So we can't rely on that.\r\n\r\n  All we know is that one IP is sending us RADIUS/UDP, and RADIUS/TLS.  The question is not just what to do, but what we _can_ do in that situation.\r\n\r\n> We cannot force every client behind a NAT to behave this way, because the NAT may be responsible for a huge variety of customer nets, and we can't mandate them to speak to each other.\r\n> \r\n> Example: Carrier-Grade NAT (CGN), Company A has a Dual-Stack internet connection with CGN for v4 and uses legacy-RADIUS, Company B has the same, but uses RADIUS/(D)TLS for their connection. We can't define a standard where Company A would now be forced to migrate to RADIUS/(D)TLS. They have no way of knowing that Company B is using DTLS with the same server. And we shouldn't mandate that the CGN keeps track of all possible connections and makes sure that no source port gets re-used if RADIUS/(D)TLS and RAIDUS/UDP are used with the same server.\r\n\r\n  Agreed.\r\n\r\n  To a certain extent, there is no technical reason why a server can't accept both RADIUS/UDP and RADIUS/TLS from the same source IP.  The packets are clearly distinguishable.\r\n\r\n  The problem we're trying to solve is to stop down-bidding attacks.  The simplest approach then is to say that both UDP and TLS may be allowed for compatibility, but that this configuration is NOT RECOMMENDED.",
          "createdAt": "2024-10-04T14:21:48Z",
          "updatedAt": "2024-10-04T14:21:48Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see benefit in adding this text to the document, so I'm closing this PR.\r\nFeel free to re-open if it is still needed.",
          "createdAt": "2025-05-14T18:31:13Z",
          "updatedAt": "2025-05-14T18:31:13Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps the text could be reworded to be less NAT specific?  Many people operate RADIUS clients behind a NAT gateway, so it could be useful to explain how NAT affects RADIUS/(D)TLS.",
          "createdAt": "2025-05-14T18:36:00Z",
          "updatedAt": "2025-05-14T18:36:00Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "The question is: Is this RADIUS/(D)TLS specific?\r\nI would argue that any effect of NAT also applies to a RADIUS/UDP with multiple different ports.",
          "createdAt": "2025-05-14T20:44:07Z",
          "updatedAt": "2025-05-14T20:44:07Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In RADIUS/UDP, clients are uniquely identified based on source IP address.  In contrast, NAT hides multiple different clients behind one IP address.  The two are therefore fundamentally incompatible.\r\n\r\nSome implementations have addressed this by looking at the contents of the RADIUS packet.  If the packet contains `NAS-IP-Address = IP1`, then it is identified as \"client 1\".  If the packet contains `NAS-IP-Address = IP2` then it is identified as \"client 2\".  This practice \"works\", for various values of \"works\".\r\n\r\nWhile the NAT usually maps one (source IP/port) to one outbound port on the NAT box, this mapping is not guaranteed.  It can change over time, without notice to either RADIUS client or server.  The server therefore can _mostly_ treat packets from one NAT port as being from the \"same\" client, but it cannot _guarantee_ that they are from the same client.  If some time has passed with no traffic, the port can be re-used.\r\n\r\n[RFC 4787 Section 4.3](https://datatracker.ietf.org/doc/html/rfc4787#section-4.3) suggests that the timeouts SHOULD be 5 minutes.  However, sites like Google Cloud default to [30 seconds](https://cloud.google.com/nat/docs/tune-nat-configuration#nat-timeouts).  Linux also appears to default to 30 seconds.\r\n\r\nIn order to keep the port mapping alive, the client must send network traffic within that timeout period.  But many clients don't send keep-alives, as [RFC 2865 Section 2.6](https://datatracker.ietf.org/doc/html/rfc2865#section-2.6) says that keep-alives are harmful.\r\n\r\nThese limitations mean that the server can only determine client identity by examining the contents every packet RADIUS/UDP in isolation.  This behavior is at best a hack, and is not standardized in any RADIUS RFC.\r\n\r\nIn contrast, with DTLS, there is a way to uniquely identify a client: the TLS session.  This identification is independent of source IP or source port.  With TLS, the identification is even stronger: the underlying TCP connection.  The properties of TCP ensure that the TCP connections won't conflict with each other, even if the NAT box reuses a source port.\r\n\r\nAs a result, NAT is fundamentally incompatible with RADIUS/UDP, but makes zero difference to RADIUS/(D)TLS.\r\n\r\nThere is an additional issue, as pointed out in the suggested text.\r\n\r\nWhen multiple clients are placed behind a NAT, the security of the system as a whole is limited by the least secure client.  Since the NAT gateway uses the same source IP for both RADIUS/UDP clients, and RADIUS/(D)TLS clients, the server must allow RADIUS/UDP from that source IP.  Which means that it's possible for a misconfiguration change the RADIUS/(D)TLS clients so that they use RADIUS/UDP.  The server has essentially no way of knowing that this has taken place, because (as noted above) it has few options for distinguishing RADIUS/UDP clients behind a NAT.\r\n\r\nAs a result, I think the text is useful, and should stay in.",
          "createdAt": "2025-05-17T11:45:52Z",
          "updatedAt": "2025-05-17T11:45:52Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "should be fixed with the new paragraph introduced in f16113d",
          "createdAt": "2025-07-20T12:05:51Z",
          "updatedAt": "2025-07-20T12:05:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6L9F4L",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-04T13:18:51Z",
          "updatedAt": "2024-10-04T13:18:51Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'm not sure exactly what the problem here is and if the proposed solution is correct.\r\n\r\nI'll try to put it the way I understand the problem:\r\n\r\nA 10.0.0.1 (RADIUS/DTLS) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:2083\r\nB 10.0.0.2 (RADIUS/UDP) --> NAT (translated to source 192.0.2.1:12345) --> RADIUS server 203.0.113.1:1812\r\n\r\nSo now the RADIUS server has two UDP connections to 192.0.2.1:12345, but since the port on the RADIUS server side is different, the NAT can translate the UDP packets from source port 2083 to A and the ones from 1812 to B.\r\n\r\nIn my view, the problem here is that, if the server mixes those up, the server is at fault for allowing the client list for RADIUS/UDP to merge with the client list for RADIUS/DTLS.\r\nThose two client lists should be separate (at least in terms of IP-Addr/Port).\r\n\r\nWe cannot force every client behind a NAT to behave this way, because the NAT may be responsible for a huge variety of customer nets, and we can't mandate them to speak to each other.\r\n\r\nExample: Carrier-Grade NAT (CGN), Company A has a Dual-Stack internet connection with CGN for v4 and uses legacy-RADIUS, Company B has the same, but uses RADIUS/(D)TLS for their connection. We can't define a standard where Company A would now be forced to migrate to RADIUS/(D)TLS. They have no way of knowing that Company B is using DTLS with the same server. And we shouldn't mandate that the CGN keeps track of all possible connections and makes sure that no source port gets re-used if RADIUS/(D)TLS and RAIDUS/UDP are used with the same server.",
              "createdAt": "2024-10-04T13:18:51Z",
              "updatedAt": "2024-10-04T13:18:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6MYUsP",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T18:05:08Z",
          "updatedAt": "2024-10-08T18:05:08Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Fortunately any kind of NAT is not going to blend this to the same source IP and port (to the same destination IP and port) as it would have no way to figure out what to do with the responses from the server (ie. which client gets them); ignoring the case of the idle timeout ending a flow and starting the new one.\r\n\r\nOtherwise I can only see this attack working if a server ignored the destination IP/port. Maybe I am missing something...",
              "createdAt": "2024-10-08T18:05:08Z",
              "updatedAt": "2024-10-08T19:29:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qvyDq",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Over all, I don't see NAT as a security consideration. Yes (D)TLS works way better behind a NAT than UDP - but that's just one more point why to use TLS in the first place - for practical reasons.",
          "createdAt": "2025-05-23T14:35:16Z",
          "updatedAt": "2025-05-23T14:46:35Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "This statement is fundametally wrong. RADIUS/UDP works perfeclty fine behind a NAT, as many Wifi deployments where each individual AP talks to the radius server directly demonstrates. The only caveat is that all RADIUS clients behind a nat MUST use the same shared secret.",
              "createdAt": "2025-05-23T14:35:16Z",
              "updatedAt": "2025-05-23T14:46:35Z"
            },
            {
              "originalPosition": 16,
              "body": "as @jimdigriz mentioned, a NAT cannot reuse a 5-tuple. In practice any NAT implementation I've come across won't even reuse the source port. So this is a non-issue to me.\r\nEven if a NAT would do that, the provisions in this draf state that any given port on a server MUST only accept one protocol, i.e. a port accepting DTLS packets must discard any packets that is not a TLS message.",
              "createdAt": "2025-05-23T14:42:26Z",
              "updatedAt": "2025-05-23T14:46:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qwKhF",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-23T15:03:38Z",
          "updatedAt": "2025-05-23T15:03:38Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "The \"fundamentally incompatible\" phrase is not about whether it works, but whether it breaks the security model of RADIUS.  Having multiple clients behind a NAT might \"work\", but it has not been standardized in the RFCs.\r\n\r\nHaving multiple clients share the same secret is bad security practice, and should not be recommended by a standard,.",
              "createdAt": "2025-05-23T15:03:38Z",
              "updatedAt": "2025-05-23T15:03:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6qwW1k",
          "commit": {
            "abbreviatedOid": "3b26c02"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-23T15:19:07Z",
          "updatedAt": "2025-05-23T15:19:07Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Aa NAT is allowed to re-use a source port after 30 seconds without traffic.  So the issue should be discussed here, I think.\r\n\r\nHaving different server ports for UDP vs DTLS addresses some of the security issues, but it still allows for down-grade attacks.\r\n\r\nWhen there are both UDP and DTLS clients are behind a NAT, then it is possible for a misconfiguration to turn a DTLS client into a UDP client.  Since the server accepts both kinds of packets, it must accept these packets.  And it may be difficult for the server to tell that this is happening.\r\n\r\nWe should really recommend against allowing both UDP and DTLS clients behind a NAT.  If we don't discuss it here, then I expect the SECDIR reviewer or the IESG will point it out.",
              "createdAt": "2025-05-23T15:19:07Z",
              "updatedAt": "2025-05-23T15:19:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOLrzygc56q4c1",
      "title": "Security Consideration: Wildcard Clients",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/17",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added subsection for Wildcard Clients (from RFC 7360 Section 10.6)",
      "createdAt": "2024-09-06T13:50:05Z",
      "updatedAt": "2025-05-14T18:38:21Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "wildcard-clients",
      "headRefOid": "1c0759df6ab4a748b1ae3b37557166d63dbbdf3c",
      "closedAt": "2025-05-14T18:38:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2024-09-06T14:01:36Z",
          "updatedAt": "2024-09-06T14:01:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good, though I'm not convinced it warrants opening a whole new section. Maybe we could include this specification somewhere else?\r\nWe have a bit of discussion on IP ranges already in the \"Connecting Client Identity\" section (currently 4.3)\r\n\r\nEdit: Sorry, didn't see that this was in the security considerations section.\r\nMy point still somewhat stands, but with one addition: For security considerations, I would suggest to add a bit more text why this is not an issue with RADIUS/(D)TLS, what we gain from identifying the client, etc.",
          "createdAt": "2024-10-04T13:22:09Z",
          "updatedAt": "2024-10-04T13:24:47Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "NONE",
          "body": "Could we change 'wildcard' to something else? One reason is that because this document relates to TLS, it's easy to get confused between wildcard clients and wildcard certificates. The second reason is that it gives the possibility to use 'wildcard' only when discussing about wildcard certificate.\r\n\r\nI see that there's nothing about wildcard certificates currently in the draft or RFCs. There probably should be? Ban them altogether (easy) or define how they are to be used (more work). Edit: pull request #4 adds a note about wildcard certificates.",
          "createdAt": "2024-10-04T17:03:18Z",
          "updatedAt": "2024-10-04T17:07:13Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 for not using \"wildcard\" when talking about clients.",
          "createdAt": "2024-10-04T17:22:07Z",
          "updatedAt": "2024-10-04T17:22:07Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the whole \"Connecting Client Identity\" is not used anywhere in this document, there is no point in mentioning this again for ip-range-config clients.\r\n\r\nHow to identify clients and what to do when you have identified a client is out-of-scope for this document.\r\nWe only make sure that the client has a valid config. Whether or not it's the same client is not important for RADIUS/(D)TLS, but a general RADIUS issue.\r\nI'm going to close the PR.",
          "createdAt": "2025-05-14T18:38:21Z",
          "updatedAt": "2025-05-14T18:38:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOLrzygc56rxFz",
      "title": "Security Consideration: Crypto-Agility",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/18",
      "state": "CLOSED",
      "author": "ethan-thompson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "Added some basic text to reference the Deprecating Insecure Practices in RADIUS document (to address RFC 7360 Section 10.1)",
      "createdAt": "2024-09-06T16:02:52Z",
      "updatedAt": "2025-05-14T18:41:47Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "14ac56b2132bc2989536d94cea917dad71539bf0",
      "headRepository": "ethan-thompson/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "security-considerations-crypto-agility",
      "headRefOid": "75f3d6d19314e14940458386c31434a16f23572d",
      "closedAt": "2025-05-14T18:41:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps\r\n\r\n\r\n# Crypto-Agility\r\n\r\nCrypto-agility requirements were discussed extensively in {{RFC6421}}.  {{RFC6614, Appendix C}} described how these requirements were met for RADIUS/TLS.  {{RFC7360, Section 10.1}} described how these requirements were met for RADIUS/DTLS.   The final outcome of the {{RFC6421}} crypto-agility requirements are discussed in {{?I-D.ietf-radext-deprecating-radius, Section 6.3}}.\r\n\r\nThis specification defers to {{?I-D.ietf-radext-deprecating-radius}} for all discussion of crypto-agility in RADIUS.  In short, TLS satisfies the requirements of {{?I-D.ietf-radext-deprecating-radius}}, and there is no need to define RADIUS-specific cryptographic primitives.\r\n\r\n\r\n",
          "createdAt": "2024-09-06T20:24:16Z",
          "updatedAt": "2024-09-06T20:24:33Z"
        },
        {
          "author": "ethan-thompson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I like your suggestion much better",
          "createdAt": "2024-09-09T14:08:24Z",
          "updatedAt": "2024-09-09T14:08:24Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I also like the suggestion from Alan.\r\nI'd reference the deprecating radius draft as normative and have them published as cluster. (But that's editorial. The content looks good to me)",
          "createdAt": "2024-10-04T13:27:49Z",
          "updatedAt": "2024-10-04T13:27:49Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd prefer to publish the deprecating document first.  It's essentially done.  Given issues like the BlastRADIUS vulnerability, I think it's preferable to have an official RFC describing what to do.  Otherwise as we've seen, implementors may do \"inventive\" things.\r\n\r\nThe TLSbis document is likely to take a while to settle.",
          "createdAt": "2024-10-04T13:34:47Z",
          "updatedAt": "2024-10-04T13:34:47Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Fine by me, in this case it's even easier to reference it as normative.",
          "createdAt": "2024-10-04T13:37:32Z",
          "updatedAt": "2024-10-04T13:37:32Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "see #20, further discussion over there.",
          "createdAt": "2025-05-14T18:41:46Z",
          "updatedAt": "2025-05-14T18:41:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOLrzygc5_XSYB",
      "title": "Update to RFC9525 Guidance",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/19",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've added this pull request as documentation for further discussions.\r\n\r\nThis is mainly the discussion from #4 with the things removed/added we discussed in the interim.",
      "createdAt": "2024-10-21T18:58:43Z",
      "updatedAt": "2025-07-17T12:13:07Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c458813a6d507981a69298ce6c3716b492b0aee0",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-rfc9525-guidance",
      "headRefOid": "5ef77e7823114e7d57b6bec750c006af3cce812e",
      "closedAt": "2024-10-21T19:04:57Z",
      "mergedAt": "2024-10-21T19:04:57Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "4f6bcde1ac3354dd4cc057e88d89a02297b6f962"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 20,
      "id": "PR_kwDOLrzygc6AuVgx",
      "title": "Add some text for agility",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/20",
      "state": "CLOSED",
      "author": "jimdigriz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Moved the text from draft-ietf-radext-deprecate-radius and rejig it to work here.\r\n\r\nAs draft-ietf-radext-deprecate-radius does not deliver the agility it-self on these points whilst draft-ietf-radext-radiusdtls-bis (and RFC6614 and RFC7360) do, the references I feel should belong here.\r\n\r\nAddresses https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/18",
      "createdAt": "2024-11-03T12:54:41Z",
      "updatedAt": "2025-06-01T10:24:18Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "6f6500732cf450eeee8d2363d4c5a986266f6173",
      "headRepository": null,
      "headRefName": "agility",
      "headRefOid": "5f2d1afb7c9e2b1beb1800a33ef9f5764d947251",
      "closedAt": "2025-06-01T10:24:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6pWMMF",
          "commit": {
            "abbreviatedOid": "5f2d1af"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T18:41:25Z",
          "updatedAt": "2025-05-14T18:41:26Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nCrypto-agility requirements for the RADIUS protocol were discussed extensively in {{?RFC6421}}. {{RFC6614, Appendix C}} described how those requirements were met for RADIUS/TLS and {{RFC7360, Section 10.1}} describes the same for RADIUS/DTLS. For clarity, the final outcome of the those discussions are repeated, using the text of {{RFC7360}} with some minor modifications to update references, without changing the content.\r\n```\r\n\r\nIt's not \"crypto-agility in general\" but \"crypto-agility for RADIUS\"\r\nWe should make that clear.",
              "createdAt": "2025-05-14T18:41:25Z",
              "updatedAt": "2025-05-14T18:41:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6pWO7r",
          "commit": {
            "abbreviatedOid": "5f2d1af"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T18:46:27Z",
          "updatedAt": "2025-05-14T18:46:27Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Perhaps add a ref to https://datatracker.ietf.org/doc/html/draft-ietf-radext-deprecating-radius-05, which discusses crypto agility",
              "createdAt": "2025-05-14T18:46:27Z",
              "updatedAt": "2025-05-14T18:46:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOLrzygc6LdgeP",
      "title": "Propose Loopback-Attack text",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/21",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Propose Loopback-Attack text and move to subsection of Proxy",
      "createdAt": "2025-02-17T13:27:37Z",
      "updatedAt": "2025-03-03T22:10:55Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "96e64c166fece6d27cf5dc6912990feedb9ded1d",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-security-loopback-attack",
      "headRefOid": "36937ce0849a0ea499f393da398936526926bed9",
      "closedAt": "2025-03-03T22:10:55Z",
      "mergedAt": "2025-03-03T22:10:55Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "d57d9a112ea3755738996987c40e6f92ec3b30c1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6c82uJ",
          "commit": {
            "abbreviatedOid": "9411b45"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T14:27:31Z",
          "updatedAt": "2025-02-21T14:34:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nRADIUS/(D)TLS nodes that are configured to act both as client and server, typically in a proxy configuration, may be vulnerable to attacks where an attacker mirrors back all traffic to the node.\r\nTherefore, nodes that are capable of acting as both client and server SHOULD implement mitigations to avoid accepting connections from itself.\r\nOne example of a potentially vulnerable configuration is a setup where the RADIUS/(D)TLS server is accepting incoming connections from any address (or a wide address range).\r\nSince the server may not be able to verify the certificate subject or subject alternate names, the trust is based on the certificate issuer or certificate OID.\r\nHowever, in this case, the client certificate which the RADIUS/(D)TLS node uses for outgoing connections on the client side might also satisfy the trust check of the server side.\r\nOther scenarios where the identification of an outgoing connection satisfies the trust check of an incoming one are possible, but are not enumerated here.\r\n```",
              "createdAt": "2025-02-21T14:27:31Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nEither through misconfiguration, erroneous or spoofed dynamic discovery, or an attacker rerouting TLS packets, a proxy might thus open a connection to itself, creating a loop.\r\nSuch attacks have been described for TLS-PSK [selfie], dubbed a selfie-attack, but are much broader in the Radius/(D)TLS case. In particular, as described above, they also apply to certificate based authentication.\r\n```\r\n\r\nThe link to `[selfie]` has not been provided. This should be included in the references.",
              "createdAt": "2025-02-21T14:29:41Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nImplementations SHOULD therefore detect connections from itself, and reject them.\r\nThere is currently no detection method that works universally for all use-cases and TLS implementations.\r\nSome possible detection methods are listed below:\r\n\r\n```\r\n\r\n(always add an empty line between text and item lists. the markdown parser does not recognize the itemized list as such otherwise.",
              "createdAt": "2025-02-21T14:30:55Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nThe application layer RADIUS protocol also offers some loop detection, e.g. using a Proxy-State attribute.\r\nHowever, these methods are not capable of reliably detecting and suppressing these attacks in every case and are outside the scope of this document. \r\n```",
              "createdAt": "2025-02-21T14:34:12Z",
              "updatedAt": "2025-02-21T14:34:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6c_MrL",
          "commit": {
            "abbreviatedOid": "a1adfb9"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T17:43:53Z",
          "updatedAt": "2025-02-21T17:43:57Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nSuch attacks have been described for TLS-PSK {{?RFC9257}}, dubbed a selfie-attack, but are much broader in the RADIUS/(D)TLS case. In particular, as described above, they also apply to certificate based authentication.\r\n```",
              "createdAt": "2025-02-21T17:43:54Z",
              "updatedAt": "2025-02-21T17:43:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6c_OdK",
          "commit": {
            "abbreviatedOid": "a1adfb9"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T17:47:26Z",
          "updatedAt": "2025-02-21T17:47:27Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nHowever, these methods are not capable of reliably detecting and suppressing these attacks in every case and are outside the scope of this document.\r\n```\r\n\r\n(the automatic build complains about trailing whitespaces)",
              "createdAt": "2025-02-21T17:47:26Z",
              "updatedAt": "2025-02-21T17:47:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6eNjtg",
          "commit": {
            "abbreviatedOid": "a040d73"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-03T14:49:02Z",
          "updatedAt": "2025-03-03T15:00:40Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n- Comparing client or server random used in the TLS handshake. While this is a very effective method, it requires access to values which are normally private to the TLS implementation.\r\n```",
              "createdAt": "2025-03-03T14:49:02Z",
              "updatedAt": "2025-03-03T15:00:40Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n- Sending a custom random number in an extension in the TLS client hello. Again, this is verify effective, but requires extension of the TLS implementation.\r\n```",
              "createdAt": "2025-03-03T14:49:27Z",
              "updatedAt": "2025-03-03T15:00:40Z"
            },
            {
              "originalPosition": 22,
              "body": "I don't really understand what this means.\r\nThe scenario I had in mind here was the following (can be either from the client or the server side, I'll make an example for the client side):\r\n* Client connects\r\n* Server sends server certificate\r\n* Client checks if the server certificate is equal to any server certificate that it would send itself\r\n\r\nThere should be no mixing of client and server certificates, because a scenario where the same cert is used as client and server cert is possible, but not what we are trying to solve here.\r\nIt is perfectly fine to have two separate certificates (one client, one server) and with the text above, as I read it, this check would say \"everything's fine\" because the client cert does not match any configured server certs.\r\n\r\n```suggestion\r\n- Comparing the incoming server certificate to all server certificates configured on the proxy. While in some scenarios this can be a valid detection method, using the same server certificate on multiple servers would keep these servers from connecting with each other, even when this connection is legitimate.\r\n```",
              "createdAt": "2025-03-03T15:00:32Z",
              "updatedAt": "2025-03-03T22:07:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOLrzygc6MDSzT",
      "title": "Malformed packets apply to both TLS and DTLS",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/22",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Statement about malformed packets apply to both TLS and DTLS. Reword slighlty and move to section 4.",
      "createdAt": "2025-02-21T13:41:22Z",
      "updatedAt": "2025-02-21T14:53:34Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "96e64c166fece6d27cf5dc6912990feedb9ded1d",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-malformed-packets",
      "headRefOid": "3edeec56cca17142207fe6cd01846239496a20b8",
      "closedAt": "2025-02-21T14:53:34Z",
      "mergedAt": "2025-02-21T14:53:34Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "8801686b7f1a9805600e52c809228f11b1f8b0d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6c8nuq",
          "commit": {
            "abbreviatedOid": "cd7e338"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T14:05:36Z",
          "updatedAt": "2025-02-21T14:14:25Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nAs a result the behavior with respect to discarded packets has to change, since a malformed RADIUS packet could impact the decoding of succeeding packets.\r\n\r\nWith DTLS, the \"next\" packet does not depend on proper decoding of the previous packet, since the RADIUS packets are sent in independent DTLS records.\r\nHowever, since both TLS and DTLS provide integrity protection and ensure that the packet was sent by the peer, a protocol violation at this stage implies that the peer is misbehaving.\r\n```",
              "createdAt": "2025-02-21T14:05:36Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nImplementations of this specification SHOULD read the \"silently discard\" texts in the RADIUS specification referenced above as \"silently discard and close the connection\".\r\n```\r\n\r\nor\r\n\r\n```suggestion\r\nImplementations of this specification SHOULD treat the \"silently discard\" texts in the RADIUS specification referenced above as \"silently discard and close the connection\".\r\n```",
              "createdAt": "2025-02-21T14:07:33Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            },
            {
              "originalPosition": 13,
              "body": "(Error was the same in the previous version, but now I noticed it.)",
              "createdAt": "2025-02-21T14:08:03Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThat is, the implementation SHOULD send a TLS close notification and, in the case of RADIUS/TLS, the underlying TCP connection MUST be closed if any of the following circumstances are seen:\r\n```\r\n\r\nThe original text was specific for RADIUS/TLS, and RADIUS/DTLS does not have a \"connection\", and closing the UDP socket is an implementation detail.\r\nI don't have a strong opinion about it, but that's what just came to my mind.",
              "createdAt": "2025-02-21T14:13:11Z",
              "updatedAt": "2025-02-21T14:14:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOLrzygc6MDrUs",
      "title": "update DTLS packet legnths",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/23",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "DTLS handles application data based on DTLS records, so length and padding statements should apply to those records and not the the whole packet.",
      "createdAt": "2025-02-21T14:26:12Z",
      "updatedAt": "2025-02-21T14:37:09Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "dc4229e4cfa2237b231a4261b6f127a28ac2d362",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-dtls-packet-length",
      "headRefOid": "91ad0c7b53bded178b0c81507e9d2bae114c2eea",
      "closedAt": "2025-02-21T14:37:09Z",
      "mergedAt": "2025-02-21T14:37:09Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "e165b488000948c597a70e86b986fd3b93ff1b49"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOLrzygc6NzWfs",
      "title": "Suggestion for text for post-handshake auth",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/25",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Text as per Heikki's comments on the radext ML",
      "createdAt": "2025-03-07T16:52:02Z",
      "updatedAt": "2025-07-17T12:12:59Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_handshake_authentication",
      "headRefOid": "959bc0e0019125c693ef1707652037b17a1def57",
      "closedAt": "2025-05-26T11:49:46Z",
      "mergedAt": "2025-05-26T11:49:46Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "787bd2fdf7a6ec74d9983a73c7cc4eece0bb770f"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this looks fine.",
          "createdAt": "2025-04-16T11:48:07Z",
          "updatedAt": "2025-04-16T11:48:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 30,
      "id": "PR_kwDOLrzygc6V1mU-",
      "title": "Update text for Path MTU",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/30",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a suggestion for different wording on Path MTU. (See #27 for some discussion)\r\n\r\nThis change probably should go to the list of changes, since in RFC 7360, PMTU was `SHOULD`, I changed it out to `MAY`\r\n\r\nSuggestions/comments/... welcome.",
      "createdAt": "2025-05-12T13:18:46Z",
      "updatedAt": "2025-07-17T12:13:04Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_path_mtu_discovery",
      "headRefOid": "098deeafd64792b58f84ab4f5376a04bf0c5ed75",
      "closedAt": "2025-05-26T11:48:18Z",
      "mergedAt": "2025-05-26T11:48:18Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "e4796194f788be6d7ab7c336f6cbec697f10948d"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me.",
          "createdAt": "2025-05-12T13:37:06Z",
          "updatedAt": "2025-05-12T13:37:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 31,
      "id": "PR_kwDOLrzygc6V2Te6",
      "title": "Text suggestion for TLS Record count limitation",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/31",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "see #28 for discussion\r\n\r\nfeedback/improvements/... welcome",
      "createdAt": "2025-05-12T14:21:44Z",
      "updatedAt": "2025-07-17T12:13:05Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_tls_record_count_limit",
      "headRefOid": "e064fb7de19ebb6205ade741ff97260b44be0243",
      "closedAt": "2025-05-27T08:57:49Z",
      "mergedAt": "2025-05-27T08:57:49Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "b7c70027805779e0f53267e644072047a5989319"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6o4wSp",
          "commit": {
            "abbreviatedOid": "0f9aebf"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T14:27:24Z",
          "updatedAt": "2025-05-12T14:27:24Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Perhaps explain when they're rotated?\r\n\r\n```\r\n... the encryption keys have to be rotated regularly, depending on both the amount of data which was transferred, and on the encryption method.  See {{RFC8446, Section 5.5}} for more information.\r\n```",
              "createdAt": "2025-05-12T14:27:24Z",
              "updatedAt": "2025-05-12T14:27:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6o5NNZ",
          "commit": {
            "abbreviatedOid": "0f9aebf"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-12T15:00:37Z",
          "updatedAt": "2025-05-12T15:00:37Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Sounds good. I've also added the reference to the CFRG draft on AEAD limits",
              "createdAt": "2025-05-12T15:00:37Z",
              "updatedAt": "2025-05-12T15:00:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOLrzygc6V2eUm",
      "title": "Reword the DTLS padding handling on the receiving end",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/32",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As suggested by Alexander Clouter @jimdigriz in #24 \r\n\r\nI have changed the wording a bit, not exactly as suggested, hopefully still making it a bit less ambiguous.\r\n\r\nSuggestions/Improvements/Comments/... welcome.",
      "createdAt": "2025-05-12T14:37:47Z",
      "updatedAt": "2025-07-17T12:13:06Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_dtls_record_padding",
      "headRefOid": "bf7368e72618f74094a4405acbbeabfb28cd9f77",
      "closedAt": "2025-05-26T11:49:11Z",
      "mergedAt": "2025-05-26T11:49:11Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "4b8a40d4033b624022e6468825a1ebc3b1e37559"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "PR_kwDOLrzygc6V-9FG",
      "title": "Alternative wording for session closure.",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/33",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Originally proposed text from #6, with the changes suggested by Alan. Slight changes in the text.\r\n\r\nOne discussion item: Should for RADIUS proxies\r\nAccounting-Request/CoA-Request/Disconnect-Requests  still be processed on the outgoing layer and retransmitted?\r\n\r\nFor the RADIUS server we say that the server may process these packets, and just discard the answer.\r\nMaybe the same should be done for RADIUS proxies. On the other hand, if we discard the answer anyway, retransmitting may also be pointless.",
      "createdAt": "2025-05-13T11:28:17Z",
      "updatedAt": "2025-07-07T14:21:09Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_response_cache",
      "headRefOid": "799f5014c136ed6f8ac35296b6a4a29984a5a676",
      "closedAt": "2025-07-07T14:20:56Z",
      "mergedAt": "2025-07-07T14:20:56Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "a0d726694003ea9acefa93f1dea73aec6d6be13b"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would say that on closing a session, all packets which were sent on that session (without a response) should be treated as if they had just been received from the client.  The packets should be re-processed through the forwarding path.",
          "createdAt": "2025-05-13T14:44:55Z",
          "updatedAt": "2025-05-13T14:44:55Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "For the \"client\" side of the broken connection. yes.\r\nThe question is for the \"server\" side of the broken connection. should they retransmit on their uplink or just delete the packet and trust that the client will try a different path for the outstanding packet?",
          "createdAt": "2025-05-13T14:59:26Z",
          "updatedAt": "2025-05-13T14:59:26Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For a client which sees a broken \"outbound\" connection, it can retransmit the packet on another connection.  This applies to proxies, too.\r\n\r\nFor a server which sees a broken \"inbound\" connection, it should just discard the request.  There is no globally unique packet ID, so the server has no way of detecting the \"same\" packet which is retransmitted from the client over a different inbound link.  So no matter what the server does, it can't send any reply to the client.\r\n\r\nTherefore, the only thing that the server can do is to discard the request.",
          "createdAt": "2025-05-13T15:05:18Z",
          "updatedAt": "2025-05-13T15:05:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOLrzygc6WNHNF",
      "title": "Move text for session resumption and clarify",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/34",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Text taken from #7 with some minor changes:\r\n\r\nInstead of generally referencing RFC5077, it is now referenced specifically for servers, since servers issue the tickets. The client must still cache all relevant data.",
      "createdAt": "2025-05-14T18:07:31Z",
      "updatedAt": "2025-07-17T12:12:58Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_session_resumption",
      "headRefOid": "b7cde9b15aaf2223316aa6bccc56ac101dc65ee3",
      "closedAt": "2025-07-07T16:30:23Z",
      "mergedAt": "2025-07-07T16:30:23Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "5911967dd58d4f919aa14719e37f22ead7864946"
      },
      "comments": [
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm personally no longer convinced that session resumption SHOULD be implemented - given that connections tend to be long running anyway and the complexity it infers. Of course, it MAY be implemented.\r\n\r\nBut I'm not going to argue about that detail. The important thing is what to do **if** it is implemented, which is fine with me.\r\n\ud83d\udc4d ",
          "createdAt": "2025-05-23T15:21:48Z",
          "updatedAt": "2025-05-23T15:22:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @fmauchle , that's a good comment.\r\n\r\nMaybe we can do it similar to the \"RADIUS/TLS or RADIUS/DTLS\"\r\n\r\nMy suggestion would then be:\r\nRADIUS/(D)TLS clients MAY implement session resumption.\r\nRADIUS/(D)TLS servers SHOULD implement session resumption.\r\n\r\nThe need for session resumption highly depends on whether or not the sessions are re-opened on a regular basis or if they are long-standing.\r\nI would assume that in most cases, the RADIUS/(D)TLS client will decide on whether or not to close the connection, and in this case clients that leave the connection open for a long time would not have the need to implement session resumption.\r\nFor the server, implementing session resumption is helpful when dealing with clients that re-connect often.\r\n\r\nBut I would not be opposed to make this a MAY altogether.",
          "createdAt": "2025-05-26T08:29:35Z",
          "updatedAt": "2025-05-26T08:29:35Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On May 26, 2025, at 4:29\u202fAM, Jan-Frederik Rieckers ***@***.***> wrote:\r\n> My suggestion would then be:\r\n> RADIUS/(D)TLS clients MAY implement session resumption.\r\n> RADIUS/(D)TLS servers SHOULD implement session resumption.\r\n\r\n  If we're not doing to use \"MUST\", then I would lean towards \"SHOULD\" for both client and server.\r\n\r\n> The need for session resumption highly depends on whether or not the sessions are re-opened on a regular basis or if they are long-standing.\r\n> I would assume that in most cases, the RADIUS/(D)TLS client will decide on whether or not to close the connection, and in this case clients that leave the connection open for a long time would not have the need to implement session resumption.\r\n\r\n  The overhead of doing a full re-authentication is tiny, compared to a long-lived connection.\r\n\r\n  That being said, I don't see any reason to _not_ implement session resumption.  Most RADIUS servers which do EAP (i.e. all of the major ones) already do session resumption for TLS-based EAP methods.  Doing session resumption for RADIUS/TLS is a tiny cost.\r\n\r\n  I don't have strong reasons for requiring session resumption.  I can't think of cases where it would make a significant difference.  In contrast, doing session resumption for TLS-based EAP methods has a noticeable effect on authentication latency.\r\n\r\n",
          "createdAt": "2025-05-26T10:54:20Z",
          "updatedAt": "2025-05-26T10:54:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDOLrzygc6WNRJm",
      "title": "Add text for default trust anchors",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/35",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Rewording from #15, see discussion there.\r\n\r\nI have left out the reasoning for this, since it does not fit in the normative text, if needed, we can add a subsection in the security considerations.",
      "createdAt": "2025-05-14T18:28:40Z",
      "updatedAt": "2025-07-17T12:12:56Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "271e5c78e36c2ff01580259196d83a292617bfcd",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_trust_anchor",
      "headRefOid": "fefc43cbe17c8d170fb9a3fef4fd329a0f5b4ba3",
      "closedAt": "2025-05-26T11:43:28Z",
      "mergedAt": "2025-05-26T11:43:28Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "fe5f8a0fef3bb2168576f67085c7f95aeb115822"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6rHrIp",
          "commit": {
            "abbreviatedOid": "fefc43c"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T12:40:19Z",
          "updatedAt": "2025-05-27T12:40:20Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Typo \"preclude\" and \"configured\"",
              "createdAt": "2025-05-27T12:40:20Z",
              "updatedAt": "2025-05-27T12:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc6rHvmS",
          "commit": {
            "abbreviatedOid": "fefc43c"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T12:46:12Z",
          "updatedAt": "2025-05-27T12:46:12Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "fixed in commit 52122b4\r\nThanks.",
              "createdAt": "2025-05-27T12:46:12Z",
              "updatedAt": "2025-05-27T12:46:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 38,
      "id": "PR_kwDOLrzygc6fK-UI",
      "title": "clarify practical use of PKIX client identity",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/38",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarify the technicality of PKIX identity versus its practical use of subject or subjectAltName, to address #26.",
      "createdAt": "2025-07-16T11:59:08Z",
      "updatedAt": "2025-07-17T08:26:19Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "5911967dd58d4f919aa14719e37f22ead7864946",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "pkix-client-identity",
      "headRefOid": "2c0bbed81c083199c4d50584c55ce1e8ce62b5cb",
      "closedAt": "2025-07-17T08:26:19Z",
      "mergedAt": "2025-07-17T08:26:19Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "83f68e29cbe83e29253721b989e26079fc533f91"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc60gRxG",
          "commit": {
            "abbreviatedOid": "611f89d"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T07:56:03Z",
          "updatedAt": "2025-07-17T07:56:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The general issue of \"what do I use to apply policies\" is not unique to TLS-X.509-PKIX, so I would suggest putting it in a separate paragraph.\r\nI've reworded it slightly. (and removed the whitespace at the end of the line, so kdrfc doesn't complain)\r\n\r\n```suggestion\r\nWith TLS-X.509-PKIX, a client is uniquely identified by the tuple of the serial number of the presented client certificate and the issuer.\r\n\r\nIn practice, identification of unique clients is not always necessary and could be based on the subject of the presented certificate or a subjectAltName entry.\r\nWhile this identification technique could match multiple distinct certificates and therefore distinct clients, it is often sufficient, e.g. for the purpose of applying policies.\r\n```",
              "createdAt": "2025-07-17T07:56:03Z",
              "updatedAt": "2025-07-17T07:56:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "PR_kwDOLrzygc6fLGhw",
      "title": "Forbid CN only for servers",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/39",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think this proposal was lost among the lenghy discussion on the mailing list:\r\n\r\nRFC9525 mainly applies to identify servers, but not clients. Specifically the provision that Common Name MUST NOT be used to identify a server doesn't really apply to clients. To the contrary it seems to be perfectly reasonable to identfy a client based on its Common Name.\r\n\r\nProposal: move the Common Name provision to the details of server identity validation perfomred by clients.",
      "createdAt": "2025-07-16T12:12:43Z",
      "updatedAt": "2025-07-20T11:46:15Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "9d0f45f9b88ed231cf51b18424ca851330aa9f0f",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "forbid-cn-server-only",
      "headRefOid": "f1671665cb1afeca0dcd9fef7701e84af39e1405",
      "closedAt": "2025-07-20T11:46:15Z",
      "mergedAt": "2025-07-20T11:46:15Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "daa3c02c7f3ba9304be937a8966ca156a7302109"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would argue differently.\r\nThe problem with the CN RDN, as far as I understand, is that it is not typed. This can be a problem for both client and server.\r\n\r\nIf we want to identify a client based on a domain name, then we should not use the CN, but SAN:DNS. If it's an IP address, SAN:IP.\r\nOnly if we want to identify a client based on an arbitrary string with custom format (e.g. a customer number stored in CN) and within a private CA it is ok to use the CN.\r\n\r\nThe reasoning for this approach:\r\nIf we use identifiers with well-defined format, (such as IP addresses or DNS names), we should use the well-defined certificate fields, and we can use the same validation routines for client and server certificate validation.\r\nOnly if explicitly configured the validation should use the CN.\r\n\r\nTheoretically we could also allow CN for such identifiers for server certificates, I'm not sure whether this is needed (and this would be in direct violation of RFC9525)\r\n\r\nThe draft currently states:\r\n> Implementations MAY allow configuration of a set of additional properties of the certificate to check for a peer's authorization to communicate\r\n\r\nEven if it contradicts the \"MUST NOT use CN\", it could be possible to configure a CN check via this route.",
          "createdAt": "2025-07-17T07:48:28Z",
          "updatedAt": "2025-07-17T07:48:28Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The draft still requires the use of subjectAltNames for client certificates, **IF** its DNS name or IP address is known.\r\n\r\nHowever, for clients this is more often not the case (in contrast to servers), so strictly forbidding the use of CN might be overkill (CN should still not be used to match a DNS name)",
          "createdAt": "2025-07-17T08:21:30Z",
          "updatedAt": "2025-07-17T08:21:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 41,
      "id": "PR_kwDOLrzygc6fXjpD",
      "title": "Add explicit text explaining how to send RADIUS pkt via TLS",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/41",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When looking over the document, I noticed that at no point we had an explicit specification that RADIUS packets are to be concatenated, without padding, and so on.\r\nThis fixes this, and it does nothing else than document explicitly what is inferred at many points in the document already.\r\n(Theoretically, it is implied at many points in this document, that this is the case, but it's always better to have it explicitly in there)\r\n\r\nMaybe this is worth adding in the \"list of changes\", maybe not, I'm open for suggestions on this.",
      "createdAt": "2025-07-17T12:09:38Z",
      "updatedAt": "2025-07-22T18:42:10Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "9d0f45f9b88ed231cf51b18424ca851330aa9f0f",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_explicit_tls_transmission",
      "headRefOid": "e2b4146b4194c2bea68f548a6fd0a025327ec229",
      "closedAt": "2025-07-20T11:43:37Z",
      "mergedAt": "2025-07-20T11:43:37Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "10ada7cdbb12f2401971c16ddfa8ac38ac1d803f"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Minor comments, but I think this is a good addition.",
          "createdAt": "2025-07-17T13:08:08Z",
          "updatedAt": "2025-07-17T13:08:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc60kd-C",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T13:05:11Z",
          "updatedAt": "2025-07-17T13:05:11Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "\"RADIUS\"",
              "createdAt": "2025-07-17T13:05:11Z",
              "updatedAt": "2025-07-17T13:05:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc60kfmW",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T13:06:56Z",
          "updatedAt": "2025-07-17T13:06:56Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I don't think this is true?  Even RADIUS/UDP depended on the Length field.  RFC 2865 says:\r\n\r\n```\r\n      Octets outside the range of the Length field\r\n      MUST be treated as padding and ignored on reception.\r\n```\r\n\r\nSo the length of the packet is explicit, not implicit.\r\n\r\nPerhaps just delete this sentence.  ",
              "createdAt": "2025-07-17T13:06:56Z",
              "updatedAt": "2025-07-17T13:06:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc60kfzx",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T13:07:10Z",
          "updatedAt": "2025-07-17T13:07:10Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Perhaps `Length` field?",
              "createdAt": "2025-07-17T13:07:10Z",
              "updatedAt": "2025-07-17T13:07:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc60nVq7",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T16:19:40Z",
          "updatedAt": "2025-07-17T16:19:41Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "fixed. *sigh*",
              "createdAt": "2025-07-17T16:19:40Z",
              "updatedAt": "2025-07-17T16:19:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc60nV34",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T16:19:58Z",
          "updatedAt": "2025-07-17T16:19:58Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I've reworded it to be more clear what I mean. I hope it's fixed with that.",
              "createdAt": "2025-07-17T16:19:58Z",
              "updatedAt": "2025-07-17T16:19:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc60nXFd",
          "commit": {
            "abbreviatedOid": "ddbf152"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-17T16:21:43Z",
          "updatedAt": "2025-07-17T16:21:43Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I've changed it to code environment, and changed the other instances of this too.",
              "createdAt": "2025-07-17T16:21:43Z",
              "updatedAt": "2025-07-17T16:21:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOLrzygc6frVQ1",
      "title": "Convert 4-tuple to 5-tuple",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/43",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Generally, any session tracking is described with a 5-tuple, that also includes the protocol.\r\n\r\nTo be consistent with other specs, literature, ... we could just modify this and just statically set protocol to `UDP`\r\n\r\n(Thanks Fabian for the suggestion)",
      "createdAt": "2025-07-19T10:02:36Z",
      "updatedAt": "2025-07-22T18:42:14Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "9d0f45f9b88ed231cf51b18424ca851330aa9f0f",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_5tuple",
      "headRefOid": "bd326bf2fe3f281f0952fa0b6b28429d444a0c4a",
      "closedAt": "2025-07-20T11:42:12Z",
      "mergedAt": "2025-07-20T11:42:12Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "5250ccc41d17a566cfffda1b0cfe6851c0117f66"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 44,
      "id": "PR_kwDOLrzygc6gH58N",
      "title": "Fix typo in draft",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/44",
      "state": "MERGED",
      "author": "chrohrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "WGLC Comment"
      ],
      "body": "",
      "createdAt": "2025-07-22T18:16:55Z",
      "updatedAt": "2025-07-22T18:55:37Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "17514bba596a8c0997beac5a9e022a2bfdeaf406",
      "headRepository": "chrohrer/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "conctrast-typo",
      "headRefOid": "2816812dcca224142f176e8032c0ecd3d4795ece",
      "closedAt": "2025-07-22T18:55:37Z",
      "mergedAt": "2025-07-22T18:55:37Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "2fcc1a6a8c460262f7e7975f8f7906cdd01cadb6"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2025-07-22T18:55:32Z",
          "updatedAt": "2025-07-22T18:55:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 45,
      "id": "PR_kwDOLrzygc6gIDn1",
      "title": "Update draft-ietf-radext-radiusdtls-bis.md",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/45",
      "state": "MERGED",
      "author": "chrohrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "WGLC Comment"
      ],
      "body": "Remove reference to RADIUS/DTLS in RADIUS/TLS specific section",
      "createdAt": "2025-07-22T18:34:44Z",
      "updatedAt": "2025-07-22T18:59:13Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "17514bba596a8c0997beac5a9e022a2bfdeaf406",
      "headRepository": "chrohrer/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "remove-dtls-reference-in-tls-section",
      "headRefOid": "983f5c445a01a5b471d89bb1f5a1bb7769076730",
      "closedAt": "2025-07-22T18:59:13Z",
      "mergedAt": "2025-07-22T18:59:12Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "327a20e780522389338370d2f4905a6f5eec780c"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Ooops. good catch. Thank you.",
          "createdAt": "2025-07-22T18:59:00Z",
          "updatedAt": "2025-07-22T18:59:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 47,
      "id": "PR_kwDOLrzygc6gqoK5",
      "title": "be explicit about client source IP",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/47",
      "state": "CLOSED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs discussion",
        "WGLC Comment"
      ],
      "body": "When validating client certificates, the fact that the client may only connect from IP addresses to which a given DNS name resolves to (or the actual source addres when multiple IPs or IP prefix is configured) is only implied. Maybe better to state it explicitly.",
      "createdAt": "2025-07-25T17:12:34Z",
      "updatedAt": "2025-09-19T12:40:18Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "0bdcd9908d3ab5f231d631449fd42e481defd87d",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-explicit-client-source-ip",
      "headRefOid": "15eaff5b7344d078962f69c6a453215da598ad3e",
      "closedAt": "2025-09-19T12:40:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think that this should be mandated. It opens up a whole can of worms.\r\n* At which time is the lookup done?\r\n* What happens if the DNS changes?\r\n* How should the implementation behave if there is no DNS entry?\r\n\r\nI know that radsecproxy does this a certain way, other implementations might do it differently.\r\n\r\nWe could add a sentence with a word of warning that this should be considered, but I wouldn't mandate a special behavior.",
          "createdAt": "2025-07-28T13:59:14Z",
          "updatedAt": "2025-07-28T13:59:14Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's a balance between allowing people to do anything, and giving them guidance which is too specific. \r\n\r\nIt may be worth mentioning the issue, and giving options as to what can be done.\r\n\r\nMy concern (as always) is that if the spec is silent on a topic, people have no idea what to do, and therefore do something problematic.",
          "createdAt": "2025-07-28T14:34:12Z",
          "updatedAt": "2025-07-28T14:34:12Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think that this should be mandated. It opens up a whole can of worms.\r\n\r\nWe alerady mandate it for IP prefix, so I think it would only be consostent to the same for DNS names. This describes the default certificate validation, similar to whate we do to server certificates. And we already allow this check to be omitted, if the situation doesn't provide a fixed DNS name or IP address.\r\n\r\n> * At which time is the lookup done?\r\n> * What happens if the DNS changes?\r\n\r\nThis is implementation specific, and the same issue exists for clients resolving servers in the DNS. To be technically correct, repeating the lookup should be done latest when the DNS TTL expires (i.e. the DNS cache lifetime).\r\n\r\n> * How should the implementation behave if there is no DNS entry?\r\n\r\nThis paragraph describes explicitly the situation when a DNS entry exists. If it doesn't (but the client is configured by DNS name, it's simply an unknown client).\r\n\r\n> I know that radsecproxy does this a certain way, other implementations might do it differently.\r\n\r\nThat is exactly the point. While updating client cert validation to the current draft, I noticed it might accept a certificate (with SAN DNS) from a client, whose source address is not what that DNS name resolves to - and I think that is the wrong behavior. ",
          "createdAt": "2025-08-04T12:07:33Z",
          "updatedAt": "2025-08-04T12:07:55Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I get the point, I am convinced. Now the question is: should there be more explicit text for how and when to resolve DNS names to IP addresses on the server side?\r\n\r\nRight now the suggested change does not have any text explaining when and why to do this, and I think there should be at least some explanation and guidance.",
          "createdAt": "2025-08-15T12:26:46Z",
          "updatedAt": "2025-08-15T12:26:46Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the main issue with DNS queries is that the POSIX API doesn't return TTL.  So applications are pretty much stuck.\r\n\r\nFor new connections:\r\n\r\n* do lookups when the server needs to connect to a new server (first time it does lookup, or when it transitions from no connections to 1+ connection to the server)\r\n\r\nThen for ongoing connections:\r\n\r\n* do DNS lookups when DNS TTL expires (this is hard, as the POSIX APIs don't return TTL)\r\n* do DNS lookups any time any new connection is opened\r\n* do DNS lookups periodically, say every hour or two\r\n\r\nThere's also the issue of when to close connections.  If a server wishes to change all of the IPs associated with itself, it should first spin up servers at the new IPs, then update DNS, then shut down connections to the old IPs.\r\n\r\ni.e. if a connection remains open and active, there's no reason for the client to close the connection just because DNS changes.",
          "createdAt": "2025-08-15T14:30:53Z",
          "updatedAt": "2025-08-15T14:30:53Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, in theory you would have to do a lookup every time you need the IP address (i.e. for every new connection, outgoing and incoming), everything else is just caching. Hoever in practice, this caching is rather important especially for incoming connections. (I think stating the fact that you have to do a lookup in the first place is useless)\r\n\r\nAs Alan stated, at least the POSIX API doesn't provide caching hints (TTL), and I have no clue what would happen if you query that API for the same name repeatedly - would it do the caching? (I don't think so).\r\n\r\nWe may add a statement that servers \"SHOULD NOT cache longer than the DNS responses TTL\" (and referencd STD13 for its definition), being fully aware that most implementations won't follow that advise by the letter.",
          "createdAt": "2025-08-21T05:40:52Z",
          "updatedAt": "2025-08-21T05:40:52Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> As Alan stated, at least the POSIX API doesn't provide caching hints (TTL), and I have no clue what would happen if you query that API for the same name repeatedly - would it do the caching? (I don't think so).\r\n\r\nThe local C library should cache the results of the DNS query, for at least the TTL.  Perhaps this means that we should recommend clients do a DNS lookup every time they need to open a new connection.",
          "createdAt": "2025-08-21T14:27:10Z",
          "updatedAt": "2025-08-21T14:27:10Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "> Perhaps this means that we should recommend clients do a DNS lookup every time they need to open a new connection.\r\n\r\nThe problem is not the client, there the process of DNS lookup is quite easy.\r\nThe problem is the server, if clients are only configured by DNS name and not by IP address.\r\nShould the server look up every DNS-configured client the moment it gets a new connection to find out which one it is?\r\nWhat happens if there are multiple clients defined with a DNS name that resolves to the same IP address?\r\n\r\nI think it is ok to state that configuring a client by DNS only is only a convenience to put a human-readable name in the configuration instead of an IP address, and that the server should do a lookup at startup and then maybe periodically.",
          "createdAt": "2025-08-21T23:23:39Z",
          "updatedAt": "2025-08-21T23:23:39Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The problem is the server, if clients are only configured by DNS name and not by IP address.\r\n> Should the server look up every DNS-configured client the moment it gets a new connection to find out which one it is?\r\n\r\nIn theory yes. In practice its unrealistic, so implementors have to do some caching, or rely on the underlying library/OS to do the caching. A quick test on Debian (libc) it does no caching at all, every call to getaddrino() triggers multiple DNS queries (for A and AAAA records)\r\n\r\n> What happens if there are multiple clients defined with a DNS name that resolves to the same IP address?\r\n\r\nYou select the one for which its certificates SAN DNS matches the configured DNS name. \r\n",
          "createdAt": "2025-08-22T10:05:00Z",
          "updatedAt": "2025-08-22T10:05:00Z"
        },
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With rough consensus on the mailing list, this is not the right approach. Closing this PR.",
          "createdAt": "2025-09-19T12:40:18Z",
          "updatedAt": "2025-09-19T12:40:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 48,
      "id": "PR_kwDOLrzygc6j2R1R",
      "title": "Recommend closing connection upon certificate expiry",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/48",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Text suggestion for #46 ",
      "createdAt": "2025-08-15T14:33:56Z",
      "updatedAt": "2025-09-19T09:58:47Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "327a20e780522389338370d2f4905a6f5eec780c",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_cert_lifetime",
      "headRefOid": "d98f7caccad67d31b20a98bdc6c26c593338268c",
      "closedAt": "2025-09-11T09:42:31Z",
      "mergedAt": "2025-09-11T09:42:31Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "83c6ec7177f4c1d3268b92fe5245172566b620da"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 49,
      "id": "PR_kwDOLrzygc6j5ytL",
      "title": "Add text for RADIUS/DTLS retransmission behavior",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/49",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a first text suggestion for #42 ",
      "createdAt": "2025-08-15T22:28:00Z",
      "updatedAt": "2025-09-19T09:58:50Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "327a20e780522389338370d2f4905a6f5eec780c",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature_dtls_retransmissions",
      "headRefOid": "94c02342fe7a080777ec475ef210c46fa621e23e",
      "closedAt": "2025-08-21T23:24:13Z",
      "mergedAt": "2025-08-21T23:24:13Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "f90b8f249cc7450eb7c85c78d827d6c48efc8f34"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1",
          "createdAt": "2025-08-21T14:28:51Z",
          "updatedAt": "2025-08-21T14:28:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDOLrzygc6knqRn",
      "title": "Silent discard vs Protocol-Error",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/50",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "WGLC Comment"
      ],
      "body": "Changes to section 4.5 require sending Protocol-Error instead of silently discrading packets. Apply the same provision to section 4.10.",
      "createdAt": "2025-08-21T06:26:26Z",
      "updatedAt": "2025-09-19T09:50:16Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "327a20e780522389338370d2f4905a6f5eec780c",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-silentd-discard-vs-protocol-error",
      "headRefOid": "42bf09bb17eabe85a4f232e75b7362ec00b8da06",
      "closedAt": "2025-09-19T09:50:16Z",
      "mergedAt": "2025-09-19T09:50:16Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "1c9ef6bee61473d936bb28bf23f3c6b28fcb2c74"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me.",
          "createdAt": "2025-08-21T14:27:54Z",
          "updatedAt": "2025-08-21T14:27:54Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me, but maybe we should add a recommendation on the Error-Cause attribute?",
          "createdAt": "2025-09-10T14:01:20Z",
          "updatedAt": "2025-09-10T14:01:20Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@janfred yes, adding Error-Cause would be good, too",
          "createdAt": "2025-09-10T15:37:09Z",
          "updatedAt": "2025-09-10T15:37:09Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me",
          "createdAt": "2025-09-11T10:28:57Z",
          "updatedAt": "2025-09-11T10:28:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc6_WX3L",
          "commit": {
            "abbreviatedOid": "0c4b2b8"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-11T09:46:53Z",
          "updatedAt": "2025-09-11T09:47:51Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nFor request packets that would have been silently discarded in the previous specifications, servers SHOULD reply with a Protocol-Error {{!RFC7930, Section 4}} message to avoid request ID exhaustion, and servers SHOULD include an Error-Cause attribute indicating the type of failure. In any case, further processing of the original request MUST stop.\r\n```",
              "createdAt": "2025-09-11T09:46:54Z",
              "updatedAt": "2025-09-11T09:47:51Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n* Packet with an invalid code field (see {{radius_datagrams}} for details)\r\n```",
              "createdAt": "2025-09-11T09:47:19Z",
              "updatedAt": "2025-09-11T09:47:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDOLrzygc6pepg-",
      "title": "Add client source IP for clients configured by DNS",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/53",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs discussion",
        "WGLC Comment"
      ],
      "body": "This is an alternate text for #47 which does not mandate any behavior and instead just mentions this as option.\r\n\r\nIt does not contain any hints on what implementations / operators should do because I don't think we can say anything definitive about this.",
      "createdAt": "2025-09-19T10:35:09Z",
      "updatedAt": "2025-09-30T17:57:12Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "0bdcd9908d3ab5f231d631449fd42e481defd87d",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature/hint_dns_client_ip",
      "headRefOid": "b122b7b2ca15a07f0346528c5f17a3af3ec90dc9",
      "closedAt": "2025-09-25T11:33:33Z",
      "mergedAt": "2025-09-25T11:33:33Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "95d8e84137041e676db88f0896fc73f52d7ab458"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOLrzygc6qfTw7",
      "title": "Additional text as hint that TCP also changes transmission times",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/54",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per comments on the mailing list, maybe this is something that people implementing RADIUS/TLS should keep in mind. The most prominent case is Event-Timestamp vs. Acct-Delay-Time, but maybe it's also relevant for other cases.",
      "createdAt": "2025-09-25T11:44:15Z",
      "updatedAt": "2025-09-30T17:57:08Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "95d8e84137041e676db88f0896fc73f52d7ab458",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature/hint_transmission_time",
      "headRefOid": "b5b75e37c4c01ee870c48abed4970b61a1b66857",
      "closedAt": "2025-09-30T17:55:19Z",
      "mergedAt": "2025-09-30T17:55:19Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "a0450adbf505a092f2a8511a5272b224255f3530"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Additonally, this can lead to a significantly increased transmission time, especially compared to RADIUS/UDP, where a RADIUS packet either arrives only with the negligible transport delay or it is lost and needs to be retransmitted.\r\n\r\nThis isn't clear to me that TCP delays can be seconds.  Perhaps\r\n\r\nAdditonally, TCP retransmissions can occur seconds after the original data was sent, leading to a significantly increased transmission time, especially compared to RADIUS/UDP.  In contrast, RADIUS/UDP packets are usually received either quickly, or not at all.",
          "createdAt": "2025-09-25T15:19:04Z",
          "updatedAt": "2025-09-25T15:19:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7DzwqK",
          "commit": {
            "abbreviatedOid": "36ff710"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-30T14:12:29Z",
          "updatedAt": "2025-09-30T14:12:30Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nAdditionally, due to the architecture of TCP as reliable stream transport, TCP retransmissions can occur significantly later, even multiple seconds, after the original data was passed to the network stack by the application.\r\nIn contrast, RADIUS/UDP packets are usually received either quickly, or not at all, in which case the RADIUS/UDP stack triggers a retransmission of the packet on the application layer.\r\n```",
              "createdAt": "2025-09-30T14:12:29Z",
              "updatedAt": "2025-09-30T14:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7DzyHq",
          "commit": {
            "abbreviatedOid": "36ff710"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-30T14:13:18Z",
          "updatedAt": "2025-09-30T14:13:18Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "@alandekok I've reworded your suggestion a bit, I hope it captures what we want to say.",
              "createdAt": "2025-09-30T14:13:18Z",
              "updatedAt": "2025-09-30T14:13:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7D2Wv-",
          "commit": {
            "abbreviatedOid": "36ff710"
          },
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-30T16:22:36Z",
          "updatedAt": "2025-09-30T16:22:36Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "+1 from me",
              "createdAt": "2025-09-30T16:22:36Z",
              "updatedAt": "2025-09-30T16:22:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOLrzygc6qfge6",
      "title": "Add examples of allowed packet types",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/55",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Maybe this is a good example of what we want to say with the sentence before. It's always good to give examples.\r\n\r\nMaybe sufficient to fix #51 ?",
      "createdAt": "2025-09-25T12:02:08Z",
      "updatedAt": "2025-09-30T17:57:11Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "95d8e84137041e676db88f0896fc73f52d7ab458",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature/example_packet_types",
      "headRefOid": "d2d0b4cdc9295a49d6adfba33f84b9177911153c",
      "closedAt": "2025-09-30T14:05:55Z",
      "mergedAt": "2025-09-30T14:05:55Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "4db3d23c05a9fc1e3a1efc4e5fcf8bb186b4734f"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me.",
          "createdAt": "2025-09-25T15:19:23Z",
          "updatedAt": "2025-09-25T15:19:23Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDOLrzygc6sTZhs",
      "title": "Suggestions from 2025-10-03 radext emails",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/56",
      "state": "CLOSED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "These commits contain suggestions from my emails to radext on 2025-10-03. Most of them are clarifications. Main proposed changes are:\r\n* remove all TLS renegotiations 3e474a3c3b4aedd70e838d07d2815455380e7604\r\n* stop sending when Error-Cause is 406 'Unsupported Extension' 5916c67d5752b6cf3f32cb4195ed6776f6903e50\r\n\r\nCommit 738ab370157f6ec29ec04250ccc7b5bae4b08dc9 also attempts to clarify RFC 6614 response types replaced with Protocol-Error response. My understanding is that the RFC 6614 behaviour is replaced, but please check 738ab370157f6ec29ec04250ccc7b5bae4b08dc9",
      "createdAt": "2025-10-06T15:32:51Z",
      "updatedAt": "2025-10-23T08:09:33Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "hvn-oct-1",
      "headRefOid": "24bb5e1f68eb787b40c74187133b00df4e0180d6",
      "closedAt": "2025-10-23T08:09:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "In general:\r\nIt's a bit unfortunate, that this is one big pull request.\r\nNow we have to sort through everything at once and cannot discuss each issue separately.",
          "createdAt": "2025-10-06T16:04:20Z",
          "updatedAt": "2025-10-06T16:04:20Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In general: It's a bit unfortunate, that this is one big pull request. Now we have to sort through everything at once and cannot discuss each issue separately.\r\n\r\nI can easily split them into individual PRs(sans e.g. the 'unwanted' commit). Let me do that and we can then continue.",
          "createdAt": "2025-10-06T16:30:48Z",
          "updatedAt": "2025-10-06T16:30:48Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "> I can easily split them into individual PRs(sans e.g. the 'unwanted' commit). Let me do that and we can then continue.\r\n\r\nThanks :)\r\nAlso thanks for reading through the document and commenting.\r\n\r\nSome of the issues should definitely be fixed before publication.",
          "createdAt": "2025-10-07T09:41:11Z",
          "updatedAt": "2025-10-07T09:41:11Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I switched this PR to a draft PR. There are things I'll suggest differently while making a note of the comments so far.",
          "createdAt": "2025-10-11T08:33:51Z",
          "updatedAt": "2025-10-11T08:33:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7FB2pC",
          "commit": {
            "abbreviatedOid": "24bb5e1"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-06T15:47:17Z",
          "updatedAt": "2025-10-06T15:47:17Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I think the change to \"handshake or record\" is dangerous.\r\nWhat we mean is: either it's DTLS or it gets thrown away. with this change we would restrict what type of DTLS messages can be sent and that's not what we want.",
              "createdAt": "2025-10-06T15:47:17Z",
              "updatedAt": "2025-10-06T15:47:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7FCBAy",
          "commit": {
            "abbreviatedOid": "24bb5e1"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-06T15:54:30Z",
          "updatedAt": "2025-10-06T15:54:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This is wrong.\r\nIt's not just unsupported types, it's really unwanted packets.\r\n\r\nThis includes an Accounting packet that the proxy might accept in general, but may not be able to send it to the requested destination. This doesn't mean that the client should stop sending Accounting packets.",
              "createdAt": "2025-10-06T15:54:30Z",
              "updatedAt": "2025-10-06T15:54:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7FCHSb",
          "commit": {
            "abbreviatedOid": "24bb5e1"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-06T15:58:47Z",
          "updatedAt": "2025-10-06T15:58:47Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I would prefer leaving the parentheses in.\r\nThe deduction can be correct, if the server is actually down, but it may also be incorrect. The parentheses emphasize that the deduction is not always wrong.",
              "createdAt": "2025-10-06T15:58:47Z",
              "updatedAt": "2025-10-06T15:58:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7FCLv4",
          "commit": {
            "abbreviatedOid": "24bb5e1"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-06T16:01:54Z",
          "updatedAt": "2025-10-06T16:01:54Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I don't see any reason why we should forbid renegotiation.",
              "createdAt": "2025-10-06T16:01:54Z",
              "updatedAt": "2025-10-06T16:01:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7FC1Cc",
          "commit": {
            "abbreviatedOid": "24bb5e1"
          },
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-06T16:28:36Z",
          "updatedAt": "2025-10-06T16:28:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Correct, I'll drop this. For some reason I managed to skip the discussion that used unroutable realm as an example of an unwanted packet.",
              "createdAt": "2025-10-06T16:28:37Z",
              "updatedAt": "2025-10-06T16:28:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOLrzygc6sU1JS",
      "title": "Update to Detecting live servers - per connection",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/57",
      "state": "CLOSED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change makes it clear that the watchdog needs to be on a per-connection basis.",
      "createdAt": "2025-10-06T17:15:24Z",
      "updatedAt": "2025-11-05T20:03:01Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "after-wglc/detecting-live-servers",
      "headRefOid": "5e1ccd40b75a79245084bb800be5e96c464bc400",
      "closedAt": "2025-11-04T15:15:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Not necessary any more with merge of #79 ",
          "createdAt": "2025-11-04T15:15:53Z",
          "updatedAt": "2025-11-04T15:15:53Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 58,
      "id": "PR_kwDOLrzygc6svfOh",
      "title": "radiusdtls-bis-09 - terminology",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/58",
      "state": "MERGED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reference to radext-gw mailing list message:\r\nhttps://mailarchive.ietf.org/arch/msg/radext/X5lyKic2hrxGj9YZbZ66U8N0PDs/\r\n\r\nI'd like to make sure the use of terms 'packet', 'message', 'datagram', etc. is uniform. My suggestion:\r\n- RADIUS packet, RADIUS packet type  - from RFC 2865\r\n- (D)TLS record - from the DTLS RFC 9147: a DTLS record always fits into one UDP datagram\r\n- UDP datagram\r\n- TCP segment\r\n- IP packet (not currently used by the draft)\r\n\r\nThe two commits in this pull request are examples of what kind of terminology check-up I'm thinking of.",
      "createdAt": "2025-10-08T16:52:12Z",
      "updatedAt": "2025-10-20T21:08:04Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "radius-packet-datagram",
      "headRefOid": "5a887b3c108b023ba098a434e33507f2bc81c3b0",
      "closedAt": "2025-10-20T21:08:04Z",
      "mergedAt": "2025-10-20T21:08:04Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "ceadd99f367e027b5a4f01199454f0b57866f7aa"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "It's always good to be clear and consistent :+1:\r\nI'll look through the document too and see if I see other instances where this should be changed.",
          "createdAt": "2025-10-08T18:43:42Z",
          "updatedAt": "2025-10-08T18:43:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7Fp1zA",
          "commit": {
            "abbreviatedOid": "5a887b3"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-08T18:42:19Z",
          "updatedAt": "2025-10-08T18:42:19Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I would leave `DTLS messages` in this specific instance as-is, because we're really talking about the payload of the UDP datagram, not about the UDP datagram itself.\r\nIt makes it clear, that this is something that must probably be handled at crypto-API level and not on the network stack.\r\n\r\nIn most (if not all) cases, the software is not splitting the DTLS records on the network layer and passing them individually to the TLS library, it's passing the UDP datagram to the TLS library, and then the software needs to make sure to use calls to the library that ensure only one DTLS record is handled at a time.",
              "createdAt": "2025-10-08T18:42:19Z",
              "updatedAt": "2025-10-08T18:42:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Fr1s5",
          "commit": {
            "abbreviatedOid": "5a887b3"
          },
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-08T21:37:15Z",
          "updatedAt": "2025-10-08T21:37:15Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "> I would leave `DTLS messages` in this specific instance as-is, because we're really talking about the payload of the UDP datagram, not about the UDP datagram itself. It makes it clear, that this is something that must probably be handled at crypto-API level and not on the network stack.\r\n\r\nFirst, I'd like to note that the [previous paragraph](https://www.ietf.org/archive/id/draft-ietf-radext-radiusdtls-bis-09.html#section-6.1-2) already says the following about sending RADIUS packets:\r\n\r\n`We note that a single UDP datagram may, however, contain multiple DTLS records.`\r\n\r\nTherefore it would be symmetric to use 'UDP datagram' also in this paragraph that talks about receiving RADIUS packets.\r\n\r\nSecond, the DTLS 1.3 RFC also says [`DTLS messages`](https://www.rfc-editor.org/rfc/rfc9147.html#section-4.3-1) when it talks about data that is transferred with DTLS records. TLS 1.3 also says that [records carry messages](https://www.ietf.org/archive/id/draft-ietf-tls-rfc8446bis-14.html#name-record-protocol). For these reason I'd avoid saying that DTLS messages contain DTLS records.\r\n\r\nThird, I'd say that UDP datagram is the synonym for the UDP datagram payload in this document. Or then this document could say 'UDP datagram payload' when there's a need to emphasise the payload.\r\n\r\n> In most (if not all) cases, the software is not splitting the DTLS records on the network layer and passing them individually to the TLS library, it's passing the UDP datagram to the TLS library, and then the software needs to make sure to use calls to the library that ensure only one DTLS record is handled at a time.\r\n\r\nI fully agree on this. Maybe this draft could simply says that received UDP datagrams are opaque data for a RADIUS server and must be directly passed to the TLS library. It seems, this is what the next section ['6.2 Server behavior' ](https://www.ietf.org/archive/id/draft-ietf-radext-radiusdtls-bis-09.html#section-6.2-1) already says?\r\n\r\n```\r\nWhen a RADIUS/DTLS server receives packets on the configured\r\nRADIUS/DTLS port, all packets MUST be treated as being DTLS.\r\nRADIUS/UDP packets MUST NOT be accepted on this port.\r\n```\r\nSomething I just noted: there is no text in the next section ['6.3 Client behavior'](https://www.ietf.org/archive/id/draft-ietf-radext-radiusdtls-bis-09.html#name-client-behavior) that says the similar thing about received UDP datagrams: all MUST be treated as being DTLS when the port is configured for sending RADIUS/DTLS requests.",
              "createdAt": "2025-10-08T21:37:15Z",
              "updatedAt": "2025-10-08T21:37:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 59,
      "id": "PR_kwDOLrzygc6svzJK",
      "title": "radiusdtls-bis-09 - Detecting Live Servers - absence of reply",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/59",
      "state": "CLOSED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarify that the updated paragraph covers both the correct and incorrect cases. That is, when the client draws a conclusion that the server is unavailable, the conclusion may be correct or incorrect and the pargraph covers the both cases, not just the problems with the incorrect conclusion.\r\n\r\nI've so far understood the paragraph to only address the problems that arise when the conclusion is incorrect. Janfred's comment clarified this is not the case and I hope the updated text is also clearer about this.",
      "createdAt": "2025-10-08T17:26:47Z",
      "updatedAt": "2025-11-04T15:16:10Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "live-servers-parens",
      "headRefOid": "b33514050ff6cbfee8c0ab7ebd37cdff7684db9c",
      "closedAt": "2025-11-04T15:16:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Not necessary any more with merge of #79",
          "createdAt": "2025-11-04T15:16:09Z",
          "updatedAt": "2025-11-04T15:16:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOLrzygc6tT4nQ",
      "title": "radiusdtls-bis-09 - Clarify text related to unwanted packet handling and comparisons to respective RFC 6614 behaviour",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/60",
      "state": "MERGED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "These changes aim to clarify the current text in section '4.5 RADIUS Datagrams'. In short:\r\n- two last two paragraphs are now in different order\r\n- the long paragraph that discusses RFC 6614 unwanted packets is now split to multiple paragraphs with bulletted list\r\n- a new sentence is added to clearly say RFC 6614 responses to unwanted packets is replaced by this document\r\n- imperfect and passive tense is replaced with present tense that states what RFC 6614 says\r\n\r\nSee the individual commits for more detailed descriptions per commit.\r\n\r\nFunctional changes are not intentional, these should be only clarifications.",
      "createdAt": "2025-10-12T13:02:36Z",
      "updatedAt": "2025-10-20T20:51:24Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a0450adbf505a092f2a8511a5272b224255f3530",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "unwanted-packets",
      "headRefOid": "d51f60571b0f5ea65da4ef5649aefb8ff9f04905",
      "closedAt": "2025-10-20T20:51:24Z",
      "mergedAt": "2025-10-20T20:51:24Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "70baed6e125e27286a82c040b3ebe05aa9f9e548"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me.",
          "createdAt": "2025-10-13T10:08:47Z",
          "updatedAt": "2025-10-13T10:08:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 61,
      "id": "PR_kwDOLrzygc6tVQ9q",
      "title": "radiusdtls-bis-09 - Mostly DTLS specific updates",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/61",
      "state": "MERGED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The overhead and retransmissions commits aim to clarify the existing text.\r\n\r\nThe third commit, '(D)TLS data is opaque', attempts to clarify that any data received over a TLS/TCP or DTLS/UDP port should be pushed to the (D)TLS implementation for processing. (D)TLS then tells what happens next.\r\n\r\nThe text the third commit adds is intended to say what Janfred commented earlier, [What we mean is: either it's DTLS or it gets thrown away](https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/56/commits/dcc543c0066b12fa3592a2d813a5fa8d9952fbb4#r2407121622), with the help of (D)TLS implementation. The removed text, from a point of RADIUS server implementator, reads as if the RADIUS server needs to understand what's the state of TLS connection or DTLS association.\r\n\r\nIn any case, I'd say the two removed paragraph should be in the 'Packet / Connection Handling' in case they are kept.",
      "createdAt": "2025-10-12T17:12:15Z",
      "updatedAt": "2025-11-07T16:04:40Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c49fcb98d7969edc6fea2b354def796e2ccea2af",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "dtls-specific-updates",
      "headRefOid": "6f835f777e916d853c4e7a808225f35488b70f87",
      "closedAt": "2025-11-07T16:04:40Z",
      "mergedAt": "2025-11-07T16:04:40Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "3823ef03fa2a851be21d5dca59fb6b532df0a748"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1, modulu some minor comments",
          "createdAt": "2025-10-13T09:36:38Z",
          "updatedAt": "2025-10-13T09:36:38Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The changes in this PR can also be addressed when a full terminology check and update sweep is done.",
          "createdAt": "2025-11-04T21:14:18Z",
          "updatedAt": "2025-11-04T21:14:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7MtwHg",
          "commit": {
            "abbreviatedOid": "e8c06ae"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T15:06:42Z",
          "updatedAt": "2025-11-07T15:08:47Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nAll data received over a TCP or UDP port assigned for RadSec is opaque for the RADIUS client or server application and must be handled by the TLS or DTLS implementation.\r\nClosing TLS connections and discarding invalid UDP datagrams are done by the (D)TLS implmentation.\r\n```",
              "createdAt": "2025-11-07T15:06:42Z",
              "updatedAt": "2025-11-07T15:55:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOLrzygc6tWY3B",
      "title": "radiusdtls-bis-09 - Assorted fixes and other commits",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/62",
      "state": "OPEN",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Move two paragraphs to the enclosing section because they describe changes to RADIUS in general. The other commits fix typos, unify US vs UK spelling and fix some RADIUS messages types in an example.",
      "createdAt": "2025-10-12T21:26:40Z",
      "updatedAt": "2025-11-04T21:12:53Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c6c9b0f67f23913899fce54dfda92e028895da0d",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "assorted-commits",
      "headRefOid": "defa7edf5fda5c1f33584ed54008d5bb44b4c96d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1, other than I think the \"home server\" commit should be dropped.",
          "createdAt": "2025-10-13T09:35:04Z",
          "updatedAt": "2025-10-13T09:35:04Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> +1, other than I think the \"home server\" commit should be dropped.\r\n\r\nThat's fine with me, I just thought it looks odd that home server receives the said dynauth message types. It's correct to say that it can, even if the messages were unexpected, finish processing them and do whatever is needed.\r\n",
          "createdAt": "2025-10-15T12:56:36Z",
          "updatedAt": "2025-10-15T12:56:36Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "@h-vn I've added most of the changes already, could you rebase the branch, so the PR only shows the changes that are still pending?",
          "createdAt": "2025-10-23T08:08:53Z",
          "updatedAt": "2025-10-23T08:08:53Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll do it soon but not right now",
          "createdAt": "2025-10-23T21:43:27Z",
          "updatedAt": "2025-10-23T21:43:27Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The changes that now remain look correct. It may be useful to hold this since Margaret wrote on the list that she's working on the shepherding process. ",
          "createdAt": "2025-10-24T15:35:28Z",
          "updatedAt": "2025-10-24T15:35:28Z"
        },
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At the time of writing there are only two changes remaining. The one is about 'changes to Radius' which is likely better handled with this PR anymore. The other commit is about home server not receiving CoA-Request and Disconnect-Request, which are not that important.",
          "createdAt": "2025-11-04T21:12:37Z",
          "updatedAt": "2025-11-04T21:12:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7LHbGA",
          "commit": {
            "abbreviatedOid": "defa7ed"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-01T20:53:26Z",
          "updatedAt": "2025-11-01T20:53:27Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "If no changes to the packet format are needed, don't mentions this here.\r\n\"This section discusses the needed changes to the port usage and shared secrets ({{portusage}}).",
              "createdAt": "2025-11-01T20:53:26Z",
              "updatedAt": "2025-11-01T20:53:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOLrzygc6xAVtm",
      "title": "better wording for 5-tuple session tracking",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/74",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "",
      "createdAt": "2025-11-01T19:41:20Z",
      "updatedAt": "2025-11-02T18:54:38Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c6c9b0f67f23913899fce54dfda92e028895da0d",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "after-wglc/5tuple",
      "headRefOid": "5b660736963763646b46c3f1f6b4dd049dc24127",
      "closedAt": "2025-11-02T17:32:27Z",
      "mergedAt": "2025-11-02T17:32:27Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "fb795448c8b007521941dd81ffff871517bb4f82"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 75,
      "id": "PR_kwDOLrzygc6xAWO8",
      "title": "Updated wording on the exponential back-off",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/75",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "Text was suggested by Alan on the List.\r\n\r\nSee also #73",
      "createdAt": "2025-11-01T19:45:16Z",
      "updatedAt": "2025-11-02T18:54:35Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c6c9b0f67f23913899fce54dfda92e028895da0d",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "after-wglc/exponential-backoff",
      "headRefOid": "8fd0551bcfb32ae89d7a7a1bdadaf74766226c17",
      "closedAt": "2025-11-02T17:07:39Z",
      "mergedAt": "2025-11-02T17:07:39Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "25d33c8d4b75d3dc8c0e2810e983890aca7534b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7LL0Ql",
          "commit": {
            "abbreviatedOid": "8fd0551"
          },
          "author": "meadmaker",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-11-02T17:03:44Z",
          "updatedAt": "2025-11-02T17:03:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 77,
      "id": "PR_kwDOLrzygc6xESOt",
      "title": "Include a reference to RFC8900 (IP Fragmentation considered fragile)",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/77",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Shepherd Comment"
      ],
      "body": "See also #72",
      "createdAt": "2025-11-02T16:07:17Z",
      "updatedAt": "2025-11-02T18:54:37Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c6c9b0f67f23913899fce54dfda92e028895da0d",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "after-wglc/mention-rfc8900",
      "headRefOid": "34220e3a25cc84ddfc7de2c7acc0aee2435e1679",
      "closedAt": "2025-11-02T16:52:44Z",
      "mergedAt": "2025-11-02T16:52:44Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "f54d541935482420e955d8e285889dc81f1f79fe"
      },
      "comments": [
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me",
          "createdAt": "2025-11-02T16:08:15Z",
          "updatedAt": "2025-11-02T16:08:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 78,
      "id": "PR_kwDOLrzygc6xEil7",
      "title": "remove not yet defined details about protocol error",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/78",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Limit the details about protocol-error, since a propoer protocol-error draft only just started.",
      "createdAt": "2025-11-02T17:48:01Z",
      "updatedAt": "2025-11-07T16:24:05Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "3823ef03fa2a851be21d5dca59fb6b532df0a748",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-update-protocol-error",
      "headRefOid": "6cdf25e6cc63ad3eedf10e2ed5e14f93ce3e0677",
      "closedAt": "2025-11-07T16:24:05Z",
      "mergedAt": "2025-11-07T16:24:05Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "4560e45b50e18ecf66a82532795102319fc7ac69"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7LrTMg",
          "commit": {
            "abbreviatedOid": "4dd7212"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T15:32:09Z",
          "updatedAt": "2025-11-04T15:32:17Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nRADIUS/(D)TLS clients MUST accept Protocol-Error as a valid response and thus stop any retransmission of the original packet over the current connection.\r\nFurther details of handling the Protocol-Error reply on the client side are outside of the scope of this document, see {{?I-D.dekok-protocol-error}} for a more detailed description on Protocol-Error.\r\n```",
              "createdAt": "2025-11-04T15:32:09Z",
              "updatedAt": "2025-11-04T15:32:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Mdwmd",
          "commit": {
            "abbreviatedOid": "8bf1dda"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T20:17:50Z",
          "updatedAt": "2025-11-06T20:17:50Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nA server MAY therefore respond with a Protocol-Error packet as defined in {{!RFC7930, Section 4}}, to alleviate this situation and signal that it was unable to process a packet.\r\nThe Error-Cause attribute of this packet SHOULD be set to the value 406 (\"Unsupported Extension\"), if the server does not support the packet type, or the value 502 (\"Request Not Routable (Proxy)\"), if the request cannot be routed.\r\n```",
              "createdAt": "2025-11-06T20:17:50Z",
              "updatedAt": "2025-11-06T20:17:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Md5FX",
          "commit": {
            "abbreviatedOid": "8bf1dda"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T20:25:24Z",
          "updatedAt": "2025-11-06T20:25:25Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Maybe we should adjust the text in this section as well now.\r\nI'm struggling to find a good wording for what we mean, but we should say something about how (and if) legacy clients that don't send protocol-error (because it is a MAY) should go forward. Should they stop sending CoA-NAK, Disconnect-NAK, Accounting-Response and silently discard or should they keep sending the NAKs/Responses?",
              "createdAt": "2025-11-06T20:25:24Z",
              "updatedAt": "2025-11-06T20:25:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MtQTd",
          "commit": {
            "abbreviatedOid": "8bf1dda"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T14:45:20Z",
          "updatedAt": "2025-11-07T14:45:21Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I don't quite understand your comment.\r\nClients never send protocol-error, only servers do.\r\nA server that is updated should change to protocol-error. Any old behavior (if servers don't get updated) doesn't break things, they just lack the improvement.\r\nThe future spec will then define more details and probably require the sending of protocol-error.",
              "createdAt": "2025-11-07T14:45:20Z",
              "updatedAt": "2025-11-07T14:45:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MvQrX",
          "commit": {
            "abbreviatedOid": "5a242c2"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T16:12:36Z",
          "updatedAt": "2025-11-07T16:12:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nDue to the use of one single port for all packet types, clients might send packets to the server which it cannot process.\r\nWithout a response from the server, the client has to wait for the requests to time out before reusing the request id, leading to resource exhaustion of the limited id space.\r\n```",
              "createdAt": "2025-11-07T16:12:36Z",
              "updatedAt": "2025-11-07T16:12:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDOLrzygc6xEq4h",
      "title": "Reword detecting live servers section",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/79",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses also the comments in #57 #59 \r\n\r\nrelated to #64 ",
      "createdAt": "2025-11-02T18:32:55Z",
      "updatedAt": "2025-11-05T20:02:49Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "fb795448c8b007521941dd81ffff871517bb4f82",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "after-wglc/reword-detecting-live-servers",
      "headRefOid": "2aee47b8dabc7ed7c39bbcc0a6b4cf3e02848fe0",
      "closedAt": "2025-11-04T15:14:59Z",
      "mergedAt": "2025-11-04T15:14:59Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "6b6cea9360d73d1ccaf257d94e4c28b8496356c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7LMBpY",
          "commit": {
            "abbreviatedOid": "e74a7e7"
          },
          "author": "meadmaker",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-11-02T19:02:40Z",
          "updatedAt": "2025-11-02T19:04:25Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "> the missing response might be the cause of only one of many downstream servers being unresponsive\r\n\r\nThe missing response is not the cause of a downstream server being unresponsive.  I suggest:\r\n\r\n> The absence of a reply can cause a client to incorrectly deduce that the next-hop RADIUS server (i.e. proxy) is unavailable, while the missing response might be the result of only one of many downstream servers being unresponsive.\r\n\r\nChanged \"cause\" to \"result\".",
              "createdAt": "2025-11-02T19:02:40Z",
              "updatedAt": "2025-11-02T19:04:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDOLrzygc6xExfL",
      "title": "Clarify allowed retransmissions/retries",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/80",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #86",
      "createdAt": "2025-11-02T19:10:26Z",
      "updatedAt": "2025-11-05T20:00:51Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "fb795448c8b007521941dd81ffff871517bb4f82",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-clarify-retransmission",
      "headRefOid": "6f89f83694c16698b6c42d78e3c0675502220416",
      "closedAt": "2025-11-05T20:00:50Z",
      "mergedAt": "2025-11-05T20:00:50Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "48944effeb52f2de840d498aa584becfa6b8d9ce"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7MFmJ-",
          "commit": {
            "abbreviatedOid": "8a928b6"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T19:45:18Z",
          "updatedAt": "2025-11-05T19:45:18Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nRADIUS clients MUST NOT retry sending a packet by altering the protocol (i.e. switching from TLS to DTLS or vice versa) of the configured server on its own.\r\nThis requirement does not, however, forbid the practice of putting servers with the same IP address and port but different protocols into a failover or load-balancing pool.\r\n```",
              "createdAt": "2025-11-05T19:45:18Z",
              "updatedAt": "2025-11-05T19:45:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOLrzygc6xE_37",
      "title": "reword of the reword of the liveliness wording",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/81",
      "state": "MERGED",
      "author": "jimdigriz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "be more explicit that 'DOWN' is part of the watchdog state machine and the aggregated realm topology issue",
      "createdAt": "2025-11-02T20:38:00Z",
      "updatedAt": "2025-11-02T20:40:45Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "after-wglc/reword-detecting-live-servers",
      "baseRefOid": "e74a7e73e12095374f1604714a866a2750c07f13",
      "headRepository": "jimdigriz/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "reword-detecting-live-servers",
      "headRefOid": "f76a72de05b77488997192ec0dd86499d202db17",
      "closedAt": "2025-11-02T20:40:45Z",
      "mergedAt": "2025-11-02T20:40:44Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "2aee47b8dabc7ed7c39bbcc0a6b4cf3e02848fe0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 82,
      "id": "PR_kwDOLrzygc6xO09t",
      "title": "Separate the SHOULDS for PKIX",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/82",
      "state": "MERGED",
      "author": "meadmaker",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The document gives a list of rules that MUST be used when implementing PKIX authentication, but then includes two SHOULD items.  This change moves that to a separate list.",
      "createdAt": "2025-11-03T16:51:32Z",
      "updatedAt": "2025-11-04T14:50:25Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "fb795448c8b007521941dd81ffff871517bb4f82",
      "headRepository": "meadmaker/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "separate_shoulds_for_PKIX",
      "headRefOid": "a6f801cae4bdf36c07c5a95dc11667328e3db688",
      "closedAt": "2025-11-04T14:50:25Z",
      "mergedAt": "2025-11-04T14:50:25Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "91ef4d2ca324e58c723a20ca6e4185fc765f054a"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Instead of separating the MUST and SHOULD, i would rather change the \"MUST\" in the previous to something like:\r\n\r\n\"If implemented, the following rules apply:\"",
          "createdAt": "2025-11-03T17:32:24Z",
          "updatedAt": "2025-11-03T17:32:24Z"
        },
        {
          "author": "meadmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Changed as requested",
          "createdAt": "2025-11-03T17:36:19Z",
          "updatedAt": "2025-11-03T17:36:19Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 83,
      "id": "PR_kwDOLrzygc6xPV-L",
      "title": "Modified initial sections, added terminology, moved changes section t\u2026",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/83",
      "state": "MERGED",
      "author": "mrw42",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026o end, removed eduroam and Open Roaming sections.",
      "createdAt": "2025-11-03T17:33:44Z",
      "updatedAt": "2025-11-04T23:50:34Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "fb795448c8b007521941dd81ffff871517bb4f82",
      "headRepository": "mrw42/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "term-section",
      "headRefOid": "7b1fc83789f642f4b89ec0e4662bf5e207ee15a8",
      "closedAt": "2025-11-04T23:50:34Z",
      "mergedAt": "2025-11-04T23:50:34Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "b99e0437c3bbc8c6a78811fe2723306123b42831"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7LYcu2",
          "commit": {
            "abbreviatedOid": "bc45887"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-03T17:36:18Z",
          "updatedAt": "2025-11-03T17:36:19Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "With this change, we are removing the reference to TCP and UDP, see #76 ",
              "createdAt": "2025-11-03T17:36:18Z",
              "updatedAt": "2025-11-03T17:36:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LYd6n",
          "commit": {
            "abbreviatedOid": "bc45887"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-03T17:37:56Z",
          "updatedAt": "2025-11-03T17:37:56Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "```suggestion\r\nfor MD5 see {{?RFC9765}}.\r\n```\r\n\r\n(missing trailing dot)",
              "createdAt": "2025-11-03T17:37:56Z",
              "updatedAt": "2025-11-03T17:37:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LYiFK",
          "commit": {
            "abbreviatedOid": "bc45887"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-03T17:42:52Z",
          "updatedAt": "2025-11-03T17:42:52Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "To add to this: The definition is included in the new terminology section, but I think it's still worth having this in the introduction section mentioned explicitly.",
              "createdAt": "2025-11-03T17:42:52Z",
              "updatedAt": "2025-11-03T17:42:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LYoNh",
          "commit": {
            "abbreviatedOid": "bc45887"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-03T17:50:03Z",
          "updatedAt": "2025-11-03T17:50:03Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "We never talk (normatively) about TCP segments in this document, because we don't need to. TCP just provides a stream. We only need to care about payloads/packet sizes/... in UDP.",
              "createdAt": "2025-11-03T17:50:03Z",
              "updatedAt": "2025-11-03T17:50:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Ls8FB",
          "commit": {
            "abbreviatedOid": "998ea69"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T16:46:34Z",
          "updatedAt": "2025-11-04T16:46:35Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nTransport Layer Security (DTLS) {{!RFC6347}},{{!RFC9147}} over UDP {{!STD6}}.,\r\n```",
              "createdAt": "2025-11-04T16:46:34Z",
              "updatedAt": "2025-11-04T16:46:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Ls-q-",
          "commit": {
            "abbreviatedOid": "998ea69"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T16:48:27Z",
          "updatedAt": "2025-11-04T16:48:27Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "```suggestion\r\n# Changes from RFC6614 (RADIUS/TLS) and RFC7360 (RADIUS/DTLS)\r\n```",
              "createdAt": "2025-11-04T16:48:27Z",
              "updatedAt": "2025-11-04T16:48:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LtIYT",
          "commit": {
            "abbreviatedOid": "998ea69"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T16:56:03Z",
          "updatedAt": "2025-11-04T16:56:03Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "Same as with TCP segments, I don't think we mention IP packets anywhere in the document, so I would remove this.",
              "createdAt": "2025-11-04T16:56:03Z",
              "updatedAt": "2025-11-04T16:56:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LtJdG",
          "commit": {
            "abbreviatedOid": "998ea69"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T16:56:52Z",
          "updatedAt": "2025-11-04T16:56:53Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "Either it is truly TLS and DTLS, then we would need a reference to TLS as well, or its just DTLS, then remove the parenthesis.",
              "createdAt": "2025-11-04T16:56:53Z",
              "updatedAt": "2025-11-04T16:56:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LtpRJ",
          "commit": {
            "abbreviatedOid": "998ea69"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T17:18:59Z",
          "updatedAt": "2025-11-04T17:18:59Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Same comment as above: Either TLS and DTLS, then also reference TLS, or only DTLS.\r\nIn this case, I think its both.",
              "createdAt": "2025-11-04T17:18:59Z",
              "updatedAt": "2025-11-04T17:18:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LtyFi",
          "commit": {
            "abbreviatedOid": "998ea69"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T17:25:12Z",
          "updatedAt": "2025-11-04T17:25:13Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Add parenthesis around D in the explanation to make it clear we mean both TLS and DTLS.",
              "createdAt": "2025-11-04T17:25:13Z",
              "updatedAt": "2025-11-04T17:25:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LtyoZ",
          "commit": {
            "abbreviatedOid": "998ea69"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T17:25:36Z",
          "updatedAt": "2025-11-04T17:25:37Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "```suggestion\r\n(D)TLS connection:\r\n: A single (D)TLS communication channel (with DTLS this is a synonym for Association).\r\n```",
              "createdAt": "2025-11-04T17:25:36Z",
              "updatedAt": "2025-11-04T17:25:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LwWrJ",
          "commit": {
            "abbreviatedOid": "bc45887"
          },
          "author": "mrw42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T20:02:44Z",
          "updatedAt": "2025-11-04T20:02:44Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Added back in introduction.",
              "createdAt": "2025-11-04T20:02:44Z",
              "updatedAt": "2025-11-04T20:02:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LwWx-",
          "commit": {
            "abbreviatedOid": "bc45887"
          },
          "author": "mrw42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T20:02:52Z",
          "updatedAt": "2025-11-04T20:02:52Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Done",
              "createdAt": "2025-11-04T20:02:52Z",
              "updatedAt": "2025-11-04T20:02:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LwW6h",
          "commit": {
            "abbreviatedOid": "bc45887"
          },
          "author": "mrw42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T20:03:04Z",
          "updatedAt": "2025-11-04T20:03:04Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Removed.",
              "createdAt": "2025-11-04T20:03:04Z",
              "updatedAt": "2025-11-04T20:03:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Lw8J4",
          "commit": {
            "abbreviatedOid": "ef85575"
          },
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T20:55:32Z",
          "updatedAt": "2025-11-04T20:55:32Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "'Section 3.8.4.' should be part of the link. Like this: `{{RFC9293, Section 3.8.4}}`.",
              "createdAt": "2025-11-04T20:55:32Z",
              "updatedAt": "2025-11-04T20:55:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Lxfiz",
          "commit": {
            "abbreviatedOid": "ef85575"
          },
          "author": "mrw42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T21:50:42Z",
          "updatedAt": "2025-11-04T21:50:42Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Done\r\n",
              "createdAt": "2025-11-04T21:50:42Z",
              "updatedAt": "2025-11-04T21:50:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LxwmW",
          "commit": {
            "abbreviatedOid": "5855576"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T22:21:45Z",
          "updatedAt": "2025-11-04T22:21:45Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "```suggestion\r\n: As defined in TLS {{RFC5246}}.\r\n```",
              "createdAt": "2025-11-04T22:21:45Z",
              "updatedAt": "2025-11-04T22:21:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Lx8KM",
          "commit": {
            "abbreviatedOid": "5855576"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T22:45:20Z",
          "updatedAt": "2025-11-04T22:45:21Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "```suggestion\r\n```\r\n\r\nMy previous comment on this is still valid, we don't have any mention of IP packets (nor do we need to, because that's all already included in the discussion of TCP or UDP) and we never care about actual IP packets, only their content.",
              "createdAt": "2025-11-04T22:45:21Z",
              "updatedAt": "2025-11-04T22:45:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Lx8rp",
          "commit": {
            "abbreviatedOid": "5855576"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T22:46:25Z",
          "updatedAt": "2025-11-04T22:46:25Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "```suggestion\r\n: A RadSec instance that initiates a new connection.\r\n```\r\n\r\n(to be consistent with the other points)",
              "createdAt": "2025-11-04T22:46:25Z",
              "updatedAt": "2025-11-04T22:46:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LyAmi",
          "commit": {
            "abbreviatedOid": "998ea69"
          },
          "author": "mrw42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T22:54:51Z",
          "updatedAt": "2025-11-04T22:54:51Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Done\r\n",
              "createdAt": "2025-11-04T22:54:51Z",
              "updatedAt": "2025-11-04T22:54:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LyEbq",
          "commit": {
            "abbreviatedOid": "f31495c"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T23:03:25Z",
          "updatedAt": "2025-11-04T23:03:26Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nThis document defines transport profiles for running the Remote Authentication Dial In User Service (RADIUS) over Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS), allowing the secure and reliable transport of RADIUS messages.\r\nRADIUS/TLS and RADIUS/DTLS are collectively referred to as RadSec.\r\n```\r\n\r\nRe-format to one-line-per-sentence",
              "createdAt": "2025-11-04T23:03:26Z",
              "updatedAt": "2025-11-04T23:03:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LyE0I",
          "commit": {
            "abbreviatedOid": "f31495c"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T23:04:15Z",
          "updatedAt": "2025-11-04T23:04:15Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nThis document defines transport profiles for running Remote Authentication Dial In User Service (RADIUS) over Transport Layer Security (TLS) {{!RFC8446}}, {{!RFC5246}} over TCP {{!STD7}} and Datagram Transport Layer Security (DTLS) {{!RFC6347}}, {{!RFC9147}} over UDP {{!STD6}}., allowing secure and reliable transport of RADIUS messages.\r\nRADIUS/TLS and RADIUS/DTLS are collectively referred to as RadSec.\r\n```\r\n\r\n\r\nRe-format to one-line-per-sentence",
              "createdAt": "2025-11-04T23:04:15Z",
              "updatedAt": "2025-11-04T23:04:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LyFYl",
          "commit": {
            "abbreviatedOid": "f31495c"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T23:05:24Z",
          "updatedAt": "2025-11-04T23:05:24Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nThe RADIUS protocol is a widely deployed authentication, authorization and accounting solution defined in {{!RFC2865}}, {{!RFC2866}}, {{!RFC5176}} and others.\r\nDeployment experience has shown several shortcomings, such as its dependency on the unreliable transport protocol, UDP, and its lack of confidentiality for large parts of RADIUS messages.\r\nAdditionally, the confidentiality and integrity mechanisms in RADIUS rely on the MD5 algorithm {{?RFC1321}}, which has been proven to be insecure.\r\nAlthough RADIUS/(D)TLS does not remove the MD5-based mechanisms, it adds confidentiality and integrity protection through the TLS layer.\r\nFor an updated version of RADIUS/(D)TLS without need for MD5 see {{?RFC9765}}.\r\n```\r\n\r\nRe-format to one-line-per-sentence",
              "createdAt": "2025-11-04T23:05:24Z",
              "updatedAt": "2025-11-04T23:05:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LyF2X",
          "commit": {
            "abbreviatedOid": "f31495c"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T23:06:21Z",
          "updatedAt": "2025-11-04T23:06:21Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "```suggestion\r\nWhenever \"(D)TLS\" or \"RADIUS/(D)TLS\" is mentioned, the specification applies for both RADIUS/TLS and RADIUS/DTLS.\r\nWhere \"TLS\" or \"RADIUS/TLS\" is mentioned, the specification only applies to RADIUS/TLS, where \"DTLS\" or \"RADIUS/DTLS\" is mentioned it only applies to RADIUS/DTLS.\r\n```\r\n\r\n\r\nRe-format to one-line-per-sentence",
              "createdAt": "2025-11-04T23:06:21Z",
              "updatedAt": "2025-11-04T23:06:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LyGIU",
          "commit": {
            "abbreviatedOid": "f31495c"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T23:06:55Z",
          "updatedAt": "2025-11-04T23:06:55Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "```suggestion\r\nServer implementations MUST support both RADIUS/TLS and RADIUS/DTLS.\r\nClient implementations SHOULD implement both, but MUST implement at least one of RADIUS/TLS or RADIUS/DTLS.\r\n```\r\n\r\nRe-format to one-line-per-sentence",
              "createdAt": "2025-11-04T23:06:55Z",
              "updatedAt": "2025-11-04T23:07:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LyMJR",
          "commit": {
            "abbreviatedOid": "f31495c"
          },
          "author": "mrw42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T23:20:41Z",
          "updatedAt": "2025-11-04T23:20:41Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "When we have one line per sentence it runs off the right and or wraps awkwardly on a small screen.  I had to reformat it to actually read the paragraphs and find the terminology to change.  \r\n\r\nIf you want to do this for every paragraph, why don't you do it in a separate PR after you accept my actual, substantive changes?\r\n\r\nWe need to actually move forward on the text.\r\n",
              "createdAt": "2025-11-04T23:20:41Z",
              "updatedAt": "2025-11-04T23:20:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LyMhU",
          "commit": {
            "abbreviatedOid": "f31495c"
          },
          "author": "mrw42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T23:21:37Z",
          "updatedAt": "2025-11-04T23:21:37Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "You will find the longer PR does  this, too.  Please change later if you must.",
              "createdAt": "2025-11-04T23:21:37Z",
              "updatedAt": "2025-11-04T23:21:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 84,
      "id": "PR_kwDOLrzygc6xRbcK",
      "title": "Check PKIX addr against range",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/84",
      "state": "MERGED",
      "author": "meadmaker",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I found the wording around using PKIX authentication for clients identified by IP address belonging to an IP range confusing.  My first impression of the text was that it expected the certificate to include the IP range, and I was confused about how that would be represented.  It took me a few times reading it before I understood what it was trying to say.\r\n\r\n- Turn this line into its own bullet point, which seems like it was intended anyway\r\n- Make it clear that this is an optional server configuration\r\n- Make it clear that the server has separate validations for the client IP address being part of its configured range and for the client IP address being identified in the certificate",
      "createdAt": "2025-11-03T20:43:58Z",
      "updatedAt": "2025-11-04T17:00:15Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "fb795448c8b007521941dd81ffff871517bb4f82",
      "headRepository": "meadmaker/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "check_pkix_addr_against_range",
      "headRefOid": "9a551479377cc0c9e78336c32257b042ddedd6ce",
      "closedAt": "2025-11-04T17:00:15Z",
      "mergedAt": "2025-11-04T17:00:15Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "d02d81833f269e3d8f9ab3c250fdfc0d3c8bea0c"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe \"range or set\" ? In theory, it is also possible to allow a list of IP addresses instead of a range (or a list of ranges)",
          "createdAt": "2025-11-04T14:55:13Z",
          "updatedAt": "2025-11-04T14:55:13Z"
        },
        {
          "author": "meadmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done!",
          "createdAt": "2025-11-04T15:38:48Z",
          "updatedAt": "2025-11-04T15:38:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7Lr4U3",
          "commit": {
            "abbreviatedOid": "78062a8"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T15:59:21Z",
          "updatedAt": "2025-11-04T15:59:22Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n  * Some servers MAY be configured to accept a client coming from a range or set of IP addresses.  In this case, the server MUST verify that the client IP address of the current connection is a member of the range or set of IP addresses, and the server MUST match the client IP address of the current connection against the presented identifiers of any subjectAltName entry of type iPAddress {{!RFC5280}}.\r\n```",
              "createdAt": "2025-11-04T15:59:22Z",
              "updatedAt": "2025-11-04T15:59:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDOLrzygc6xct-3",
      "title": "Clarify for reconnections",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/86",
      "state": "MERGED",
      "author": "meadmaker",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Reword the exception, mostly because \"iff\" is not an English word ;-)\r\n- Supply an absolute lower limit for configuring the lower limit of reconnection time, so that administrators don't set the lower limit to 0 seconds.",
      "createdAt": "2025-11-04T15:37:02Z",
      "updatedAt": "2025-11-04T16:17:02Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "6b6cea9360d73d1ccaf257d94e4c28b8496356c4",
      "headRepository": "meadmaker/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "reconnection",
      "headRefOid": "257639f4abe921a5e5a78d659c1766696fa3be5a",
      "closedAt": "2025-11-04T16:17:02Z",
      "mergedAt": "2025-11-04T16:17:02Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "9df32789bdd5ffd9cb84d8315dc57d368b1e4c10"
      },
      "comments": [
        {
          "author": "meadmaker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As for the absolute lower limit of reconnection time, I think it's important to have a well-considered lower limit, but I don't have a good feel for exactly what that number is.  I put half a second in the pull request, but if you feel that a different number would be better please use that instead.",
          "createdAt": "2025-11-04T15:43:55Z",
          "updatedAt": "2025-11-04T15:43:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7Lr3jd",
          "commit": {
            "abbreviatedOid": "12d42a0"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T15:58:44Z",
          "updatedAt": "2025-11-04T15:58:45Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nExcept in cases where an attempted resumption of a TLS session was closed by the RADIUS/(D)TLS server, RADIUS/(D)TLS clients MUST NOT immediately reconnect to a server after a failed connection attempt.  Typical reconnections MUST have a lower bound for the time in between retries.  The lower bound SHOULD be configurable, but MUST NOT be less than 0.5 seconds.  In cases where the server closes the connection on an attempted TLS session resumption, the client MUST NOT use TLS session resumption for the following connection attempt.\r\n```",
              "createdAt": "2025-11-04T15:58:44Z",
              "updatedAt": "2025-11-04T15:58:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7LsKGJ",
          "commit": {
            "abbreviatedOid": "2c8a8ef"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T16:12:31Z",
          "updatedAt": "2025-11-04T16:12:32Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nExcept in cases where an attempted resumption of a TLS session was closed by the RADIUS/(D)TLS server, RADIUS/(D)TLS clients MUST NOT immediately reconnect to a server after a failed connection attempt.\r\nA connection attempt is treated as failed if it fails at any point until a the (D)TLS session is established successfully.\r\nTypical reconnections MUST have a lower bound for the time in between retries.\r\nThe lower bound SHOULD be configurable, but MUST NOT be less than 0.5 seconds.\r\nIn cases where the server closes the connection on an attempted TLS session resumption, the client MUST NOT use TLS session resumption for the following connection attempt.\r\n```",
              "createdAt": "2025-11-04T16:12:32Z",
              "updatedAt": "2025-11-04T16:12:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDOLrzygc6xdDtO",
      "title": "Check limits before opening the session",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/88",
      "state": "MERGED",
      "author": "meadmaker",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Using the word \"started\" implies that the session has already succeeded in its creation.",
      "createdAt": "2025-11-04T16:01:53Z",
      "updatedAt": "2025-11-04T16:15:45Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "6b6cea9360d73d1ccaf257d94e4c28b8496356c4",
      "headRepository": "meadmaker/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "check-limits-before-session-creation",
      "headRefOid": "1d9946bafc12893e1aebb5cf7052741f2a715e2c",
      "closedAt": "2025-11-04T16:15:45Z",
      "mergedAt": "2025-11-04T16:15:45Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "f499db5962e12b1a383021efea2910cbc74b5022"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 89,
      "id": "PR_kwDOLrzygc6xgjqY",
      "title": "WIP: Apply terminology throughout, remove most discussion of Protocol-Erro\u2026",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/89",
      "state": "OPEN",
      "author": "mrw42",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026r, editorial changes, move \"Changes to RADIUS\" session after protocol specification, etc.",
      "createdAt": "2025-11-04T22:00:25Z",
      "updatedAt": "2025-11-05T19:36:25Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "573edd80f9008dd4f73aac3adb2952e1d0302ab3",
      "headRepository": "mrw42/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fix-conflicts",
      "headRefOid": "a173515903a697af89ca9013532fb1c22bfff7c9",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Unfortunately, this pull request changes the line wrapping completely, which makes it impossible to quickly spot changes.\r\n\r\nIn the current version I'm trying to have one sentence per line.",
          "createdAt": "2025-11-04T22:58:32Z",
          "updatedAt": "2025-11-04T22:58:32Z"
        },
        {
          "author": "mrw42",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was trying to help by doing a whole bunch of work in the document and submitting it as a PR, but perhaps that was a waste of time\u2026 I can\u2019t reasonably edit, or even properly read, a document that is written one sentence per line.  So, you can merge this PR, or you can redo the work it contains, whichever is easier for you. Let me know when you have a version that you believe fully updates terminology throughout the document (to match the terminology section), addresses all of the open WG issues, and addresses my other shepherd review comments sent in email.  I will then do another review.",
          "createdAt": "2025-11-05T14:28:48Z",
          "updatedAt": "2025-11-05T14:32:49Z"
        },
        {
          "author": "alandekok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mrw42 I think the concern is the mixing of whitespace changes and editorial changes.  That makes it difficult to review the changes, as the git \"diff\" view doesn't display the changes correctly.\r\n\r\nI've talked with Janfred, and we're going to look at a solution.  There's no question that the document has to make progress.  I hope we can continue to make progress this week.",
          "createdAt": "2025-11-05T14:49:17Z",
          "updatedAt": "2025-11-05T14:49:17Z"
        },
        {
          "author": "mrw42",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I understand the concern...   It really wasn't possible for me to make changes in effectively every paragraph in the document and retain the white space, given that in some cases I was needing to move back and forth three page widths to see the full sentences.  I understand why the resulting changes will be hard for Janfred to deal with if he wants to review each separate change.  Many of the changes were made using find/replace, checking each instance to make sure the change would apply correctly.  For instance almost every instance of the word \"node\" in document was changed to \"endpoint\" and almost every instance of RADIUS/(D)TLS was changes to RadSec...  ",
          "createdAt": "2025-11-05T18:27:12Z",
          "updatedAt": "2025-11-05T18:27:12Z"
        },
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "Since this contains too many changes, I'm marking this as Work-in-progress.\r\n\r\nMost of the terminology has been updated in 3a91230\r\n\r\nThe other changes are too big to grasp, so I'll keep this as a reference without intention of merging this specific PR, but rather going through the changes individually.",
          "createdAt": "2025-11-05T19:36:01Z",
          "updatedAt": "2025-11-05T19:36:01Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 90,
      "id": "PR_kwDOLrzygc6xssoF",
      "title": "Reduce RADIUS to its abbreviation again in the document title",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/90",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "While it might be good to spell everything out, the abbreviation RADIUS is really not applicable to what the protocol does any more, and I think it should be treated more like a fixed term.\r\n\r\nWith the other abbreviations (TLS/DTLS) spelled out, the title gets very long otherwise.",
      "createdAt": "2025-11-05T16:46:40Z",
      "updatedAt": "2025-11-05T20:02:41Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "3a912302cd8f5ce4cb911598a187c6302085c649",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature/make-title-smaller-again",
      "headRefOid": "c4973fcdb2577c323af7cdd1f3eafa90c05d8054",
      "closedAt": "2025-11-05T19:37:12Z",
      "mergedAt": "2025-11-05T19:37:12Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "6c18dab345edb0e5424bed4ad64d16c73bec6d00"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 91,
      "id": "PR_kwDOLrzygc6xsulz",
      "title": "Add the change from \"RADIUS/(D)TLS\" to \"RadSec\" to list of changes",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/91",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think this is notable enough.\r\n\r\nMaybe also include the previous terms (RADIUS/TLS and RADIUS/DTLS) explicitly here?",
      "createdAt": "2025-11-05T16:48:40Z",
      "updatedAt": "2025-11-21T12:40:20Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "3a912302cd8f5ce4cb911598a187c6302085c649",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature/add-radsec-to-changes",
      "headRefOid": "c2654eff3cee7d62b70f126619230cedaaea39d0",
      "closedAt": "2025-11-05T20:04:34Z",
      "mergedAt": "2025-11-05T20:04:34Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "c7e94afe45aa9cfa28b84db4d020a3e4b54eb154"
      },
      "comments": [
        {
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the proposal is fine as-is. The prevois terms are already mentioned in the section just above as well as in the title.",
          "createdAt": "2025-11-05T17:00:31Z",
          "updatedAt": "2025-11-05T17:00:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7MEHG5",
          "commit": {
            "abbreviatedOid": "458a714"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T18:04:19Z",
          "updatedAt": "2025-11-05T18:04:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n* The protocols RADIUS/TLS and RADIUS/DTLS are now collectively referred to as RadSec.\r\n```\r\n\r\nChange to clarify that RadSec consists technically of two protocols.",
              "createdAt": "2025-11-05T18:04:20Z",
              "updatedAt": "2025-11-05T18:04:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDOLrzygc6xtQVP",
      "title": "Minor fixes to punctuation, some incorrect use of 'trust base' and other minor fixes.",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/92",
      "state": "MERGED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some genetive forms were missing, which are now corrected. 'trust base' was only used once and it seems 'trust store' is the correct alternative which is also used elsewhere. There seems also be one incorrect use of 'trust anchor' where 'trust store' would be correct.\r\n\r\nMinor updates to wording of what is exposed for client identification.",
      "createdAt": "2025-11-05T17:28:37Z",
      "updatedAt": "2025-11-05T18:00:51Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a492e127257329af7000f4bae242504a11d692d2",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "trust-store",
      "headRefOid": "5e39fef845f06a727691679693b7f6c8acad42f4",
      "closedAt": "2025-11-05T18:00:51Z",
      "mergedAt": "2025-11-05T18:00:51Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "5bcf4a42615dbe0ecbac3cdfe12115ad1f02cac4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7MDud4",
          "commit": {
            "abbreviatedOid": "a91a24f"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T17:40:42Z",
          "updatedAt": "2025-11-05T17:40:43Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n* When the configured trust base changes (e.g., removal of a CA from set of trust anchors; issuance of a new CRL for a CA in the set of trust anchors), implementations SHOULD reassess the continued validity of the certificate path of all connected peers.  This can either be done by caching the peer's certificate for the duration of the connection and re-evaluating the cached certificate or by renegotiating the (D)TLS connection, either directly or by opening a new (D)TLS connection and closing the old one.\r\n```",
              "createdAt": "2025-11-05T17:40:42Z",
              "updatedAt": "2025-11-05T17:40:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOLrzygc6xtbnY",
      "title": "Drop RFC 6614 discussion of RADIUS/UDP client identification",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/93",
      "state": "MERGED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarify client identity determination in RadSec by removing the irrelevant discussion of how RADIUS/UDP does it. This text is a left over from RFC 6614.",
      "createdAt": "2025-11-05T17:43:51Z",
      "updatedAt": "2025-11-10T18:44:41Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "a492e127257329af7000f4bae242504a11d692d2",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "udp-connecting-client-identity",
      "headRefOid": "6a137df8d5d2a4e8e19027354fef65adfeabd922",
      "closedAt": "2025-11-10T18:44:41Z",
      "mergedAt": "2025-11-10T18:44:41Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "8cdd5342b9fccce7e7447d7f9b7e76cd33342b5c"
      },
      "comments": [
        {
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "body": "I would still include this, maybe reword it a little bit.\r\nIt's an important change to how RADIUS/UDP handles things, and we should note that.",
          "createdAt": "2025-11-09T23:04:02Z",
          "updatedAt": "2025-11-09T23:04:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7NEJ53",
          "commit": {
            "abbreviatedOid": "4042574"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-09T23:10:26Z",
          "updatedAt": "2025-11-09T23:10:26Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nIn RADIUS/UDP, clients are uniquely identified by their IP addresses, as the shared secret is associated with the origin IP address.\r\nWith RadSec multiple distinct RadSec clients can connect from the same IP address.\r\nThis requires changing the method of identifying individual clients from RADIUS/UDP.\r\n\r\nDepending on the trust model used, the RadSec client identity is determined as follows.\r\n```\r\n\r\nMaybe this is a better way of saying what we mean without the (probably unnecessary) comment about the insecurity of using a common shared secret per IP address.",
              "createdAt": "2025-11-09T23:10:26Z",
              "updatedAt": "2025-11-09T23:10:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7NUL1U",
          "commit": {
            "abbreviatedOid": "4042574"
          },
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-10T18:35:34Z",
          "updatedAt": "2025-11-10T18:35:34Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Your suggestion is better than the original text because it ties the old practice with the new options with an explanation.\r\n\r\nHowever, leaving in the text about shared secret without saying that it's now fixed, sort of hints that identity is needed to determine the shared secret. Let me add one more thing.",
              "createdAt": "2025-11-10T18:35:34Z",
              "updatedAt": "2025-11-10T18:35:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7NUUKt",
          "commit": {
            "abbreviatedOid": "6a137df"
          },
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This attempts to clarify that selecting the correct shared secret is no longer a concern because its value is now fixed.",
          "createdAt": "2025-11-10T18:44:09Z",
          "updatedAt": "2025-11-10T18:44:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDOLrzygc6xt30s",
      "title": "unify use of the term 'trust base'",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/94",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-11-05T18:25:14Z",
      "updatedAt": "2025-11-05T19:23:35Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "5bcf4a42615dbe0ecbac3cdfe12115ad1f02cac4",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-unify-trust-base",
      "headRefOid": "9b7ed0d4eec2e1ea40f2f2ca144e1f28aab0bd02",
      "closedAt": "2025-11-05T19:23:35Z",
      "mergedAt": "2025-11-05T19:23:35Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "78e3b9de38379a04bb4b278e7a3fb650c304fe08"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7MEjF3",
          "commit": {
            "abbreviatedOid": "4d1873d"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T18:36:59Z",
          "updatedAt": "2025-11-05T18:36:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n* Implementations MUST allow the configuration of a trust base (i.e. a set of trusted Certificate Authorities (CAs){{!RFC5280}}) for new TLS sessions.  This list SHOULD be application-specific and not use a global system trust store.\r\n```\r\n\r\nIn this case, I'd leave the \"trust store\" in there, because here we really do mean \"all the CAs that come with the system and are trusted for everything\".\r\n(even though it's introducing a new term, but I think \"trust store\" should be a well-known term)",
              "createdAt": "2025-11-05T18:36:59Z",
              "updatedAt": "2025-11-05T18:36:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 95,
      "id": "PR_kwDOLrzygc6xvJKc",
      "title": "Draft: Apply Margaret's changes as best as possible with formatting",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/95",
      "state": "OPEN",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See also #89 ",
      "createdAt": "2025-11-05T20:24:34Z",
      "updatedAt": "2025-11-07T16:42:09Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "ab2ac67b670116e553e6d42e795acfc355c91a66",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "margarets-changes",
      "headRefOid": "cbbc0479d19f15406bd1728d694404b58697baac",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7MGWQE",
          "commit": {
            "abbreviatedOid": "2f553cd"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Formatting changes",
          "createdAt": "2025-11-05T20:28:44Z",
          "updatedAt": "2025-11-06T16:09:20Z",
          "comments": [
            {
              "originalPosition": 737,
              "body": "```suggestion\r\n- Comparing client or server random used in the TLS handshake. While this is a very effective method, it requires access to values which are normally private to the TLS implementation.\r\n- Sending a custom random number in an extension in the TLS client hello. Again, this is very effective, but requires extension of the TLS implementation.\r\n- Comparing the incoming server certificate to all server certificates configured on the proxy. While in some scenarios this can be a valid detection method, using the same server certificate on multiple servers would keep these servers from connecting with each other, even when this connection is legitimate.\r\n```",
              "createdAt": "2025-11-05T20:28:44Z",
              "updatedAt": "2025-11-05T20:34:39Z"
            },
            {
              "originalPosition": 747,
              "body": "```suggestion\r\nFollowing the recommendations in {{RFC9325, Section 4.1}}, this specification forbids the usage of NULL encryption cipher suites for RadSec.\r\n```",
              "createdAt": "2025-11-05T20:29:01Z",
              "updatedAt": "2025-11-05T20:34:39Z"
            },
            {
              "originalPosition": 751,
              "body": "```suggestion\r\nFor cases where administrators need access to the decrypted RadSec traffic, we suggest using different approaches, like exporting the key material from TLS libraries according to {{?I-D.ietf-tls-keylogfile}}.\r\n```",
              "createdAt": "2025-11-05T20:29:17Z",
              "updatedAt": "2025-11-05T20:34:39Z"
            },
            {
              "originalPosition": 764,
              "body": "```suggestion\r\nPerforming a (D)TLS handshake is more complex than the cryptographic check of a RADIUS packet.\r\nAn attacker could try to trigger a high number of (D)TLS handshakes at the same time, resulting in a high server load and potentially a Denial-of-Service.\r\n```",
              "createdAt": "2025-11-05T20:29:34Z",
              "updatedAt": "2025-11-05T20:34:39Z"
            },
            {
              "originalPosition": 769,
              "body": "```suggestion\r\nBoth TLS and DTLS need to store session information for each open (D)TLS session.\r\n```",
              "createdAt": "2025-11-05T20:29:44Z",
              "updatedAt": "2025-11-05T20:34:39Z"
            },
            {
              "originalPosition": 785,
              "body": "```suggestion\r\nTo prevent resource exhaustion by partially opening a large number of (D)TLS sessions, RadSec servers SHOULD have a timeout on partially open (D)TLS sessions.\r\nImplementations SHOULD expose this timeout as configurable option to the administrator.\r\nThe recommended default for this timeout is a few seconds. If a (D)TLS session is not established within this timeframe, it is likely that this is a bogus connection.\r\nIn contrast, an established session might not send packets for longer periods of time, but since the endpoints are mutually authenticated this does not pose a problem other than the problems mentioned before.\r\n```",
              "createdAt": "2025-11-05T20:30:32Z",
              "updatedAt": "2025-11-05T20:34:39Z"
            },
            {
              "originalPosition": 798,
              "body": "```suggestion\r\nSee {{RFC8446, Section 5.5}} and {{?I-D.irtf-cfrg-aead-limits}} for more information.\r\n```",
              "createdAt": "2025-11-05T20:30:47Z",
              "updatedAt": "2025-11-05T20:34:39Z"
            },
            {
              "originalPosition": 971,
              "body": "```suggestion\r\n{{RFC6614}} mandates the implementation of the trust profile \"certificate with PKIX trust model\" for both clients and servers.\r\nThe experience of the deployment of RADIUS/TLS as specified in {{RFC6614}} has shown that most actors still rely on RADIUS/UDP.\r\n```",
              "createdAt": "2025-11-05T20:31:13Z",
              "updatedAt": "2025-11-05T20:34:39Z"
            },
            {
              "originalPosition": 1036,
              "body": "```suggestion\r\nThe following list contains the most important changes from the previous specifications in {{RFC6613}} (RADIUS/TCP), {{RFC6614}} (RADIUS/TLS) and {{RFC7360}} (RADIUS/DTLS).\r\n\r\n* {{?RFC6614}} referenced {{?RFC6613}} for TCP-related specification, RFC6613 on the other hand had some specification for RADIUS/TLS. These specifications have been merged into this document, and therefore removes {{RFC6613}} as normative reference.\r\n* RFC6614 marked TLSv1.1 or later as mandatory, this specification requires TLSv1.2 as minimum and recommends usage of TLSv1.3.\r\n* RFC6614 allowed use of TLS compression, this document forbids it.\r\n* RFC6614 only requires support for the trust model \"certificates with PKIX\" ({{?RFC6614, Section 2.3}}). This document changes this. For   servers, TLS-X.509-PKIX ({{tlsx509pkix}}, equivalent to   \"certificates with PKIX\" in RFC6614) and TLS-PSK ({{tlspsk}}) is now mandated and clients must implement at least one of the two.\r\n* The mandatory-to-implement cipher suites are not referenced directly, this is replaced by a pointer to the TLS BCP.\r\n* The specification regarding steps for certificate verification has been updated.\r\n* {{RFC6613}} mandated the use of Status-Server as watchdog algorithm, {{?RFC7360}} only recommended it. This specification mandates the use of Status-Server for both RADIUS/TLS and RADIUS/DTLS.\r\n* {{RFC6613}} only included limited text around retransmissions, this document now gives more guidance on how to handle retransmissions, especially across different transports.\r\n* The rules for verifying the endpoint certificate have been updated to follow guidance provided in {{!RFC9525}}. Using the Common Name RDN for validation of server certificates is now forbidden.\r\n* The response to unwanted packets has changed. Endpoints should now reply with a Protocol-Error packet, which is connection-specific and should not be proxied.\r\n\r\nThe rationales behind some of these changes are outlined in {{design_decisions}}.\r\n```",
              "createdAt": "2025-11-05T20:33:59Z",
              "updatedAt": "2025-11-05T20:34:39Z"
            },
            {
              "originalPosition": 1043,
              "body": "```suggestion\r\nThanks to the original authors of RFC 6613, RFC 6614 and RFC 7360: Alan DeKok, Stefan Winter, Mike McCauley, Stig Venaas and Klaas Vierenga.\r\n```",
              "createdAt": "2025-11-05T20:34:11Z",
              "updatedAt": "2025-11-05T20:34:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MGkcP",
          "commit": {
            "abbreviatedOid": "bb21c0a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T20:39:32Z",
          "updatedAt": "2025-11-05T20:45:10Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "I don't agree with removing the description here. I think it is important to note that RADIUS needs mutual trust.",
              "createdAt": "2025-11-05T20:39:32Z",
              "updatedAt": "2025-11-05T20:45:10Z"
            },
            {
              "originalPosition": 225,
              "body": "The \"MUST\" here confuses the \"SHOULD\"s later. See #82 ",
              "createdAt": "2025-11-05T20:40:19Z",
              "updatedAt": "2025-11-05T20:45:10Z"
            },
            {
              "originalPosition": 279,
              "body": "This is a change in BCP14 language without any explanation.\r\n\r\nThis should at least be discussed. Leaving SHA-1 in was to keep backwards compatibility to the previous spec. (Maybe there were additional reasons, I'm not exactly sure)",
              "createdAt": "2025-11-05T20:41:58Z",
              "updatedAt": "2025-11-05T20:45:10Z"
            },
            {
              "originalPosition": 177,
              "body": "This is normative language and shouldn't be used in the terminology section",
              "createdAt": "2025-11-05T20:45:01Z",
              "updatedAt": "2025-11-05T20:45:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MY_W6",
          "commit": {
            "abbreviatedOid": "bb21c0a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T16:10:00Z",
          "updatedAt": "2025-11-06T16:10:01Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nThis document defines transport profiles for running the Remote Authentication Dial In User Service (RADIUS) over Transport Layer Security (TLS) {{!RFC8446}}, {{!RFC5246}} over TCP {{!STD7}} and Datagram Transport Layer Security (DTLS) {{!RFC6347}}, {{!RFC9147}} over UDP {{!STD6}}, allowing secure and reliable transport of RADIUS messages.\r\n```",
              "createdAt": "2025-11-06T16:10:00Z",
              "updatedAt": "2025-11-06T16:42:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MZEHr",
          "commit": {
            "abbreviatedOid": "bb21c0a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T16:12:47Z",
          "updatedAt": "2025-11-06T16:12:48Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n{::boilerplate bcp14-tagged}\r\n```\r\n\r\nThis is the BCP14 boilerplate, it's important.",
              "createdAt": "2025-11-06T16:12:47Z",
              "updatedAt": "2025-11-06T16:12:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MZHvb",
          "commit": {
            "abbreviatedOid": "bb21c0a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Another whitespace/typo update",
          "createdAt": "2025-11-06T16:15:03Z",
          "updatedAt": "2025-11-06T16:42:24Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "```suggestion\r\nImplementations MUST follow the recommendations given in {{!BCP195}}, especially in regards to recommended cipher suites and TLS session resumption.\r\n```",
              "createdAt": "2025-11-06T16:15:03Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 254,
              "body": "```suggestion\r\n  * If the expected RadSec server was configured as a hostname, or the hostname was yielded by a dynamic discovery procedure, that name is matched against the presented identifiers of any subjectAltName entry of type dNSName {{!RFC5280}}.  Since a dynamic discovery might by itself not be secured, implementations MAY require the use of DNSSEC {{!RFC4033}} to ensure the authenticity of the DNS result before considering this identity as valid.\r\n```",
              "createdAt": "2025-11-06T16:15:29Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 260,
              "body": "```suggestion\r\n  * Clients which also act as servers (i.e. proxies) may be susceptible to security issues when a ClientHello is mirrored back to themselves.  More details on this issue are discussed in {{security_considerations}}.\r\n```",
              "createdAt": "2025-11-06T16:15:44Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 285,
              "body": "```suggestion\r\nRadSec implementations SHOULD support using Raw Public Keys {{!RFC7250}} for mutual authentication.\r\n```",
              "createdAt": "2025-11-06T16:16:04Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 311,
              "body": "```suggestion\r\nOne example of this can be to restrict clients configured by DNS name to only the IP address(es) that this DNS name resolves to.\r\n```",
              "createdAt": "2025-11-06T16:16:16Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 338,
              "body": "```suggestion\r\nSession resumption lowers the time and effort required to start a (D)TLS session and increases network responsiveness.\r\n```",
              "createdAt": "2025-11-06T16:16:30Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 418,
              "body": "```suggestion\r\nDue to the lossy nature of UDP, RADIUS/UDP and RADIUS/DTLS transports are required to perform retransmissions as per {{!RFC5080, Section 2.2.1}}.\r\n```",
              "createdAt": "2025-11-06T16:16:52Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 437,
              "body": "```suggestion\r\nIn order to avoid congestive collapse, it is RECOMMENDED that RadSec clients which originate Accounting-Request packets (i.e. not proxies) do not include Acct-Delay-Time ({{?RFC2866, Section 5.2}}) in those packets.\r\n```",
              "createdAt": "2025-11-06T16:17:10Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 488,
              "body": "```suggestion\r\nWhile RADIUS/UDP could be implemented mostly stateless (except for the requests in flight), both TCP/TLS as well as DTLS require state tracking of the underlying TLS connection and are thus subject to potential resource exhaustion.\r\nThis is aggravated by the fact that RADIUS client/servers are often statically configured and thus form long-running endpoint relationships with long-running connections.\r\n```",
              "createdAt": "2025-11-06T16:17:33Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 492,
              "body": "```suggestion\r\nImplementations SHOULD have configurable limits on the number of open connections.\r\nWhen this maximum is reached and a new session is needed, the server MUST either drop an old session in order to open the new one or not create a new session.\r\n```",
              "createdAt": "2025-11-06T16:17:47Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 497,
              "body": "```suggestion\r\nTherefore, both RadSec clients and servers MAY close connections after they have been idle for some time (no traffic except application layer watchdog).\r\nThis idle timeout SHOULD be configurable within reasonable limits and it SHOULD be possible to disable idle timeouts completely.\r\n```",
              "createdAt": "2025-11-06T16:18:00Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 503,
              "body": "```suggestion\r\nOn the server side, this mostly helps avoid resource exhaustion.\r\nFor clients, proactively closing sessions can also help mitigate situations where watchdog mechanisms are unavailable or fail to detect non-functional connections.\r\nSome scenarios or RADIUS protocol extensions could also require that a connection be kept open at all times, so clients MAY immediately re-open the connection.\r\nThese scenarios could be related to monitoring the infrastructure or to allow the server to proactively send packets to the clients without a preceding request.\r\n```",
              "createdAt": "2025-11-06T16:18:24Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 509,
              "body": "```suggestion\r\nThe value of the idle timeout to use depends on the exact deployment and is a trade-of between resource usage on clients/servers and the overhead of opening new connections.\r\nVery short timeouts that are at or below the timeouts used for application layer watchdogs, typically in the range of 30-60s can be considered unreasonable.\r\nIn contrast, the upper limit is much more difficult to define but may be in the range of 10 to 15min, depending on the available resources, or never (disabling idle timeout) in scenarios where a permanently open connection is required.\r\n```",
              "createdAt": "2025-11-06T16:19:36Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 523,
              "body": "```suggestion\r\nA discarded RADIUS request packet be associated with a cached RADIUS response packet ({{RFC5080, Section 2.2.2}}), in which case the cached response paccket also MUST be discarded.\r\n```",
              "createdAt": "2025-11-06T16:19:56Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 536,
              "body": "```suggestion\r\nImplementations of this specification SHOULD treat the \"silently discard\" texts in the RADIUS specification referenced above as \"silently discard and close the connection\".\r\n```",
              "createdAt": "2025-11-06T16:20:08Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 547,
              "body": "```suggestion\r\nFor request packets that would have been silently discarded in the previous specifications, servers SHOULD reply with a Protocol-Error {{!RFC7930, Section 4}} message to avoid request ID exhaustion, and servers SHOULD include an Error-Cause attribute indicating the type of failure. In any case, further processing of the original request MUST stop.\r\n```",
              "createdAt": "2025-11-06T16:20:19Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 576,
              "body": "```suggestion\r\nAs an implementation note, it is RECOMMENDED that RADIUS/TLS implementations do not pass a single RADIUS packet to the TLS library in multiple fragments and instead assemble the RADIUS packet and pass it as one unit, in order to avoid unnecessary overhead when sending or receiving (especially if every new write generates a new TLS record) and wait times on the other endpoint.\r\n```",
              "createdAt": "2025-11-06T16:20:35Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 631,
              "body": "```suggestion\r\nFor the receiving RADIUS/DTLS endpoint, the length checks defined in {{RFC2865, Section 3}} still apply.\r\n```",
              "createdAt": "2025-11-06T16:20:51Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 649,
              "body": "```suggestion\r\nWhen implementations do not use the 5-tuple described below, note that IP address based policies MUST still be applied for all incoming packets, similar to the mandated behavior for TLS Session Resumption in {{tls_session_resumption}}.\r\n```",
              "createdAt": "2025-11-06T16:21:05Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 659,
              "body": "```suggestion\r\nRADIUS/DTLS servers SHOULD use the stateless cookie tracking technique described in {{!RFC6347, Section 4.2.1}}.\r\n```",
              "createdAt": "2025-11-06T16:21:16Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 669,
              "body": "```suggestion\r\nTaking any other action would permit unauthenticated clients to perform a DoS attack, by reusing a 5-tuple and thus causing the server to close an active (and authenticated) DTLS session.\r\n```",
              "createdAt": "2025-11-06T16:21:28Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 673,
              "body": "```suggestion\r\nAs a result, servers MUST ignore any attempts to reuse an existing 5-tuple from an active session.\r\n```",
              "createdAt": "2025-11-06T16:21:40Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 692,
              "body": "```suggestion\r\nOne common method to protect passwords is the use of the Extensible Authentication Protocol (EAP) and EAP methods that utilize TLS.\r\n```",
              "createdAt": "2025-11-06T16:21:55Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 729,
              "body": "```suggestion\r\n- Comparing client or server random used in the TLS handshake.  While this is a very effective method, it requires access to values which are normally private to the TLS implementation.\r\n- Sending a custom random number in an extension in the TLS client hello.  Again, this is very effective, but requires extension of the TLS implementation.\r\n- Comparing the incoming server certificate to all server certificates configured on the proxy.  While in some scenarios this can be a valid detection method, using the same server certificate on multiple servers would keep these servers from connecting with each other, even when this connection is legitimate.\r\n```",
              "createdAt": "2025-11-06T16:22:20Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 776,
              "body": "```suggestion\r\nTherefore, any shared secret used with RADIUS/UDP before MUST NOT be used with RADIUS/(D)TLS and (D)TLS-PSK.\r\n```",
              "createdAt": "2025-11-06T16:22:37Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 935,
              "body": "```suggestion\r\n* {{RFC6613}} mandated the use of Status-Server as watchdog algorithm, {{?RFC7360}} only recommended it.  This specification mandates the use of Status-Server for both RADIUS/TLS and RADIUS/DTLS.\r\n```",
              "createdAt": "2025-11-06T16:22:57Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            },
            {
              "originalPosition": 931,
              "body": "```suggestion\r\n* RFC6614 only requires support for the trust model \"certificates with PKIX\" ({{?RFC6614, Section 2.3}}).  This document changes this.  For servers, TLS-X.509-PKIX ({{tlsx509pkix}}, equivalent to \"certificates with PKIX\" in RFC6614) and TLS-PSK ({{tlspsk}}) is now mandated and clients must implement at least one of the two.\r\n```",
              "createdAt": "2025-11-06T16:23:31Z",
              "updatedAt": "2025-11-06T16:23:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MZylN",
          "commit": {
            "abbreviatedOid": "0d3e3a6"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T16:45:40Z",
          "updatedAt": "2025-11-06T18:01:54Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "```suggestion\r\n* Implementations MUST allow the configuration of a trust base (i.e. a set of trusted Certificate Authorities (CAs){{!RFC5280}}) for new TLS sessions.  This list SHOULD be application-specific and not use a global system trust store.\r\n```",
              "createdAt": "2025-11-06T16:45:40Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 231,
              "body": "```suggestion\r\n* When the configured trust base changes (e.g., removal of a CA from the set of trust anchors; issuance of a new CRL for a CA in the set of trust anchors), implementations SHOULD reassess the continued validity of the certificate path of all connected peers.  This can either be done by caching the peer's certificate for the duration of the connection and re-evaluating the cached certificate or by renegotiating the (D)TLS connection, either directly or by opening a new (D)TLS connection and closing the old one.\r\n```",
              "createdAt": "2025-11-06T16:46:57Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 232,
              "body": "```suggestion\r\n* Implementations SHOULD NOT keep a connection open for longer than the validity span of the peer's certificate. At the time the peer's certificate expires, the connection SHOULD be closed and re-opened.\r\n```",
              "createdAt": "2025-11-06T16:48:39Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 237,
              "body": "```suggestion\r\nRadSec endpoints SHOULD NOT be pre-configured with a set of trusted CAs by the vendor or manufacturer that are enabled by default.\r\nInstead, the endpoints SHOULD start off with an empty CA set as the trust base.\r\n```",
              "createdAt": "2025-11-06T16:49:26Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 240,
              "body": "```suggestion\r\nThis does not preclude vendors or manufacturers including their set of trusted CAs in their products, but the enabling of those lists should be a conscious decision by an administrator.\r\n```",
              "createdAt": "2025-11-06T16:49:56Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 248,
              "body": "```suggestion\r\n* RadSec clients validate the server's identity to match their local configuration, accepting the identity on the first match:\r\n```",
              "createdAt": "2025-11-06T17:44:40Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 254,
              "body": "```suggestion\r\n  * Clients MAY use other attributes of the certificate to validate the server's identity, but they MUST NOT accept any certificate without validation.\r\n```",
              "createdAt": "2025-11-06T17:44:57Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 266,
              "body": "```suggestion\r\n  * If configured by the administrator, the identity check MAY be omitted after a successful {{RFC5280}} trust chain check, e.g. if the client used dynamic lookup there is no configured client identity to verify.  The client's authorization MUST then be validated using a certificate policy OID unless both endpoints are part of a trusted network.\r\n```",
              "createdAt": "2025-11-06T17:45:42Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 267,
              "body": "```suggestion\r\n* Implementations MAY allow configuration of a set of additional properties of the certificate to check for a peer's authorization to communicate (e.g. a set of allowed values presented in  subjectAltName entries of type uniformResourceIdentifier {{RFC5280}} or a set of allowed X.509v3 Certificate Policies).\r\n```",
              "createdAt": "2025-11-06T17:46:15Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 292,
              "body": "```suggestion\r\nDepending on the trust model used, the RadSec client identity can be determined differently.\r\n```",
              "createdAt": "2025-11-06T17:46:39Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 301,
              "body": "```suggestion\r\nAs a suggestion, at least the following information from the TLS connection and the X.509 client certificate should be exposed:\r\n```",
              "createdAt": "2025-11-06T17:47:05Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 310,
              "body": "```suggestion\r\nIn TLS-PSK operation at least the following information from the TLS connection should be exposed:\r\n```",
              "createdAt": "2025-11-06T17:47:23Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 335,
              "body": "```suggestion\r\nRadSec clients transmit the same packet types on the connection they initiated as a RADIUS/UDP client would, and RadSec servers transmit the same packet types on the connections the server has accepted as a RADIUS/UDP server would.\r\n```",
              "createdAt": "2025-11-06T17:47:49Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 358,
              "body": "```suggestion\r\nSince proxying of RADIUS packets is a general issue in RADIUS and not specific to RadSec, the details of handling the Protocol-Error reply on the client side are outside of the scope of this document.\r\n```",
              "createdAt": "2025-11-06T17:48:25Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 368,
              "body": "```suggestion\r\n{{RFC6614}} also recommends that a RADIUS/TLS client observing this Accounting-Response should stop sending Accounting-Request packets to this server.\r\n```",
              "createdAt": "2025-11-06T17:48:44Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 369,
              "body": "```suggestion\r\nThis behavior, however, could lead to problems, especially in proxy fabrics, since the RADIUS client cannot determine whether the reply came from the correct server or a RADIUS proxy along the way.\r\n```",
              "createdAt": "2025-11-06T17:48:56Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 383,
              "body": "```suggestion\r\nA forwarding server may either perform its forwarding function in a\r\npass through manner, where it sends retransmissions on as soon as it\r\ngets them, or it may take responsibility for retransmissions, for\r\nexample in cases where the network link between forwarding and remote\r\nserver has very different characteristics than the link between NAS\r\nand forwarding server.\r\n```\r\n\r\n(This is a quote, so line breaks as in the quoted text)",
              "createdAt": "2025-11-06T17:49:46Z",
              "updatedAt": "2025-11-06T18:01:54Z"
            },
            {
              "originalPosition": 393,
              "body": "```suggestion\r\nThe above requirements are a logical extension of the common practice where a client stops retransmission of a packet once it decides to \"give up\" on the packet and discard it.\r\n```",
              "createdAt": "2025-11-06T17:49:58Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 406,
              "body": "```suggestion\r\nIn contrast to RADIUS/UDP, RadSec establishes a (D)TLS session before transmitting any RADIUS packets.\r\n```",
              "createdAt": "2025-11-06T17:50:11Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 432,
              "body": "```suggestion\r\nOther algorithms than the one defined in {{RFC5080}} are possible, but any timer implementations MUST have similar properties of including jitter, exponential backoff and a maximum retransmission count (MRC) or maximum retransmission duration (MRD).\r\n```",
              "createdAt": "2025-11-06T17:50:35Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 444,
              "body": "```suggestion\r\nThis is aggravated by the fact that RADIUS client/servers are often statically configured and thus form long-running peer relationships with long-running connections.\r\n```",
              "createdAt": "2025-11-06T17:52:25Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 477,
              "body": "```suggestion\r\nHowever, since both TLS and DTLS provide integrity protection and ensure that the packet was sent by the peer, a protocol violation at this stage implies that the peer is misbehaving.\r\n```",
              "createdAt": "2025-11-06T17:53:05Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 487,
              "body": "```suggestion\r\nFor request packets that would have been silently discarded in the previous specifications, servers SHOULD reply with a Protocol-Error {{!RFC7930, Section 4}} message to avoid request ID exhaustion, and servers SHOULD include an Error-Cause attribute indicating the type of failure.\r\nIn any case, further processing of the original request MUST stop.\r\n```",
              "createdAt": "2025-11-06T17:53:25Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 523,
              "body": "```suggestion\r\nHowever, if the TLS session or TCP connection is closed or broken, retries over new connections are permissible.\r\n```",
              "createdAt": "2025-11-06T17:54:20Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 586,
              "body": "```suggestion\r\nA few remaining security considerations and notes to administrators deploying RadSec are listed below.\r\n```",
              "createdAt": "2025-11-06T17:56:27Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 597,
              "body": "```suggestion\r\nAdditionally, when RADIUS proxies are used, the RADIUS client has no way of ensuring that the complete path of the RADIUS packet is protected, since RADIUS routing is done hop-by-hop and any intermediate proxy may be configured, after receiving a RADIUS packet via RadSec from one peer, to forward this packet to a different peer using the RADIUS/UDP transport profile.\r\n```",
              "createdAt": "2025-11-06T17:56:57Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 614,
              "body": "```suggestion\r\nHowever, in this case, the client certificate which the RadSec endpoint uses for outgoing connections on the client side might also satisfy the trust check of the server side.\r\n```",
              "createdAt": "2025-11-06T17:57:26Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 620,
              "body": "```suggestion\r\nSuch attacks have been described for TLS-PSK {{?RFC9257}}, dubbed a selfie-attack, but are much broader in the RADIUS/(D)TLS case.\r\nIn particular, as described above, they also apply to certificate based authentication.\r\n```",
              "createdAt": "2025-11-06T17:57:40Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 642,
              "body": "```suggestion\r\nThe underlying TLS sessions of RadSec connections may have a long lifetime.\r\n```",
              "createdAt": "2025-11-06T17:57:58Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 648,
              "body": "```suggestion\r\nIf the underlying TLS library does not perform the rotation automatically, RadSec implementations SHOULD perform this rotation manually, either by a key update of the existing TLS connection or by closing the TLS connection and opening a new one.\r\n```",
              "createdAt": "2025-11-06T17:58:13Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 657,
              "body": "```suggestion\r\nWe therefore recommend to migrate from RADIUS/UDP to RadSec.\r\n```",
              "createdAt": "2025-11-06T17:58:27Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 663,
              "body": "```suggestion\r\nFirstly, administrators may be tempted to simply migrate from RADIUS/UDP to RadSec with (D)TLS-PSK and reuse the RADIUS shared secret as (D)TLS-PSK.\r\nWhile this may seem like an easy way to upgrade RADIUS/UDP to RadSec, the cryptographic problems with the RADIUS/UDP shared secret render the shared secret potentially compromised.\r\n```",
              "createdAt": "2025-11-06T17:58:51Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 666,
              "body": "```suggestion\r\nTherefore, any shared secret used with RADIUS/UDP before MUST NOT be used with RadSec and (D)TLS-PSK.\r\n```",
              "createdAt": "2025-11-06T17:59:05Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 676,
              "body": "```suggestion\r\nWhen upgrading from RADIUS/UDP to RadSec, there may be a period of time, where the connection between client and server is configured for both transport profiles.\r\nIf the old RADIUS/UDP configuration is left configured, but not used in normal operation, e.g. due to a fail-over configuration that prefers RadSec, an attacker could disrupt the RadSec communication and force a downgrade to RADIUS/UDP.\r\nTo prevent this it is RECOMMENDED that, when the migration to RadSec is completed, the RADIUS/UDP configuration is removed.\r\nRadSec clients MUST NOT fall back to RADIUS/UDP if the RadSec communication fails, unless explicitly configured this way.\r\n```",
              "createdAt": "2025-11-06T18:00:00Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 679,
              "body": "```suggestion\r\nSpecial considerations apply for clients behind a NAT, where some clients use RADIUS/UDP and others use RadSec.\r\n```",
              "createdAt": "2025-11-06T18:00:22Z",
              "updatedAt": "2025-11-06T19:12:48Z"
            },
            {
              "originalPosition": 688,
              "body": "```suggestion\r\nSubsystems that do not implement RadSec can remain unaware of (D)TLS.\r\n```",
              "createdAt": "2025-11-06T18:00:38Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 691,
              "body": "```suggestion\r\nThe proxy can do RADIUS/UDP to some servers and RadSec to others.\r\n```",
              "createdAt": "2025-11-06T18:00:49Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 696,
              "body": "```suggestion\r\nBy moving all RADIUS/(D)TLS knowledge to a (D)TLS-aware proxy, security analysis becomes simpler, and enforcement of correct security becomes easier.\r\n```",
              "createdAt": "2025-11-06T18:01:08Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            },
            {
              "originalPosition": 828,
              "body": "```suggestion\r\n* The rules for verifying the peer certificate have been updated to follow guidance provided in {{!RFC9525}}.  Using the Common Name RDN for validation of server certificates is now forbidden.\r\n* The response to unwanted packets has changed. Endpoints should now reply with a Protocol-Error packet, which is connection-specific and should not be proxied.\r\n```",
              "createdAt": "2025-11-06T18:01:47Z",
              "updatedAt": "2025-11-06T18:01:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Mcuqc",
          "commit": {
            "abbreviatedOid": "8cac916"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "some more backported changes",
          "createdAt": "2025-11-06T19:14:07Z",
          "updatedAt": "2025-11-06T19:30:27Z",
          "comments": [
            {
              "originalPosition": 514,
              "body": "```suggestion\r\nBy moving all RadSec knowledge to a (D)TLS-aware proxy, security analysis becomes simpler, and enforcement of correct security becomes easier.\r\n```",
              "createdAt": "2025-11-06T19:14:08Z",
              "updatedAt": "2025-11-06T19:19:28Z"
            },
            {
              "originalPosition": 620,
              "body": "```suggestion\r\nEspecially the sequential nature of the connection and the connected issues like head-of-line blocking could create problems.\r\n```",
              "createdAt": "2025-11-06T19:14:28Z",
              "updatedAt": "2025-11-06T19:19:28Z"
            },
            {
              "originalPosition": 635,
              "body": "```suggestion\r\n* {{?RFC6614}} referenced {{?RFC6613}} for TCP-related specification, RFC6613 on the other hand had some specification for RADIUS/TLS.\r\n  These specifications have been merged into this document, and therefore removes {{RFC6613}} as normative reference.\r\n```",
              "createdAt": "2025-11-06T19:14:48Z",
              "updatedAt": "2025-11-06T19:19:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7McrIp",
          "commit": {
            "abbreviatedOid": "8cac916"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T19:10:45Z",
          "updatedAt": "2025-11-06T19:29:04Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I think TLS and DLTS records are slightly different and specified in different RFCs. I propose to keep the original definitions.",
              "createdAt": "2025-11-06T19:10:45Z",
              "updatedAt": "2025-11-06T19:29:04Z"
            },
            {
              "originalPosition": 185,
              "body": "This is a duplicate form the definitions section, do we need to repeat it here?",
              "createdAt": "2025-11-06T19:13:51Z",
              "updatedAt": "2025-11-06T19:29:04Z"
            },
            {
              "originalPosition": 306,
              "body": "Conflicting proposal in #78 ",
              "createdAt": "2025-11-06T19:22:59Z",
              "updatedAt": "2025-11-06T19:29:04Z"
            },
            {
              "originalPosition": 343,
              "body": "```suggestion\r\nAs TLS is a reliable transport, RADIUS/TLS clients can only retry a packet if a connection closes without that packet receiving a reply, therefore the timers MUST NOT result in retransmission of any packet.\r\n```",
              "createdAt": "2025-11-06T19:24:42Z",
              "updatedAt": "2025-11-06T19:29:04Z"
            },
            {
              "originalPosition": 417,
              "body": "This has already been reworded in current master, don't revert to the old state.",
              "createdAt": "2025-11-06T19:27:15Z",
              "updatedAt": "2025-11-06T19:29:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Mden6",
          "commit": {
            "abbreviatedOid": "cbbc047"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T20:01:03Z",
          "updatedAt": "2025-11-06T20:01:03Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\nTLS record:\r\n: As defined in TLS {{RFC5246}}.\r\n\r\nDTLS record:\r\n: As defined in DTLS {{RFC9147}}.  A DTLS record is always contained in one UDP datagram.\r\n```\r\n \r\n Basically: revert to the original source.",
              "createdAt": "2025-11-06T20:01:03Z",
              "updatedAt": "2025-11-06T20:01:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Mv9Of",
          "commit": {
            "abbreviatedOid": "cbbc047"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T16:42:08Z",
          "updatedAt": "2025-11-07T16:42:09Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "Similar text already merged. Skip this.",
              "createdAt": "2025-11-07T16:42:09Z",
              "updatedAt": "2025-11-07T16:42:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOLrzygc6xvXcn",
      "title": "TLS terminology: connection instead of session",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/96",
      "state": "MERGED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update most of the uses of 'TLS session' to 'TLS connection'. Exception is TLS session resumption which is its own concept.\r\nEdit: Also skip section named 'Session Management'. We can get back to it separately, if needed.",
      "createdAt": "2025-11-05T20:43:39Z",
      "updatedAt": "2025-11-06T19:46:06Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c7e94afe45aa9cfa28b84db4d020a3e4b54eb154",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "tls-session-to-connection",
      "headRefOid": "8abc2f8fb36bb7d34390206e4b56baf55aec6f0b",
      "closedAt": "2025-11-06T19:46:06Z",
      "mergedAt": "2025-11-06T19:46:06Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "ab2ac67b670116e553e6d42e795acfc355c91a66"
      },
      "comments": [
        {
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've reverted changes to Session Management and its subsections to make this PR clearer. Possible changes to the Session Management section can now be handled separately.",
          "createdAt": "2025-11-05T23:46:58Z",
          "updatedAt": "2025-11-05T23:46:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7MGveg",
          "commit": {
            "abbreviatedOid": "1a3370e"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T20:48:16Z",
          "updatedAt": "2025-11-05T20:48:16Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "```suggestion\r\nIf a connection that used session resumption is closed immediately after being established, the RADIUS/(D)TLS client MUST NOT re-attempt session resumption but perform a full TLS handshake instead.\r\n```\r\n\r\nRe @fmauchle 's comment: maybe it's worth adding what we mean by \"immediately after\", e.g. \"no data sent\" or \"closed after less than 5 seconds\"",
              "createdAt": "2025-11-05T20:48:16Z",
              "updatedAt": "2025-11-05T20:48:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MGz7z",
          "commit": {
            "abbreviatedOid": "1a3370e"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T20:52:17Z",
          "updatedAt": "2025-11-05T20:52:17Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "```suggestion\r\nIf an incoming (D)TLS connection or the underlying transport channel is closed or broken, then there is no way to send a RADIUS response packet to the client.\r\n```\r\n\r\nI'm not sure how to get TCP and UDP together better, but what we mean is: (D)TLS fails, or TCP is closed, or the UDP socket is broken, or our Uplink is down, or any other \"aaaaa internet\" thing happens",
              "createdAt": "2025-11-05T20:52:17Z",
              "updatedAt": "2025-11-05T20:52:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MG2Qq",
          "commit": {
            "abbreviatedOid": "1a3370e"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T20:54:23Z",
          "updatedAt": "2025-11-05T20:54:23Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I'm not exactly sure if we don't actually mean Session in this instance. Just as a reminder for me, so I don't forget.",
              "createdAt": "2025-11-05T20:54:23Z",
              "updatedAt": "2025-11-05T20:54:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MG11O",
          "commit": {
            "abbreviatedOid": "1a3370e"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T20:53:55Z",
          "updatedAt": "2025-11-05T21:38:04Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "```suggestion\nIf the connection of a resumed session is closed immediately after being established, the RADIUS/(D)TLS client MUST NOT re-attempt session resumption but perform a full TLS handshake instead.\n```",
              "createdAt": "2025-11-05T20:53:55Z",
              "updatedAt": "2025-11-05T21:38:04Z"
            },
            {
              "originalPosition": 227,
              "body": "Deleting a conection doesn't really make sense. Either it must delete data related to the connection or the session data (so session resumption is no longer possible)",
              "createdAt": "2025-11-05T21:31:43Z",
              "updatedAt": "2025-11-05T21:38:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MHrdS",
          "commit": {
            "abbreviatedOid": "1a3370e"
          },
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T21:38:17Z",
          "updatedAt": "2025-11-05T21:38:18Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I agree. 'Session' appears to be used also when there's state (session state) that the application layer software needs to keep its own purposes. This session incudes info about TLS connection, certificates from the full handshake, etc. Or this is my understanding at least.\r\n\r\nI'd merge this pull request to get the changes applied that clearly relate to (D)TLS connections. It's then easier to do what's needed for this and the respective client section.",
              "createdAt": "2025-11-05T21:38:17Z",
              "updatedAt": "2025-11-05T21:38:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDOLrzygc6x_1hr",
      "title": "Use handshake instead of negotiation where appropriate.",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/97",
      "state": "MERGED",
      "author": "h-vn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update the draft use 'handshake' instead of 'negotation' when TLS handshake is discussed.",
      "createdAt": "2025-11-06T21:12:42Z",
      "updatedAt": "2025-11-06T21:25:04Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "ab2ac67b670116e553e6d42e795acfc355c91a66",
      "headRepository": "h-vn/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "negotiation-to-handshake",
      "headRefOid": "4c0c4dbf617b13a44e7ea8b76132bb416cf8e7dd",
      "closedAt": "2025-11-06T21:25:04Z",
      "mergedAt": "2025-11-06T21:25:04Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "5c1ee75cabbfdbd388e2d5d2752ef09519b893e2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7MewXS",
          "commit": {
            "abbreviatedOid": "338fab8"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T21:22:00Z",
          "updatedAt": "2025-11-06T21:22:00Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nRADIUS/DTLS servers MUST silently discard any UDP datagram they receive over the RADIUS/DTLS port that is not a new DTLS handshake or a datagram related to a DTLS connection established earlier.\r\n```\r\n\r\nThis applies the terminology we introduced earlier.",
              "createdAt": "2025-11-06T21:22:00Z",
              "updatedAt": "2025-11-06T21:22:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDOLrzygc6yAwDQ",
      "title": "Add text for 0rtt",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/98",
      "state": "MERGED",
      "author": "Janfred",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-11-06T22:56:22Z",
      "updatedAt": "2025-11-21T12:40:15Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c49fcb98d7969edc6fea2b354def796e2ccea2af",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "feature/0rtt",
      "headRefOid": "b3fc1e228da0938e0d91b2b4d0fd4d9e63ea0fd2",
      "closedAt": "2025-11-07T16:26:00Z",
      "mergedAt": "2025-11-07T16:25:59Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "fb8ed6b4fc867c6351cd93f61bf143bb1b3184a1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7MfyKH",
          "commit": {
            "abbreviatedOid": "af98aeb"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T23:05:53Z",
          "updatedAt": "2025-11-06T23:05:53Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nThe use of 0-RTT features of (D)TLS is NOT RECOMMENDED.\r\nRADIUS packets may contain confidential data that should be protected by forward secrecy, which 0-RTT cannot provide.\r\nIf 0-RTT is used, implementations MUST also implement protection mechanisms against replay attacks.\r\n```",
              "createdAt": "2025-11-06T23:05:53Z",
              "updatedAt": "2025-11-06T23:05:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 101,
      "id": "PR_kwDOLrzygc6yLsJq",
      "title": "align use of retry terminology",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/101",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-11-07T17:03:15Z",
      "updatedAt": "2025-11-07T21:21:18Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "fb8ed6b4fc867c6351cd93f61bf143bb1b3184a1",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-use-retry",
      "headRefOid": "8a04bd3dd71fbf801b9ab3aefac2bc1f2ebad6fd",
      "closedAt": "2025-11-07T21:21:18Z",
      "mergedAt": "2025-11-07T21:21:18Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "9e7eeb3a46c5f23a61b7d36b2727e0940a40854f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7Myj6-",
          "commit": {
            "abbreviatedOid": "51437e3"
          },
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T19:02:47Z",
          "updatedAt": "2025-11-07T19:02:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Line 508: is 'retransmission' correct or should it also be 'retry'. That is 'can only retry if ... must not otherwise retry'.",
              "createdAt": "2025-11-07T19:02:47Z",
              "updatedAt": "2025-11-07T19:02:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7MyvLH",
          "commit": {
            "abbreviatedOid": "51437e3"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T19:11:58Z",
          "updatedAt": "2025-11-07T19:11:58Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "yes, it is only allowed to do retries (send over new connection) but not retransmission. ",
              "createdAt": "2025-11-07T19:11:58Z",
              "updatedAt": "2025-11-07T19:11:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Mz71I",
          "commit": {
            "abbreviatedOid": "51437e3"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T20:16:06Z",
          "updatedAt": "2025-11-07T20:16:07Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nAs TLS is a reliable transport, RADIUS/TLS clients can only retry a packet if a connection closes without that packet receiving a reply, therefore the timers MUST NOT result in retransmission of any packet.\r\nA retry is the re-sending of the same content in a newly constructed RADIUS packet, where a retransmission is the re-sending of the exact same packet over the same connection to deal with packet loss on transport.\r\n```\r\n\r\nThis is a suggestion for a definition of retry and retransmission.",
              "createdAt": "2025-11-07T20:16:06Z",
              "updatedAt": "2025-11-07T20:16:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7M06Tr",
          "commit": {
            "abbreviatedOid": "51437e3"
          },
          "author": "fmauchle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T21:08:24Z",
          "updatedAt": "2025-11-07T21:08:24Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "+1\r\nmaybe need to think where to put this definition after chapter reordering is complete.",
              "createdAt": "2025-11-07T21:08:24Z",
              "updatedAt": "2025-11-07T21:08:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 102,
      "id": "PR_kwDOLrzygc6yMAaD",
      "title": "Unify use of term endpoint",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/102",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-11-07T17:28:46Z",
      "updatedAt": "2025-11-07T19:14:18Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "fb8ed6b4fc867c6351cd93f61bf143bb1b3184a1",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "patch-1",
      "headRefOid": "b5dc715478f5c70ce65a9153eca0611feddc430a",
      "closedAt": "2025-11-07T19:14:18Z",
      "mergedAt": "2025-11-07T19:14:18Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "0b7d24fb6693bfec58dde61e7ec656a18a7a90cd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7Mye60",
          "commit": {
            "abbreviatedOid": "2389e6f"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T18:58:50Z",
          "updatedAt": "2025-11-07T18:58:50Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n* When the configured trust base changes (e.g., removal of a CA from the set of trust anchors; issuance of a new CRL for a CA in the set of trust anchors), implementations SHOULD reassess the continued validity of the certificate path of all connected peers.  This can either be done by caching the peer's certificate for the duration of the connection and re-evaluating the cached certificate or by renegotiating the (D)TLS connection, either directly or by opening a new (D)TLS connection and closing the old one.\r\n```\r\n\r\nIn this instance we do mean peers I think.",
              "createdAt": "2025-11-07T18:58:50Z",
              "updatedAt": "2025-11-07T18:58:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7Myg3b",
          "commit": {
            "abbreviatedOid": "2389e6f"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T19:00:23Z",
          "updatedAt": "2025-11-07T19:00:23Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\n* Implementations SHOULD NOT keep a connection open for longer than the validity span of the peer certificate.  At the time the peer certificate expires, the connection SHOULD be closed and re-opened.\r\n```\r\n\r\nI would keep the term peer certificate here as well.\r\nWe use it in the sentence before anyway.",
              "createdAt": "2025-11-07T19:00:23Z",
              "updatedAt": "2025-11-07T19:00:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 103,
      "id": "PR_kwDOLrzygc6yM3mv",
      "title": "Consistently use term RadSec",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/103",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-11-07T18:36:40Z",
      "updatedAt": "2025-11-07T19:18:25Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "0b7d24fb6693bfec58dde61e7ec656a18a7a90cd",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-terminology-radsec",
      "headRefOid": "2c60f8c8906779f331b653cdbd4e4d5bc3bbd077",
      "closedAt": "2025-11-07T19:18:24Z",
      "mergedAt": "2025-11-07T19:18:24Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "314758ba971952ea237803bf4a8b75044b577ab7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7Mya4Y",
          "commit": {
            "abbreviatedOid": "b1fa70c"
          },
          "author": "h-vn",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I looked through the changes and they look good to me. No typos etc. spotted.",
          "createdAt": "2025-11-07T18:55:25Z",
          "updatedAt": "2025-11-07T18:55:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 104,
      "id": "PR_kwDOLrzygc6yNr9r",
      "title": "Remove X509-FINGERPRINT",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/104",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #99 ",
      "createdAt": "2025-11-07T19:49:08Z",
      "updatedAt": "2025-11-08T21:33:23Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "314758ba971952ea237803bf4a8b75044b577ab7",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-x509-fingerprint",
      "headRefOid": "3dd93ef4242f9a83810e5c1d61d9a927573303da",
      "closedAt": "2025-11-08T21:33:23Z",
      "mergedAt": "2025-11-08T21:33:23Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "ce7a04ea401c17428ec9a1a1486602ea07bcbd55"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7M1PBx",
          "commit": {
            "abbreviatedOid": "f8f0858"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-07T21:28:57Z",
          "updatedAt": "2025-11-07T21:28:57Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n* The recommendation for TLS-X509-FINGERPRINT ({{RFC6614, Section 2.3}}) is removed since the model has not been implemented by any known implementation of the experimental RADIUS/(D)TLS specifications.\r\n```\r\n\r\nWe've just changed",
              "createdAt": "2025-11-07T21:28:57Z",
              "updatedAt": "2025-11-07T21:28:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOLrzygc6yN0Vg",
      "title": "Remove raw pubkey auth",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/105",
      "state": "MERGED",
      "author": "fmauchle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Raw public key was not part of 6614, we therefore should not introduce new auth methods here. Besides there are no (?) implementations.",
      "createdAt": "2025-11-07T20:01:26Z",
      "updatedAt": "2025-11-08T21:45:28Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "ce7a04ea401c17428ec9a1a1486602ea07bcbd55",
      "headRepository": "fmauchle/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "fmauchle-raw-pubkey",
      "headRefOid": "fc005f334c780fcd446b31e484e566e2c0e8542a",
      "closedAt": "2025-11-08T21:45:28Z",
      "mergedAt": "2025-11-08T21:45:28Z",
      "mergedBy": "Janfred",
      "mergeCommit": {
        "oid": "33084a347e7df953856fc07a44f08592c61c7d2b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7M9sYb",
          "commit": {
            "abbreviatedOid": "f83c2a2"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-08T21:35:56Z",
          "updatedAt": "2025-11-08T21:35:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n```\r\n\r\nArtifact of edit that had nothing to do with the PR",
              "createdAt": "2025-11-08T21:35:56Z",
              "updatedAt": "2025-11-08T21:35:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDOLrzygc67AMN8",
      "title": "Make changes to the document organization to address shepherd review \u2026",
      "url": "https://github.com/radext-wg/draft-ietf-radext-radiusdtls-bis/pull/106",
      "state": "OPEN",
      "author": "mrw42",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "alandekok"
      ],
      "labels": [],
      "body": "\u2026comments. Other minor edits.",
      "createdAt": "2025-12-30T17:22:33Z",
      "updatedAt": "2026-01-16T08:32:53Z",
      "baseRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "baseRefName": "main",
      "baseRefOid": "c6f4db1276eb525d5557900b6d9f9e9d27df9d6e",
      "headRepository": "radext-wg/draft-ietf-radext-radiusdtls-bis",
      "headRefName": "mrc/shep-rev2",
      "headRefOid": "5b3135a2b36c12b96a12c68fd9e7e11a212886dd",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrzygc7adhCu",
          "commit": {
            "abbreviatedOid": "5b3135a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-15T11:30:42Z",
          "updatedAt": "2026-01-15T11:31:00Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "\r\nI think that the introduction is not the place to reference this, since this is also an issue with RADIUS/DTLS, so we don't fix this (unless RADIUS/TLS is used).\r\n\r\nAdditionally: This should be an informative reference and not a normative one.\r\nThe referenced RFC is not RADIUS related, so it should at least include more detail why this explains issues with RAIDUS/UDP.\r\n\r\n\r\n```suggestion\r\nFor an updated version of RadSec without need for MD5 see {{?RFC9765}}.\r\n```",
              "createdAt": "2026-01-15T11:30:42Z",
              "updatedAt": "2026-01-15T11:31:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7adlp7",
          "commit": {
            "abbreviatedOid": "5b3135a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-15T11:36:46Z",
          "updatedAt": "2026-01-15T11:36:56Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "The section about differences in unwanted packet handling is not an implementation consideration.\r\nThe section should be left here, because it is directly related to the previous text.\r\nThis is important to read for everyone that implemented the previous spec, and I fear that people will skip over the implementation consideration section quicker than over this.",
              "createdAt": "2026-01-15T11:36:47Z",
              "updatedAt": "2026-01-15T11:36:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7adwZ0",
          "commit": {
            "abbreviatedOid": "5b3135a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-15T11:47:59Z",
          "updatedAt": "2026-01-15T11:47:59Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "This section should not be simply removed. It can be moved into the section \"Radsec Packet and connection handling\", but the text should sill be left in the document.",
              "createdAt": "2026-01-15T11:47:59Z",
              "updatedAt": "2026-01-15T11:47:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7adxCK",
          "commit": {
            "abbreviatedOid": "5b3135a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-15T11:48:53Z",
          "updatedAt": "2026-01-15T11:48:53Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nRADIUS is a widely deployed Authentication, Authorization and Accounting (AAA) protocol defined in {{!RFC2865}}, {{!RFC2866}}, and {{!RFC5176}}, among others.\r\n```",
              "createdAt": "2026-01-15T11:48:53Z",
              "updatedAt": "2026-01-15T11:48:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7ad1ye",
          "commit": {
            "abbreviatedOid": "5b3135a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-15T11:55:07Z",
          "updatedAt": "2026-01-15T11:55:08Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "```suggestion\r\nThe client port used for a RadSec connections is not fixed -- it is selected by the client for each RADIUS session.\r\n```\r\nI would not use \"assign\" here, because it's not really important. Just let the OS do its thing.",
              "createdAt": "2026-01-15T11:55:07Z",
              "updatedAt": "2026-01-15T11:55:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7aeCF0",
          "commit": {
            "abbreviatedOid": "5b3135a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-15T12:10:38Z",
          "updatedAt": "2026-01-15T12:10:38Z",
          "comments": [
            {
              "originalPosition": 490,
              "body": "This is not about fragments in the IP sense, and it's not limited to \"forwarding\" but more in general sending.\r\n\r\nI would recommend leaving this section just where it was, because there it makes sense, here it is a little bit difficult to find the connection (and the right headline, I though of some, but I couldn't find the right one)",
              "createdAt": "2026-01-15T12:10:38Z",
              "updatedAt": "2026-01-15T12:10:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7aeDaq",
          "commit": {
            "abbreviatedOid": "5b3135a"
          },
          "author": "Janfred",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-15T12:12:15Z",
          "updatedAt": "2026-01-15T12:12:16Z",
          "comments": [
            {
              "originalPosition": 311,
              "body": "See below, I would recommend leaving this here. It's directly related to the text before and should not be moved. It loses its context.",
              "createdAt": "2026-01-15T12:12:16Z",
              "updatedAt": "2026-01-15T12:12:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7akzK_",
          "commit": {
            "abbreviatedOid": "5b3135a"
          },
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-15T18:46:58Z",
          "updatedAt": "2026-01-15T18:46:58Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "I would say \"the client source port\", and perhaps just say something like \"is typically an ephemeral port picked automatically by the Operating System\"",
              "createdAt": "2026-01-15T18:46:58Z",
              "updatedAt": "2026-01-15T18:46:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7ak07q",
          "commit": {
            "abbreviatedOid": "5b3135a"
          },
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-15T18:49:23Z",
          "updatedAt": "2026-01-15T18:57:40Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I am fine either way",
              "createdAt": "2026-01-15T18:49:23Z",
              "updatedAt": "2026-01-15T18:57:40Z"
            },
            {
              "originalPosition": 27,
              "body": "I can see the use of it. What was the reasoning for removing it?",
              "createdAt": "2026-01-15T18:51:44Z",
              "updatedAt": "2026-01-15T18:57:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrzygc7atnpS",
          "commit": {
            "abbreviatedOid": "5b3135a"
          },
          "author": "smyslov",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I believe we should not spend too much time on editorial issues. Let the RFC Editor do their job. I also think that implementers are often clever enough and we do not need to treat them as clueless people who constantly lose context while reading the document.",
          "createdAt": "2026-01-16T07:48:13Z",
          "updatedAt": "2026-01-16T08:32:53Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Me too.",
              "createdAt": "2026-01-16T07:48:13Z",
              "updatedAt": "2026-01-16T08:32:53Z"
            },
            {
              "originalPosition": 27,
              "body": "I believe that the summary (that the RADIUS protocol is unchanged) is included below. I don't have strong opinion whether the verbatim list of all the things that are unchanged is needed or a couple of summary sentences are enough,, to me this is a matter of taste. I'm fine either way.",
              "createdAt": "2026-01-16T07:58:38Z",
              "updatedAt": "2026-01-16T08:32:53Z"
            },
            {
              "originalPosition": 31,
              "body": "I think that if the text persists, then still the RFC2119 MUST above is not needed - lowercase \"must\" (or just \"are\") is OK. ",
              "createdAt": "2026-01-16T08:03:41Z",
              "updatedAt": "2026-01-16T08:32:53Z"
            },
            {
              "originalPosition": 80,
              "body": "I agree with Paul's text. That said, I believe this all are nits.",
              "createdAt": "2026-01-16T08:07:41Z",
              "updatedAt": "2026-01-16T08:32:53Z"
            },
            {
              "originalPosition": 311,
              "body": "I think that this particular para is not as important as the previous one (it only affects performace), thus I can see the reasons why it is moved to implementation considerations (this recommendation can be ignored without lose of interoperability). I'm fine either way - leaving the text here or moving to implementation considerations, I don't think it is all that important.",
              "createdAt": "2026-01-16T08:19:03Z",
              "updatedAt": "2026-01-16T08:32:53Z"
            }
          ]
        }
      ]
    }
  ]
}